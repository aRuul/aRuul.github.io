<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Spring5课堂笔记 | aRuul的无名小站</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://aruul.github.io/favicon.ico?v=1619706089696">
<link rel="stylesheet" href="https://aruul.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



<script async src="//code.tidio.co/0llaydzaqpj2momyrcycfplv2h2my3av.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

    <meta name="description" content="这是看b站狂神的视频总结的笔记


Spring5

1.、Spring

1.1、简介
1.2 优点
1.3 组成
1.4、扩展


2、IoC（控制反转）理论推导

IoC本质


3、HolleSpring
4、IoC创建对象的方式
..." />
    <meta name="keywords" content="spring,java" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://aruul.github.io">
        <img src="https://aruul.github.io/images/avatar.png?v=1619706089696" class="site-logo">
        <h1 class="site-title">aRuul的无名小站</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/essay" class="site-nav">
            随笔
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/aRuul" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span> | <a class="rss" href="https://aruul.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Spring5课堂笔记</h2>
            <div class="post-date">2021-03-20</div>
            
              <div class="feature-container" style="background-image: url('https://gitee.com/aruul/a-ru-img/raw/master/img/20210411122802.png')">
              </div>
            
            <div class="post-content" v-pre>
              <p>这是看b站狂神的视频总结的笔记</p>
<!--more-->
<p><ul class="markdownIt-TOC">
<li><a href="#spring5">Spring5</a>
<ul>
<li><a href="#1-spring">1.、Spring</a>
<ul>
<li><a href="#11-%E7%AE%80%E4%BB%8B">1.1、简介</a></li>
<li><a href="#12-%E4%BC%98%E7%82%B9">1.2 优点</a></li>
<li><a href="#13-%E7%BB%84%E6%88%90">1.3 组成</a></li>
<li><a href="#14-%E6%89%A9%E5%B1%95">1.4、扩展</a></li>
</ul>
</li>
<li><a href="#2-ioc%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC">2、IoC（控制反转）理论推导</a>
<ul>
<li><a href="#ioc%E6%9C%AC%E8%B4%A8">IoC本质</a></li>
</ul>
</li>
<li><a href="#3-hollespring">3、HolleSpring</a></li>
<li><a href="#4-ioc%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F">4、IoC创建对象的方式</a></li>
<li><a href="#5-spring%E9%85%8D%E7%BD%AE">5、Spring配置</a>
<ul>
<li><a href="#51-%E5%88%AB%E5%90%8D">5.1、别名</a></li>
<li><a href="#52-bean%E7%9A%84%E9%85%8D%E7%BD%AE">5.2、Bean的配置</a></li>
<li><a href="#53-import">5.3、import</a></li>
</ul>
</li>
<li><a href="#6-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di">6、依赖注入（DI）</a>
<ul>
<li><a href="#61-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5">6.1、构造器注入</a></li>
<li><a href="#62-set%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5%E9%87%8D%E7%82%B9">6.2、set方式注入【重点】</a></li>
<li><a href="#63-%E6%8B%93%E5%B1%95%E6%B3%A8%E5%85%A5">6.3、拓展注入</a></li>
<li><a href="#64-bean%E4%BD%9C%E7%94%A8%E5%9F%9F">6.4、Bean作用域</a></li>
</ul>
</li>
<li><a href="#7-bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">7、Bean的自动装配</a>
<ul>
<li><a href="#71%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">7.1测试：自动装配</a></li>
<li><a href="#72-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">7.2、使用注解实现自动装配</a>
<ul>
<li><a href="#721-autowired">7.2.1、@Autowired</a></li>
<li><a href="#722-autowiredqualifier">7.2.2、@Autowired+@Qualifier</a></li>
<li><a href="#723-resource">7.2.3、@Resource</a></li>
<li><a href="#%E5%8C%BA%E5%88%AB">区别：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91">8、使用注解开发</a>
<ul>
<li><a href="#81-bean">8.1、bean</a></li>
<li><a href="#82-%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5value">8.2、属性如何注入@value</a></li>
<li><a href="#83-%E8%A1%8D%E7%94%9F%E7%9A%84%E6%B3%A8%E8%A7%A3">8.3、衍生的注解</a></li>
<li><a href="#84-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%BD%AE">8.4、自动装配置</a></li>
<li><a href="#85-%E4%BD%9C%E7%94%A8%E5%9F%9Fscope">8.5、作用域@scope</a></li>
<li><a href="#86-%E5%B0%8F%E7%BB%93">8.6、小结</a></li>
</ul>
</li>
<li><a href="#9-%E4%BD%BF%E7%94%A8java%E7%9A%84%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AEspring">9、使用Java的方式配置Spring</a></li>
<li><a href="#10-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">10、动态代理</a>
<ul>
<li><a href="#101-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">10.1、静态代理</a></li>
<li><a href="#102-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">10.2、动态代理</a></li>
</ul>
</li>
<li><a href="#11-aop">11、AOP</a>
<ul>
<li><a href="#111-%E4%BB%80%E4%B9%88%E6%98%AFaop">11.1、什么是AOP</a></li>
<li><a href="#112-aop%E5%9C%A8spring%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8">11.2、AOP在Spring中的使用</a></li>
<li><a href="#113-%E4%BD%BF%E7%94%A8spring%E5%AE%9E%E7%8E%B0aop">11.3、使用Spring实现AOP</a>
<ul>
<li><a href="#1131-%E6%96%B9%E6%B3%95%E4%B8%80%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fspring%E6%8E%A5%E5%8F%A3">11.3.1、方法一：使用原生spring接口</a></li>
<li><a href="#1132-%E6%96%B9%E6%B3%95%E4%BA%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%AE%9E%E7%8E%B0aop">11.3.2、方法二：自定义类实现AOP</a></li>
<li><a href="#1133-%E6%96%B9%E6%B3%95%E4%B8%89%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0">11.3.3、方法三：使用注解实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#12-%E6%95%B4%E5%90%88mybatis">12、整合mybatis</a>
<ul>
<li><a href="#121-mybatis-spring-%E6%96%B9%E5%BC%8F%E4%B8%80">12.1、mybatis-spring-方式一</a></li>
<li><a href="#122-mybatis-spring-%E6%96%B9%E5%BC%8F%E4%BA%8C">12.2、mybatis-spring-方式二</a></li>
</ul>
</li>
<li><a href="#13-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1">13. 声明式事务</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="spring5">Spring5</h1>
<h2 id="1-spring">1.、Spring</h2>
<h3 id="11-简介">1.1、简介</h3>
<ul>
<li>
<p>Spring ——&gt; 春天，为开源软件带来了春天</p>
</li>
<li>
<p>2002，首次推出了Spring框架的雏形：interface21框架！</p>
</li>
<li>
<p>Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版</p>
</li>
<li>
<p>Spring的理念：使用现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！</p>
</li>
<li>
<p>SSH：Struct2 + Spring + Hibernate（全自动持久化框架）！</p>
</li>
<li>
<p>SSM：SpringMVC + Spring + MyBatis（半自动持久化框架，可自定义性质更强）！</p>
</li>
</ul>
<p>spring官网： https://spring.io/projects/spring-framework#overview</p>
<p>官方下载： https://repo.spring.io/release/org/springframework/spring/</p>
<p>GitHub： https://github.com/spring-projects/spring-framework</p>
<p>Spring Web MVC： <a href="https://mvnrepository.com/artifact/org.springframework/spring-webmvc/5.2.7.RELEASE">spring-webmvc最新版</a></p>
<p>Spring Web MVC和Spring-JDBC的pom配置文件：</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="12-优点">1.2 优点</h3>
<ul>
<li>Spring是一个开源的免费的框架（容器）！</li>
<li>Spring是一个轻量级的、非入侵式的框架！</li>
<li>控制反转（IoC），面向切面编程（AOP）</li>
<li>支持事务的处理，对框架整合的支持！（几乎市面上所有热门框架都能整合进去）！</li>
</ul>
<p>=== 总结一句话：Spring就是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的框架！ ===</p>
<h3 id="13-组成">1.3 组成</h3>
<figure data-type="image" tabindex="1"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvU3ByaW5nNyVFNSVBNCVBNyVFNiVBOCVBMSVFNSU5RCU5Ny5wbmc" alt="img" loading="lazy"></figure>
<h3 id="14-扩展">1.4、扩展</h3>
<p>现代化的java开发 -&gt; 基于Spring的开发！</p>
<figure data-type="image" tabindex="2"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvMjAyMDA4MDEwMzA4MjAucG5n" alt="img" loading="lazy"></figure>
<ul>
<li>Spring Boot
<ul>
<li>一个快速开发的脚手架</li>
<li>基于SpringBoot可以快速开发单个微服务</li>
<li>约定大于配置！</li>
</ul>
</li>
<li>Spring Cloud
<ul>
<li>SpringCloud是基于SpringBoot实现的！</li>
</ul>
</li>
</ul>
<p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！</p>
<h2 id="2-ioc控制反转理论推导">2、IoC（控制反转）理论推导</h2>
<p><strong>传统</strong>的调用</p>
<ol>
<li>
<p>UserDao</p>
<pre><code class="language-java">package dao;
public interface UserDao {
	void getUser();
}
</code></pre>
</li>
<li>
<p>UserDaoImp</p>
<pre><code class="language-java">package dao;
public class UserDaoImpl implements UserDao{
	public void getUser() {
		System.out.println(&quot;默认获取用户数据&quot;);	
	}
}
</code></pre>
</li>
<li>
<p>UserSevice</p>
<pre><code class="language-java">package Service;
public interface UserService {
	void getUser();
}
</code></pre>
</li>
<li>
<p>UserServiceImp</p>
<pre><code class="language-java">package Service;
import dao.UserDao;
import dao.UserDaoImpl;

public class UserServiceImpl implements UserService{
		UserDao userDao = new UserDaoImpl();		
		public void getUser(){
			userDao.getUser();
		}	
}
</code></pre>
</li>
</ol>
<p>测试</p>
<pre><code class="language-java">package holle0;
import Service.UserService;
import Service.UserServiceImpl;

public class MyTest0 {
	public static void main(String[] args) {
		// 用户实际调用的是业务层，dao层他们不需要接触
		UserService userService = new UserServiceImpl();
		userService.getUser();
	}
}
</code></pre>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！</p>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExMjI3NDI1ODEucG5n" alt="image-20200801122742581" loading="lazy"><br>
**改良：**我们使用一个Set接口实现。已经发生了革命性的变化！</p>
<pre><code class="language-java">//在Service层的实现类(UserServiceImpl)增加一个Set()方法
//利用set动态实现值的注入！
//DAO层并不写死固定调用哪一个UserDao的实现类
//而是通过Service层调用方法设置实现类！
private UserDao userDao;
public void setUserDao(UserDao userDao){
    this.userDao = userDao;
}
</code></pre>
<p>set() 方法实际上是动态改变了 UserDao userDao 的 初始化部分（<strong>new UserDaoImpl()</strong>）</p>
<p>测试中加上</p>
<pre><code class="language-java">((UserServiceImpl)userService).setUserDao(new UserDaoImpl());
</code></pre>
<ul>
<li>之前，程序是主动创建对象！<strong>控制权在程序猿手上</strong>！</li>
<li>使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！（<strong>主动权在客户手上</strong>）</li>
</ul>
<p>本质上解决了问题，程序员不用再去管理对象的创建</p>
<p>系统的耦合性大大降低，可以更专注在业务的实现上</p>
<p>这是IoC（控制反转）的原型，反转(理解)：主动权交给了用户</p>
<figure data-type="image" tabindex="3"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExMjI4MDU3NjkucG5n" alt="image-20200801122805769" loading="lazy"></figure>
<h3 id="ioc本质">IoC本质</h3>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExMjM1MTg5NzQucG5n" alt="image-20200801123518974" loading="lazy"><br>
<img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvMjAyMDA4MDExMjMyMzUucG5n" alt="img" loading="lazy"><br>
<img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExMjMzNDgyMDcucG5n" alt="image-20200801123348207" loading="lazy"><br>
<img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExMjM0NTA4OTcucG5n" alt="image-20200801123450897" loading="lazy"></p>
<h2 id="3-hollespring">3、HolleSpring</h2>
<p>在父模块中导入jar包</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
	&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
	&lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>pojo的Hello.java</p>
<pre><code class="language-java">package pojo;

public class Hello {

	private String str;
	
	public String getStr() {
		return str;
	}

	public void setStr(String str) {
		this.str = str;
	}
	
	@Override
	public String toString() {
		return &quot;Holle [str=&quot; + str + &quot;]&quot;;
	}
}
</code></pre>
<p>在resource里面的xml配置</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


    &lt;!--在Spring中创建对象，在Spring这些都称为bean
    	类型 变量名 = new 类型();
    	Holle holle = new Holle();
    	
    	bean = 对象(holle)
    	id = 变量名(holle)
    	class = new的对象(new Holle();)
    	property 相当于给对象中的属性设值,让str=&quot;Spring&quot;
    --&gt;
    
    &lt;bean id=&quot;hello&quot; class=&quot;pojo.Hello&quot;&gt;
        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试类MyTest</p>
<pre><code class="language-java">package holle1;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import pojo.Hello;

public class MyTest {

	public static void main(String[] args) {
		//获取Spring的上下文对象
		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
		//我们的对象下能在都在spring·中管理了，我们要使用，直接取出来就可以了
		Hello holle = (Hello) context.getBean(&quot;hello&quot;);
		System.out.println(holle.toString());
	}

}
</code></pre>
<p>核心用set注入，所以必须要有下面的se()方法</p>
<pre><code class="language-java">//Hello类
public void setStr(String str) {
		this.str = str;
	}
</code></pre>
<p><strong>思考：</strong></p>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExNjUxNTYyNTkucG5n" alt="image-20200801165156259" loading="lazy"><br>
IoC：对象由Spring 来创建，管理，装配！</p>
<p><strong>弹幕评论里面的理解：</strong></p>
<p>原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待，就相当于你请人吃饭<br>
现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的你需要的菜送上来<br>
IoC：炒菜这件事，不再由你自己来做，而是委托给了第三方__餐厅来做</p>
<p>此时的区别就是，如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来</p>
<p>.</p>
<p>在前面第一个module试试引入Spring</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userDaomSql&quot; class=&quot;dao.UserDaoMysqlImpl&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;userServiceImpl&quot; class=&quot;service.UserServiceImp&quot;&gt;
        &lt;!--ref引用spring中已经创建很好的对象--&gt;
        &lt;!--value是一个具体的值,基本数据类型--&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDaomSql&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>第一个module改良后测试</p>
<pre><code class="language-java">package holle0;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import service.UserServiceImpl;

public class MyTest0 {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
		UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(&quot;userServiceImpl&quot;);
		userServiceImpl.getUser();
	}
}
</code></pre>
<p><strong>总结：</strong></p>
<p>所有的类都要装配的beans.xml 里面；</p>
<p>所有的bean 都要通过容器去取；</p>
<p>容器里面取得的bean，拿出来就是一个对象，用对象调用方法即可；</p>
<h2 id="4-ioc创建对象的方式">4、IoC创建对象的方式</h2>
<ol>
<li>使用无参构造创建对象，默认。</li>
<li>使用有参构造（如下）</li>
</ol>
<p>下标赋值</p>
<p>index指的是有参构造中参数的下标，下标从0开始;</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;chen&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>类型赋值（不建议使用）</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuang&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>直接通过参数名（掌握）</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;kuang&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
&lt;!-- 比如参数名是name，则有name=&quot;具体值&quot; --&gt;
</code></pre>
<p>注册bean之后就对象的初始化了（<strong>类似 new 类名()</strong>）</p>
<p>弹幕评论：</p>
<p>name方式还需要无参构造和set方法,index和type只需要有参构造</p>
<p>就算是new 两个对象，也是只有一个实例（<strong>单例模式：全局唯一</strong>）</p>
<pre><code class="language-java">User user = (User) context.getBean(&quot;user&quot;);
User user2 = (User) context.getBean(&quot;user&quot;);
system.out.println(user == user2)//结果为true
</code></pre>
<p>总结：在配置文件加载的时候，容器(&lt; bean&gt;)中管理的对象就已经初始化了</p>
<h2 id="5-spring配置">5、Spring配置</h2>
<h3 id="51-别名">5.1、别名</h3>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;chen&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;alias name=&quot;user&quot; alias=&quot;userLove&quot;/&gt;
&lt;!-- 使用时
	User user2 = (User) context.getBean(&quot;userLove&quot;);	
--&gt;
</code></pre>
<h3 id="52-bean的配置">5.2、Bean的配置</h3>
<pre><code class="language-xml">&lt;!--id：bean的唯一标识符，也就是相当于我们学的对象名
class：bean对象所对应的会限定名：包名+类型
name：也是别名，而且name可以同时取多个别名 --&gt;
&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; name=&quot;u1 u2,u3;u4&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;chen&quot;/&gt;
&lt;/bean&gt;
&lt;!-- 使用时
	User user2 = (User) context.getBean(&quot;u1&quot;);	
--&gt;
</code></pre>
<h3 id="53-import">5.3、import</h3>
<p>import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个</p>
<p>假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利<br>
用import将所有人的beans.xml合并为一个总的！</p>
<ul>
<li>
<p>张三(beans.xm1)</p>
</li>
<li>
<p>李四(beans2.xm1)</p>
</li>
<li>
<p>王五(beans3.xm1)</p>
</li>
<li>
<p>applicationContext.xml</p>
<pre><code class="language-xml">&lt;import resource=&quot;beans.xm1&quot;/&gt;
&lt;import resource=&quot;beans2.xml&quot;/&gt;
&lt;import resource=&quot;beans3.xm1&quot;/&gt;
</code></pre>
</li>
</ul>
<p><strong>使用的时候，直接使用总的配置就可以了</strong></p>
<p>弹幕评论：</p>
<p>按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个</p>
<h2 id="6-依赖注入di">6、依赖注入（DI）</h2>
<h3 id="61-构造器注入">6.1、构造器注入</h3>
<p>第4点有提到</p>
<h3 id="62-set方式注入重点">6.2、set方式注入【重点】</h3>
<p>依赖注入：set注入！</p>
<ul>
<li>依赖：bean对象的创建依赖于容器</li>
<li>注入：bean对象中的所有属性，由容器来注入</li>
</ul>
<p>【环境搭建】</p>
<ol>
<li>
<p>复杂类型</p>
<p>Address类</p>
</li>
<li>
<p>真实测试对象</p>
<p>Student类</p>
</li>
<li>
<p>beans.xml</p>
</li>
<li>
<p>测试</p>
<p>MyTest3</p>
</li>
</ol>
<p>Student类</p>
<pre><code class="language-java">package pojo;

import java.util.*;
@Get
@Set
public class Student {
//别忘了写get和set方法（用lombok注解也行）
    private String name;
    private Address address;

    private String[] books;
    private List&lt;String&gt; hobbies;

    private Map&lt;String, String&gt; card;
    private Set&lt;String&gt; game;

    private Properties infor;
    private String wife;

    @Override
    public String toString() {
        return &quot;Student{&quot; +&quot;\n&quot;+
                &quot;name='&quot; + name + '\'' +&quot;\n&quot;+
                &quot;, address=&quot; + address.toString() +&quot;\n&quot;+
                &quot;, books=&quot; + Arrays.toString(books) +&quot;\n&quot;+
                &quot;, hobbies=&quot; + hobbies +&quot;\n&quot;+
                &quot;, card=&quot; + card +&quot;\n&quot;+
                &quot;, game=&quot; + game +&quot;\n&quot;+
                &quot;, infor=&quot; + infor +&quot;\n&quot;+
                &quot;, wife='&quot; + wife + '\'' +&quot;\n&quot;+
                '}';
    }
}
</code></pre>
<p>Address类</p>
<pre><code class="language-java">package pojo;

public class Address {

    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &quot;Address{&quot; +
                &quot;address='&quot; + address + '\'' +
                '}';
    }
}
</code></pre>
<p>beans.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

	&lt;bean id=&quot;address&quot; class=&quot;pojo.Address&quot;&gt;
		&lt;property name=&quot;address&quot; value=&quot;address你好&quot; /&gt;
	&lt;/bean&gt;

	&lt;bean id=&quot;student&quot; class=&quot;pojo.Student&quot;&gt;
		&lt;!--第一种，普通值注入 --&gt;
		&lt;property name=&quot;name&quot; value=&quot;name你好&quot; /&gt;
		&lt;!--第二种，ref注入 --&gt;
		&lt;property name=&quot;address&quot; ref=&quot;address&quot; /&gt;

		&lt;!--数组注入 --&gt;
		&lt;property name=&quot;books&quot;&gt;
			&lt;array&gt;
				&lt;value&gt;三国&lt;/value&gt;
				&lt;value&gt;西游&lt;/value&gt;
				&lt;value&gt;水浒&lt;/value&gt;
			&lt;/array&gt;
		&lt;/property&gt;

		&lt;!--list列表注入 --&gt;
		&lt;property name=&quot;hobbies&quot;&gt;
			&lt;list&gt;
				&lt;value&gt;唱&lt;/value&gt;
				&lt;value&gt;跳&lt;/value&gt;
				&lt;value&gt;rap&lt;/value&gt;
				&lt;value&gt;篮球&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;

		&lt;!--map键值对注入 --&gt;
		&lt;property name=&quot;card&quot;&gt;
			&lt;map&gt;
				&lt;entry key=&quot;username&quot; value=&quot;root&quot; /&gt;
				&lt;entry key=&quot;password&quot; value=&quot;root&quot; /&gt;
			&lt;/map&gt;
		&lt;/property&gt;

		&lt;!--set(可去重)注入 --&gt;
		&lt;property name=&quot;game&quot;&gt;
			&lt;set&gt;
				&lt;value&gt;wangzhe&lt;/value&gt;
				&lt;value&gt;lol&lt;/value&gt;
				&lt;value&gt;galname&lt;/value&gt;
			&lt;/set&gt;
		&lt;/property&gt;

		&lt;!--空指针null注入 --&gt;
		&lt;property name=&quot;wife&quot;&gt;
			&lt;null&gt;&lt;/null&gt;
		&lt;/property&gt;

		&lt;!--properties常量注入 --&gt;
		&lt;property name=&quot;infor&quot;&gt;
			&lt;props&gt;
				&lt;prop key=&quot;id&quot;&gt;20200802&lt;/prop&gt;
				&lt;prop key=&quot;name&quot;&gt;cbh&lt;/prop&gt;
			&lt;/props&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>MyTest3</p>
<pre><code class="language-java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import pojo.Student;

public class MyTest3 {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
		Student stu = (Student) context.getBean(&quot;student&quot;);
		System.out.println(stu.toString());
	}	
}
</code></pre>
<h3 id="63-拓展注入">6.3、拓展注入</h3>
<p>官方文档位置</p>
<figure data-type="image" tabindex="4"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIxNDI3MTcyMTYucG5n" alt="image-20200802142717216" loading="lazy"></figure>
<p>pojo增加User类</p>
<pre><code class="language-java">package pojo;

public class User {
    private String name;
    private int id;
	public User() {
        
	}
	public User(String name, int id) {
		super();
		this.name = name;
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	@Override
	public String toString() {
		return &quot;User [name=&quot; + name + &quot;, id=&quot; + id + &quot;]&quot;;
	}
}
</code></pre>
<p>注意： beans 里面加上这下面两行</p>
<p>使用p和c命名空间需要导入xml约束</p>
<p>xmlns:p=“http://www.springframework.org/schema/p”<br>
xmlns:c=“http://www.springframework.org/schema/c”</p>
<pre><code class="language-xml">?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--p命名空间注入/set注入，可以直接注入属性的值-》property--&gt;
    &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; p:name=&quot;cxk&quot; p:id=&quot;20&quot; &gt;
    &lt;/bean&gt;

    &lt;!--c命名空间，通过构造器注入，需要写入有参和无参构造方法-》construct-args--&gt;
    &lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:name=&quot;cbh&quot; c:id=&quot;22&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="language-java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
User user = context.getBean(&quot;user&quot;,User.class);//确定class对象，就不用再强转了
System.out.println(user.toString());
</code></pre>
<h3 id="64-bean作用域">6.4、Bean作用域</h3>
<figure data-type="image" tabindex="5"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIxNDM0MDExNjUucG5n" alt="image-20200802143401165" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIxNDMzNDI1ODYucG5n" alt="image-20200802143342586" loading="lazy"></figure>
<ol>
<li>
<p>单例模式（默认）</p>
<pre><code class="language-xml">&lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:name=&quot;cxk&quot; c:age=&quot;19&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
1
</code></pre>
</li>
</ol>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIxNDM4MDIwMDUucG5n" alt="image-20200802143802005" loading="lazy"><br>
弹幕评论：单例模式是把对象放在pool中，需要再取出来，使用的都是同一个对象实例</p>
<ol>
<li>
<p>原型模式: 每次从容器中get的时候，都产生一个新对象！</p>
<pre><code class="language-xml">&lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:name=&quot;cxk&quot; c:age=&quot;19&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
1
</code></pre>
</li>
</ol>
<figure data-type="image" tabindex="7"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIxNDM4MjYyMjcucG5n" alt="image-20200802143826227" loading="lazy"></figure>
<ol>
<li>其余的request、session、application这些只能在web开放中使用！</li>
</ol>
<h2 id="7-bean的自动装配">7、Bean的自动装配</h2>
<ul>
<li>自动装配是Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文自动寻找，并自动给bean装配属性</li>
</ul>
<p>在Spring中有三种装配的方式</p>
<ol>
<li>
<p>在xml中显示配置</p>
</li>
<li>
<p>在java中显示配置</p>
</li>
<li>
<p>隐式的自动装配bean 【重要】</p>
</li>
<li>
<p>环境搭建：一个人有两个宠物</p>
</li>
<li>
<p>byType自动装配：byType会自动查找，和自己对象set方法参数的类型相同的bean</p>
<p>保证所有的class唯一(类为全局唯一)</p>
</li>
<li>
<p>byName自动装配：byName会自动查找，和自己对象set对应的值对应的id</p>
<p>保证所有id唯一，并且和set注入的值一致</p>
<pre><code class="language-xml">&lt;!-- 找不到id和多个相同class --&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;pojo.Cat&quot;/&gt;
&lt;!-- 找不到 id=cat，且有两个Cat --&gt;
</code></pre>
</li>
</ol>
<h3 id="71测试自动装配">7.1测试：自动装配</h3>
<p>pojo的Cat类</p>
<pre><code class="language-java">public class Cat {
    public void shut(){
        System.out.println(&quot;miao&quot;);
    }
}
</code></pre>
<p>pojo的Dog类</p>
<pre><code class="language-java">public class Dog {

    public void shut(){
        System.out.println(&quot;wow&quot;);
    }

}
</code></pre>
<p>pojo的People类</p>
<pre><code class="language-java">package pojo;
public class People {
    
    private Cat cat;
    private Dog dog;
    private String name;

    public Cat getCat() {
        return cat;
    }

    public void setCat(Cat cat) {
        this.cat = cat;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return &quot;People{&quot; +
                &quot;cat=&quot; + cat +
                &quot;, dog=&quot; + dog +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p>xml配置 -&gt; byType 自动装配</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;cat&quot; class=&quot;pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;/&gt;
    
    &lt;!--byType会在容器自动查找，和自己对象属性相同的bean
		例如，Dog dog; 那么就会查找pojo的Dog类，再进行自动装配
	--&gt;
    &lt;bean id=&quot;people&quot; class=&quot;pojo.People&quot; autowire=&quot;byType&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;cbh&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>xml配置 -&gt; byName 自动装配</p>
<pre><code class="language-xml">&lt;bean id=&quot;cat&quot; class=&quot;pojo.Cat&quot;/&gt;
&lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;/&gt;
&lt;!--byname会在容器自动查找，和自己对象set方法的set后面的值对应的id
  例如:setDog()，取set后面的字符作为id，则要id = dog 才可以进行自动装配
  
 --&gt;
&lt;bean id=&quot;people&quot; class=&quot;pojo.People&quot; autowire=&quot;byName&quot;&gt;
	&lt;property name=&quot;name&quot; value=&quot;cbh&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>弹幕评论：byName只能取到小写，大写取不到</p>
<h3 id="72-使用注解实现自动装配">7.2、使用注解实现自动装配</h3>
<p>jdk1.5支持的注解，spring2.5支持的注解</p>
<p>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.（翻译：基于注释的配置的引入提出了一个问题，即这种方法是否比XML“更好”）</p>
<ol>
<li>导入context约束</li>
</ol>
<pre><code class="language-xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
</code></pre>
<ol>
<li>配置注解的支持：&lt; context:annotation-config/&gt;</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="721-autowired">7.2.1、@Autowired</h4>
<p><strong>默认是byType方式，如果匹配不上，就会byName</strong></p>
<p>在属性上个使用，也可以在set上使用</p>
<p>我们可以不用编写set方法了，前提是自动装配的属性在Spring容器里，且要符合ByName 自动装配</p>
<pre><code class="language-java">public class People {
    @Autowired
    private Cat cat;
    @Autowired
    private Dog dog;
    private String name;
}
</code></pre>
<blockquote>
<p>@Nullable 字段标记了这个注解，说明该字段可以为空</p>
<p>public name(@Nullable String name){</p>
<p>}</p>
</blockquote>
<pre><code class="language-java">//源码
public @interface Autowired { 
	boolean required() default true; 
}
</code></pre>
<p>如果定义了Autowire的require属性为false，说明这个对象可以为null，否则不允许为空（false表示找不到装配，不抛出异常）</p>
<h4 id="722-autowiredqualifier">7.2.2、@Autowired+@Qualifier</h4>
<p><strong>@Autowired不能唯一装配时，需要@Autowired+@Qualifier</strong></p>
<p>如果@Autowired自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用@Qualifier(value = “dog”)去配合使用，指定一个唯一的id对象</p>
<pre><code class="language-java">public class People {
    @Autowired
    private Cat cat;
    @Autowired
    @Qualifier(value = &quot;dog&quot;)
    private Dog dog;
    private String name;
}
</code></pre>
<p>弹幕评论：</p>
<p>如果xml文件中同一个对象被多个bean使用，Autowired无法按类型找到，可以用@Qualifier指定id查找</p>
<h4 id="723-resource">7.2.3、@Resource</h4>
<p><strong>默认是byName方式，如果匹配不上，就会byType</strong></p>
<pre><code class="language-java">public class People {
    Resource(name=&quot;cat&quot;)
    private Cat cat;
    Resource(name=&quot;dog&quot;)
    private Dog dog;
    private String name;
}
</code></pre>
<p>弹幕评论：</p>
<p>Autowired是byType，@Autowired+@Qualifier = byType || byName</p>
<p>Autowired是先byteType,如果唯一則注入，否则byName查找。resource是先byname,不符合再继续byType</p>
<h4 id="区别">区别：</h4>
<p>@Resource和@Autowired的区别：</p>
<ul>
<li>都是用来自动装配的，都可以放在属性字段上</li>
<li>@Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】</li>
<li>@Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】</li>
<li>执行顺序不同：@Autowired通过byType的方式实现。@Resource默认通过byname的方式实现</li>
</ul>
<h2 id="8-使用注解开发">8、使用注解开发</h2>
<p>在spring4之后，使用注解开发，必须要保证aop包的导入<br>
<img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIyMDE5MjQ0OTAucG5n" alt="image-20200802201924490" loading="lazy"><br>
使用注解需要导入contex的约束</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="81-bean">8.1、bean</h3>
<p>弹幕评论：<br>
有了&lt; context:component-scan&gt;，另一个&lt; context:annotation-config/&gt;标签可以移除掉，因为已经被包含进去了。</p>
<pre><code class="language-xml">&lt;!--指定要扫描的包，这个包下面的注解才会生效
	别只扫一个com.kuang.pojo包--&gt; 
&lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt; 
&lt;context:annotation-config/&gt;
</code></pre>
<pre><code class="language-java">//@Component 组件
//等价于&lt;bean id=&quot;user&quot; classs&quot;pojo.User&quot;/&gt; 
@Component
public class User {  
     public String name =&quot;秦疆&quot;;
}
</code></pre>
<h3 id="82-属性如何注入value">8.2、属性如何注入@value</h3>
<pre><code class="language-java">@Component
public class User { 
    //相当于&lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt; 
    @value(&quot;kuangshen&quot;) 
    public String name; 
    
    //也可以放在set方法上面
    //@value(&quot;kuangshen&quot;)
    public void setName(String name) { 
        this.name = name; 
    }
}
</code></pre>
<h3 id="83-衍生的注解">8.3、衍生的注解</h3>
<p>@Component有几个衍生注解，会按照web开发中，mvc架构中分层。</p>
<ul>
<li>dao （@Repository）</li>
<li>service（@Service）</li>
<li>controller（@Controller）</li>
</ul>
<p><strong>这四个注解的功能是一样的，都是代表将某个类注册到容器中</strong></p>
<h3 id="84-自动装配置">8.4、自动装配置</h3>
<p>@Autowired：默认是byType方式，如果匹配不上，就会byName</p>
<p>@Nullable：字段标记了这个注解，说明该字段可以为空</p>
<p>@Resource：默认是byName方式，如果匹配不上，就会byType</p>
<h3 id="85-作用域scope">8.5、作用域@scope</h3>
<pre><code class="language-java">//原型模式prototype，单例模式singleton
//scope(&quot;prototype&quot;)相当于&lt;bean scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
@Component 
@scope(&quot;prototype&quot;)
public class User { 
    
    //相当于&lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt; 
    @value(&quot;kuangshen&quot;) 
    public String name; 
    
    //也可以放在set方法上面
    @value(&quot;kuangshen&quot;)
    public void setName(String name) { 
        this.name = name; 
    }
}
</code></pre>
<h3 id="86-小结">8.6、小结</h3>
<p><strong>xml与注解：</strong></p>
<ul>
<li>xml更加万能，维护简单，适用于任何场合</li>
<li>注解，不是自己的类使用不了，维护复杂</li>
</ul>
<p><strong>最佳实践：</strong></p>
<ul>
<li>xml用来管理bean</li>
<li>注解只用来完成属性的注入</li>
<li>要开启注解支持</li>
</ul>
<h2 id="9-使用java的方式配置spring">9、使用Java的方式配置Spring</h2>
<p>不使用Spring的xml配置，完全交给java来做！</p>
<p>Spring的一个子项目，在spring4之后，，，它成为了核心功能</p>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIyMTU3NTI4NjgucG5n" alt="image-20200802215752868" loading="lazy"><br>
<strong>实体类：pojo的User.java</strong></p>
<pre><code class="language-java">//这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中 
@component 
public class User { 
    private String name;
    
    public String getName() { 
    	return name; 
    } 
    //属性注入值
    @value(&quot;QINJIANG')  
    public void setName(String name) { 
    	this.name = name; 
    } 
    @Override 
    public String toString() { 
        return &quot;user{&quot; + 
        &quot;name='&quot; + name + '\''+ 
        '}'; 
    } 
}
</code></pre>
<p>弹幕评论：要么使用@Bean，要么使用@Component和ComponentScan，两种效果一样</p>
<p><strong>配置文件：config中的kuang.java</strong></p>
<p>@Import(KuangConfig2.class)，用@import来包含KuangConfig2.java</p>
<pre><code class="language-java">//这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component 
// @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于&lt;beans&gt;标签
@Configuration 
@componentScan(&quot;com.Kuang.pojo&quot;) //开启扫描
//@Import(KuangConfig2.class)
public class KuangConfig { 
    //注册一个bean , 就相当于我们之前写的一个bean 标签 
    //这个方法的名字,就相当于bean 标签中的 id 属性 -&gt;getUser
    //这个方法的返同值,就相当于bean 标签中的class 属性 -&gt;User
    
    //@Bean 
    public User getUser(){ 
    	return new User(); //就是返回要注入到bean的对象! 
    } 
}
</code></pre>
<p>弹幕评论：ComponentScan、@Component(&quot;pojo”) 这两个注解配合使用</p>
<p><strong>测试类</strong></p>
<pre><code class="language-java">public class MyTest { 
    public static void main(String[ ] args) { 
    //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! 
    ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象
    User getUser =(User)context.getBean( &quot;getUser&quot;); //方法名getUser
    System.out.Println(getUser.getName()); 
    } 
}
</code></pre>
<p><strong>会创建两个相同对象问题的说明：</strong></p>
<p><strong>弹幕总结 - -&gt; @Bean是相当于&lt; bean&gt;标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了</strong></p>
<pre><code class="language-java">//这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component 
// @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于&lt;beans&gt;标签
@Configuration 
@componentScan(&quot;com.Kuang.pojo&quot;) //开启扫描
//@Import(KuangConfig2.class)
public class KuangConfig { 
    //注册一个bean , 就相当于我们之前写的一个bean 标签 
    //这个方法的名字,就相当于bean 标签中的 id 属性 -&gt;getUser
    //这个方法的返同值,就相当于bean 标签中的class 属性 -&gt;User
    
    //@Bean 
    public User getUser(){ 
    	return new User(); //就是返回要注入到bean的对象! 
    } 
}
</code></pre>
<p>弹幕评论：ComponentScan、@Component(&quot;pojo”) 这两个注解配合使用</p>
<p><strong>测试类</strong></p>
<pre><code class="language-java">public class MyTest { 
    public static void main(String[ ] args) { 
    //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! 
    ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象
    User getUser =(User)context.getBean( &quot;getUser&quot;); //方法名getUser
    System.out.Println(getUser.getName()); 
    } 
}
</code></pre>
<p><strong>会创建两个相同对象问题的说明：</strong></p>
<p><strong>弹幕总结 - -&gt; @Bean是相当于&lt; bean&gt;标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了</strong></p>
<h2 id="10-动态代理">10、动态代理</h2>
<p>代理模式是SpringAOP的底层</p>
<p>分类：动态代理和静态代理</p>
<figure data-type="image" tabindex="8"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMDE0Mjc4NDYucG5n" alt="image-20200803101427846" loading="lazy"></figure>
<h3 id="101-静态代理">10.1、静态代理</h3>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMDE2MjE4NjgucG5n" alt="image-20200803101621868" loading="lazy"><br>
代码步骤：</p>
<p>1、接口</p>
<pre><code class="language-java">package pojo;
public interface Host {
	public void rent();
}
</code></pre>
<p>2、真实角色</p>
<pre><code class="language-java">package pojo;
public class HostMaster implements Host{	
    
	public void rent() {
		System.out.println(&quot;房东要出租房子&quot;);
	}
}
</code></pre>
<p>3、代理角色</p>
<pre><code class="language-java">package pojo;
public class Proxy {

	public Host host;
	
	public Proxy() {
		
	}
	
	public Proxy(Host host) {
		super();
		this.host = host;
	}
	
	public void rent() {
		seeHouse();
		host.rent();
		fee();
		sign();
	}
	//看房
	public void seeHouse() {
		System.out.println(&quot;看房子&quot;);
	}
	//收费
	public void fee() {
		System.out.println(&quot;收中介费&quot;);
	}
	//合同
	public void sign() {
		System.out.println(&quot;签合同&quot;);
	}		
}
</code></pre>
<p>4、客户端访问代理角色</p>
<pre><code class="language-java">package holle4_proxy;

import pojo.Host;
import pojo.HostMaster;
import pojo.Proxy;

public class My {

	public static void main(String[] args) {
		//房东要出租房子
		Host host = new HostMaster();
		//中介帮房东出租房子，但也收取一定费用（增加一些房东不做的操作）
		Proxy proxy = new Proxy(host);
		//看不到房东，但通过代理，还是租到了房子
		proxy.rent();
		
	}
}
</code></pre>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMDUyMjk0NzgucG5n" alt="image-20200803105229478" loading="lazy"><br>
代码翻倍：几十个真实角色就得写几十个代理</p>
<p>AOP横向开发</p>
<figure data-type="image" tabindex="9"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMTE1Mzk2MjEucG5n" alt="image-20200803111539621" loading="lazy"></figure>
<h3 id="102-动态代理">10.2、动态代理</h3>
<p>动态代理和静态角色一样，动态代理底层是反射机制</p>
<p>动态代理类是动态生成的，不是我们直接写好的！</p>
<p>动态代理(两大类)：基于接口，基于类</p>
<ul>
<li>基于接口：JDK的动态代理【使用ing】</li>
<li>基于类：cglib</li>
<li>java字节码实现：javasisit</li>
</ul>
<p>了解两个类<br>
1、Proxy：代理<br>
2、InvocationHandler：调用处理程序<br>
<img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMTI2MTk4NjgucG5n" alt="image-20200803112619868" loading="lazy"></p>
<p>实例：</p>
<p>接口 Host.java</p>
<pre><code class="language-java">//接口
package pojo2;
public interface Host {
	public void rent();
	
}
</code></pre>
<p>接口Host实现类 HostMaster.java</p>
<pre><code class="language-java">//接口实现类
package pojo2;
public class HostMaster implements Host{	
	public void rent() {
		System.out.println(&quot;房东要租房子&quot;);
	}
}
</code></pre>
<p>代理角色的处理程序类 ProxyInvocationHandler.java</p>
<pre><code class="language-java">package pojo2;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

///用这个类，自动生成代理
public class ProxyInvocationHandler implements InvocationHandler {

	// Foo f =(Foo) Proxy.NewProxyInstance(Foo. Class.GetClassLoader(),
	// new Class&lt;?&gt;[] { Foo.Class },
	// handler);

	// 被代理的接口
	public HostMaster hostMaster ;
	
	public void setHostMaster(HostMaster hostMaster) {
		this.hostMaster = hostMaster;
	}

	// 得到生成的代理类 
	public Object getProxy() {
		// newProxyInstance() -&gt; 生成代理对象，就不用再写具体的代理类了
		// this.getClass().getClassLoader() -&gt; 找到加载类的位置
		// hostMaster.getClass().getInterfaces() -&gt; 代理的具体接口
		// this -&gt; 代表了接口InvocationHandler的实现类ProxyInvocationHandler
		return Proxy.newProxyInstance(this.getClass().getClassLoader(), hostMaster.getClass().getInterfaces(), this);


	// 处理代理实例并返回结果
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		seeHouse();
		// 动态代理的本质，就是使用反射机制实现的
        // invoke()执行它真正要执行的方法
		Object result = method.invoke(hostMaster, args);
		fee();
		return result;
	}

	public void seeHouse() {
		System.out.println(&quot;看房子&quot;);
	}

	public void fee() {
		System.out.println(&quot;收中介费&quot;);
	}

}

</code></pre>
<p>用户类 My2.java</p>
<pre><code class="language-java">package holle4_proxy;

import pojo2.Host;
import pojo2.Host2;
import pojo2.HostMaster;
import pojo2.ProxyInvocationHandler;

public class My2 {

	public static void main(String[] args) {
        
		//真实角色
		HostMaster hostMaster = new HostMaster();
        
		//代理角色，现在没有；用代理角色的处理程序来实现Host接口的调用
		ProxyInvocationHandler pih = new ProxyInvocationHandler();
        
        //pih -&gt; HostMaster接口类 -&gt; Host接口
		pih.setHostMaster(hostMaster);
        
		//获取newProxyInstance动态生成代理类
		Host proxy = (Host) pih.getProxy();
		
		proxy.rent();

	}
}
</code></pre>
<p>弹幕评论：<br>
什么时候调用invoke方法的?<br>
代理实例调用方法时invoke方法就会被调用，可以debug试试</p>
<p>改为<strong>万能代理类</strong></p>
<pre><code class="language-java">///用这个类，自动生代理
public class ProxyInvocationHandler implements InvocationHandler {

	// 被代理的接口
	public Object target;

	public void setTarget(Object target) {
		this.target = target;
	}

	// 得到生成的代理类 -&gt; 固定的代码
	public Object getProxy() {
		return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
	}

	// 处理代理实例并返回结果
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		// 动态代理的本质，就是使用反射机制实现的
		// invoke()执行它真正要执行的方法
		Object result = method.invoke(target, args);
		return result;
	}

}
</code></pre>
<figure data-type="image" tabindex="10"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMzMwMzU0ODQlMjAtJTIwJUU1JThBJUE4JUU2JTgwJTgxJUU0JUJCJUEzJUU3JTkwJTg2LnBuZw" alt="image-20200803133035484" loading="lazy"></figure>
<h2 id="11-aop">11、AOP</h2>
<h3 id="111-什么是aop">11.1、什么是AOP</h3>
<figure data-type="image" tabindex="11"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMzQ1MDIxNjklMjAtJTIwQU9QLnBuZw" alt="image-20200803134502169" loading="lazy"></figure>
<h3 id="112-aop在spring中的使用">11.2、AOP在Spring中的使用</h3>
<p>提供声明式事务，允许用户自定义切面</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等…</li>
<li>切面(Aspect)：横切关注点 被模块化的特殊对象。即，它是一个类。（Log类）</li>
<li>通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。（Log类中的方法）</li>
<li>目标(Target)：被通知对象。（生成的代理类)</li>
<li>代理(Proxy)：向目标对象应用通知之后创建的对象。（生成的代理类）</li>
<li>切入点(PointCut)：切面通知执行的”地点”的定义。（最后两点：在哪个地方执行，比如：method.invoke()）</li>
<li>连接点(JointPoint)：与切入点匹配的执行点。</li>
</ul>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxNTQwNDM5MDkucG5n" alt="image-20200803154043909" loading="lazy"><br>
SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMzU5Mzc0MzUucG5n" alt="image-20200803135937435" loading="lazy"><br>
<strong>即AOP在不改变原有代码的情况下，去增加新的功能。</strong>（代理）</p>
<h3 id="113-使用spring实现aop">11.3、使用Spring实现AOP</h3>
<p>导入jar包</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="1131-方法一使用原生spring接口">11.3.1、方法一：使用原生spring接口</h4>
<p>springAPI接口实现</p>
<p>applicationContext.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!--注册bean--&gt;
    &lt;bean id=&quot;userservice&quot; class=&quot;service.UserServiceImpl&quot;/&gt;
    &lt;bean id=&quot;log&quot; class=&quot;log.Log&quot;/&gt;
    &lt;bean id=&quot;afterLog&quot; class=&quot;log.AfterLog&quot;/&gt;
	&lt;!--方式一，使用原生Spring API接口--&gt;
    &lt;!--配置aop,还需要导入aop约束--&gt;
    &lt;aop:config&gt;
        &lt;!--切入点：expression:表达式，execution（要执行的位置）--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt;
        &lt;!--UserServiceImpl.*(..) -》 UserServiceImpl类下的所以方法(参数)--&gt;
        &lt;!--执行环绕增加--&gt;
        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;!-- 环绕,在id=&quot;pointcut&quot;的前后切入 --&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>execution(返回类型，类名，方法名(参数)) -&gt; execution(* com.service.<em>,</em>(…))</p>
<p>UserService.java</p>
<pre><code class="language-java">package service;
public interface UserService {   
	    public void add() ;
	    public void delete() ;
	    public void query() ;
	    public void update();
}
</code></pre>
<p>UserService 的实现类 UserServiceImp.java</p>
<pre><code class="language-java">package service;

public class UserServiceImpl implements UserService {

    public void add() {
        System.out.println(&quot;add增&quot;);
    }
    public void delete() {
        System.out.println(&quot;delete删&quot;);
    }
    public void update() {
        System.out.println(&quot;update改&quot;);
    }
    public void query() {
        System.out.println(&quot;query查&quot;);
    }
}
</code></pre>
<p>前置Log.java</p>
<pre><code class="language-java">package log;
import org.springframework.aop.MethodBeforeAdvice;
import java.lang.reflect.Method;

public class Log implements MethodBeforeAdvice {
    //method：要执行的目标对象的方法
    //args：参数
    //target：目标对象
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;);
    }
}
</code></pre>
<p>后置AfterLog.java</p>
<pre><code class="language-java">package log;
import java.lang.reflect.Method;
import org.springframework.aop.AfterReturningAdvice;

public class AfterLog implements AfterReturningAdvice {
    //returnVaule: 返回值
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
    	System.out.println(&quot;执行了&quot;+method.getName()+&quot;方法，返回值是&quot;+returnValue);
    }
}
</code></pre>
<p>测试类MyTest5</p>
<pre><code class="language-java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import service.UserService;

public class MyTest5 {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //注意:动态代理代理的是接口
        UserService userService = (UserService) context.getBean(&quot;userservice&quot;);
        userService.add();
    }
}
</code></pre>
<h4 id="1132-方法二自定义类实现aop">11.3.2、方法二：自定义类实现AOP</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
   	https://www.springframework.org/schema/beans/spring-beans.xsd
   	http://www.springframework.org/schema/aop
   	https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

   &lt;!--注册bean--&gt;
   &lt;bean id=&quot;userservice&quot; class=&quot;service.UserServiceImpl&quot;/&gt;
   &lt;bean id=&quot;log&quot; class=&quot;log.Log&quot;/&gt;
   &lt;bean id=&quot;afterLog&quot; class=&quot;log.AfterLog&quot;/&gt;
   &lt;!-- 方式二，自定义 --&gt;
   &lt;bean id=&quot;diy&quot; class=&quot;diy.DiyPointcut&quot;/&gt;
   &lt;aop:config&gt;
       &lt;!--自定义切面--&gt;
       &lt;aop:aspect ref=&quot;diy&quot;&gt;
           &lt;!--切入点--&gt;
           &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt;
           &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;
           &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;
       &lt;/aop:aspect&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">package diy;
public class DiyPointcut {

    public void before(){
        System.out.println(&quot;插入到前面&quot;);
    }

    public void after(){
        System.out.println(&quot;插入到后面&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//测试
public class MyTest5 {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //注意:动态代理代理的是接口
        UserService userService = (UserService) context.getBean(&quot;userservice&quot;);
        userService.add();
    }
}
</code></pre>
<h4 id="1133-方法三使用注解实现">11.3.3、方法三：使用注解实现</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
	
    &lt;!-- 注册 --&gt;
    &lt;bean id=&quot;userservice&quot; class=&quot;service.UserServiceImpl&quot;/&gt;
    &lt;!--方式三，使用注解实现--&gt;
    &lt;bean id=&quot;diyAnnotation&quot; class=&quot;diy.DiyAnnotation&quot;&gt;&lt;/bean&gt;
    
    &lt;!-- 开启自动代理 
		实现方式：默认JDK (proxy-targer-class=&quot;fasle&quot;)
    			 cgbin (proxy-targer-class=&quot;true&quot;)--&gt;
	&lt;aop:aspectj-autoproxy/&gt;
    
&lt;/beans&gt;
</code></pre>
<p>DiyAnnotation.java</p>
<pre><code class="language-java">package diy;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect  //标注这个类是一个切面
public class DiyAnnotation {
	
    @Before(&quot;execution(* service.UserServiceImpl.*(..))&quot;)
    public void before(){
        System.out.println(&quot;=====方法执行前=====&quot;);
    }

    @After(&quot;execution(* service.UserServiceImpl.*(..))&quot;)
    public void after(){
        System.out.println(&quot;=====方法执行后=====&quot;);
    }

    //在环绕增强中，我们可以给地暖管一个参数，代表我们要获取切入的点
    @Around(&quot;execution(* service.UserServiceImpl.*(..))&quot;)
    public void around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;环绕前&quot;);

        Object proceed = joinPoint.proceed();

        System.out.println(&quot;环绕后&quot;);
    }
}
</code></pre>
<p>测试</p>
<pre><code class="language-java">public class MyTest5 {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //注意:动态代理代理的是接口
        UserService userService = (UserService) context.getBean(&quot;userservice&quot;);
        userService.add();
    }
}
</code></pre>
<p>输出结果：</p>
<figure data-type="image" tabindex="12"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxNzU2NDIwNjQucG5n" alt="image-20200803175642064" loading="lazy"></figure>
<h2 id="12-整合mybatis">12、整合mybatis</h2>
<p>mybatis-spring官网：https://mybatis.org/spring/zh/</p>
<p><strong>mybatis的配置流程：</strong></p>
<ol>
<li>编写实体类</li>
<li>编写核心配置文件</li>
<li>编写接口</li>
<li>编写Mapper.xmi</li>
<li>测试</li>
</ol>
<h3 id="121-mybatis-spring-方式一">12.1、mybatis-spring-方式一</h3>
<ol>
<li>编写数据源配置</li>
<li>sqISessionFactory</li>
<li>sqISessionTemplate（相当于sqISession）</li>
<li>需要给接口加实现类【new】</li>
<li>将自己写的实现类，注入到Spring中</li>
<li>测试！</li>
</ol>
<p>先导入jar包</p>
<pre><code class="language-xml">&lt;dependencies&gt;

    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.9.4&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.2&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.4&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.12&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.12&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
	
&lt;!--在build中配置resources，来防止资源导出失败的问题--&gt;
&lt;!-- Maven解决静态资源过滤问题 --&gt;
&lt;build&gt;
&lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.properties&lt;/include&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.properties&lt;/include&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
    &lt;/resource&gt;
&lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDQxMjMyMTA1NjAucG5n" alt="文件路径" loading="lazy"><br>
<strong>编写顺序：</strong><br>
<strong>User -&gt; UserMapper -&gt; UserMapper.xml -&gt; spring-dao.xml -&gt; UserServiceImpl -&gt; applicationContext.xml -&gt; MyTest6</strong></p>
<p><strong>代码步骤：</strong></p>
<p>pojo实体类 User</p>
<pre><code class="language-java">package pojo;
import lombok.Data;
@Data
public class User {
	private int id;
	private String name;
	private String pwd;
}
</code></pre>
<p>mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml</p>
<p>接口UserMapper</p>
<pre><code class="language-java">package mapper;
import java.util.List;
import pojo.User;
public interface UserMapper {
	public List&lt;User&gt; getUser();
}
</code></pre>
<p>UserMapperImpl</p>
<pre><code class="language-java">package mapper;
import java.util.List;
import org.mybatis.spring.SqlSessionTemplate;
import pojo.User;

public class UserMapperImpl implements UserMapper{
	
	//我们的所有操作，在原来都使用sqlSession来执行，现在都使用SqlSessionTemplate；
	private SqlSessionTemplate sqlSessionTemplate;

	public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {
		this.sqlSessionTemplate = sqlSessionTemplate;
	}

	public List&lt;User&gt; getUser() {
		UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class);
		return mapper.getUser();
	}
}
</code></pre>
<p>UserMapper.xml （狂神给面子才留下来的）</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        
&lt;!-- 绑定接口 --&gt;
&lt;mapper namespace=&quot;mapper.UserMapper&quot;&gt;
	&lt;select id=&quot;getUser&quot; resultType=&quot;pojo.User&quot;&gt;
		select * from mybatis.mybatis
	&lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml</p>
<p>mybatis-config.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
	&lt;!--开启日志--&gt;
	&lt;settings&gt;
		&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;
	&lt;/settings&gt;
	
	&lt;!--可以给实体类起别名 --&gt;
	&lt;typeAliases&gt; 
		&lt;package name=&quot;pojo&quot; /&gt;
	&lt;/typeAliases&gt;

&lt;/configuration&gt;
</code></pre>
<p>spring-dao.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
		
	&lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 
		这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt;
	&lt;!--data source --&gt;
	&lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
		&lt;property name=&quot;driverClassName&quot;
			value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;
		&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
		&lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
		&lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
	&lt;/bean&gt;
	
	&lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt;
        &lt;!--绑定 mybatis 配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;
    &lt;/bean&gt;

	&lt;!-- sqlSessionTemplate 就是之前使用的：sqlsession --&gt;
    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
    	&lt;!-- 只能使用构造器注入sqlSessionFactory 原因：它没有set方法--&gt;	
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
    &lt;/bean&gt;
		
&lt;/beans&gt;
</code></pre>
<p>applicationContext.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    
	&lt;!-- 导入spring-dao.xml --&gt;
	&lt;import resource=&quot;spring-dao.xml&quot;/&gt;
	
    &lt;bean id=&quot;userMapper&quot; class=&quot;mapper.UserMapperImpl&quot;&gt;
        &lt;property name=&quot;sqlSessionTemplate&quot; ref=&quot;sqlSession&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试类</p>
<pre><code class="language-java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import mapper.UserMapper;
import pojo.User;
public class MyTest6 {
	public static void main(String[] args) {
        
		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
		
		UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;);
		
		for (User user : userMapper.getUser()) {
			System.out.println(user);
		}
	}
}
</code></pre>
<h3 id="122-mybatis-spring-方式二">12.2、mybatis-spring-方式二</h3>
<p>UserServiceImpl2</p>
<pre><code class="language-java">package mapper;
import pojo.User;
import org.apache.ibatis.session.SqlSession;
import org.mybatis.spring.support.SqlSessionDaoSupport;
import java.util.List;
//继承SqlSessionDaoSupport 类
public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper {
    public List&lt;User&gt; getUser() {
        SqlSession sqlSession = getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.getUser();
        //或者一句话：return getSqlSession().getMapper(UserMapper.class).getUser();
    }
}
</code></pre>
<p>spring-dao.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
		
	&lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 c3p0 dbcp druid 
		这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt;
	&lt;!--data source --&gt;
	&lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
		&lt;property name=&quot;driverClassName&quot;
			value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;
		&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
		&lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
		&lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
	&lt;/bean&gt;
	
	&lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt;
        &lt;!--绑定 mybatis 配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;
    &lt;/bean&gt;
    
	&lt;!-- 方法二：SqlSessionTemplate 可以不写了--&gt;
    
&lt;/beans&gt;
</code></pre>
<p>applicationContext.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

	&lt;import resource=&quot;spring-dao.xml&quot; /&gt;

	&lt;!-- 方法二 --&gt;
	&lt;bean id=&quot;userMapper2&quot; class=&quot;mapper.UserMapperImpl2&quot;&gt;
		&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="language-java">public class MyTest6 {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
		UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper2&quot;);
		for (User user : userMapper.getUser()) {
			System.out.println(user);
		}
	}
}
</code></pre>
<h2 id="13-声明式事务">13. 声明式事务</h2>
<ul>
<li>把一组业务当成一个业务来做；要么都成功，要么都失败！</li>
<li>事务在项目开发中，十分的重要，涉及到数据的一致性问题</li>
<li>确保完整性和一致性</li>
</ul>
<p>事务的ACID原则：<br>
1、原子性<br>
2、隔离性<br>
3、一致性<br>
4、持久性</p>
<p>ACID参考文章：https://www.cnblogs.com/malaikuangren/archive/2012/04/06/2434760.html</p>
<p>Spring中的事务管理</p>
<ul>
<li>声明式事务：AOP</li>
<li>编程式事务：需要再代码中，进行事务管理</li>
</ul>
<p><strong>声明式事务</strong></p>
<p>先导入jar包</p>
<pre><code class="language-xml">&lt;dependencies&gt;

    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.9.4&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.2&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.4&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.12&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.12&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
	
&lt;!--在build中配置resources，来防止资源导出失败的问题--&gt;
&lt;!-- Maven解决静态资源过滤问题 --&gt;
&lt;build&gt;
&lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.properties&lt;/include&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.properties&lt;/include&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
    &lt;/resource&gt;
&lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<p><strong>代码步骤：</strong></p>
<p>pojo实体类 User</p>
<pre><code class="language-java">package pojo;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
	private int id;
	private String name;
	private String pwd;
}
</code></pre>
<p>mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml</p>
<p>接口UserMapper</p>
<pre><code class="language-java">package mapper;
import java.util.List;
import org.apache.ibatis.annotations.Param;
import pojo.User;

public interface UserMapper {
	public List&lt;User&gt; getUser();
	
	public int insertUser(User user); 
	
	public int delUser(@Param(&quot;id&quot;) int id); 
}
</code></pre>
<p>UserMapperImpl</p>
<pre><code class="language-java">package mapper;

import pojo.User;
import org.apache.ibatis.session.SqlSession;
import org.mybatis.spring.support.SqlSessionDaoSupport;
import java.util.List;

public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper {
    public List&lt;User&gt; getUser() {
    	User user = new User(5,&quot;你好&quot;,&quot;ok&quot;);
    	insertUser(user);
    	delUser(5);
        SqlSession sqlSession = getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.getUser();
        //或者return  getSqlSession().getMapper(UserMapper.class).getUser();
    }
    //插入
	public int insertUser(User user) {
		return getSqlSession().getMapper(UserMapper.class).insertUser(user);
	}
	//删除
	public int delUser(int id) {
		return getSqlSession().getMapper(UserMapper.class).delUser(id);
	}
}
</code></pre>
<p>UserMapper.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        
&lt;!-- 绑定接口 --&gt;
&lt;mapper namespace=&quot;mapper.UserMapper&quot;&gt;
	&lt;select id=&quot;getUser&quot; resultType=&quot;pojo.User&quot;&gt;
		select * from mybatis.mybatis
	&lt;/select&gt;
	
	&lt;insert id=&quot;insertUser&quot;  parameterType=&quot;pojo.User&quot; &gt;
		insert into  mybatis.mybatis (id,name,pwd) values (#{id},#{name},#{pwd})
	&lt;/insert&gt;
	
	&lt;delete id=&quot;delUser&quot; parameterType=&quot;_int&quot;&gt;
		deleteAAAAA from mybatis.mybatis where id = #{id}
		&lt;!-- deleteAAAAA是故意写错的 --&gt;
	&lt;/delete&gt;

&lt;/mapper&gt;
</code></pre>
<p>resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml</p>
<p>mybatis-config.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;!-- configuration --&gt;
&lt;configuration&gt;
	
	&lt;!--开启日志--&gt;
	&lt;settings&gt;
		&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;
	&lt;/settings&gt;
	
	&lt;!--可以给实体类起别名--&gt;
	&lt;typeAliases&gt; 
		&lt;package name=&quot;pojo&quot; /&gt;
	&lt;/typeAliases&gt;

&lt;/configuration&gt;
</code></pre>
<p>spring-dao.xml（已导入约束）</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
		
	&lt;!--data source --&gt;
	&lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
		&lt;property name=&quot;driverClassName&quot;
			value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;
		&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
		&lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
		&lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
	&lt;/bean&gt;
	
	&lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt;
        &lt;!--绑定 mybatis 配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;
    &lt;/bean&gt;
	
	&lt;!--声明式事务--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;constructor-arg ref=&quot;datasource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--结合aop实现事务织入--&gt;
    &lt;!--配置事务的通知类--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;!--给哪些方法配置事务--&gt;
        &lt;!--新东西：配置事务的传播特性 propagation--&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;query&quot; read-only=&quot;true&quot;/&gt;
            &lt;!-- *号包含上面4个方法：
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; --&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--配置事务切入--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txpointcut&quot; expression=&quot;execution(* mapper.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txpointcut&quot;/&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>applicationContext.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

	&lt;import resource=&quot;spring-dao.xml&quot; /&gt;

	&lt;bean id=&quot;userMapper&quot; class=&quot;mapper.UserMapperImpl&quot;&gt;
		&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试类</p>
<pre><code class="language-java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import mapper.UserMapper;import pojo.User;
public class MyTest7 {
	public static void main(String[] args) {

		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
		
		UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;);
		
		for (User user : userMapper.getUser()) {
			System.out.println(user);
		}
	}
}
</code></pre>
<p><strong>思考：</strong><br>
为什么需要事务？</p>
<ul>
<li>如果不配置事务，可能存在数据提交不一致的情况下；</li>
<li>如果不在spring中去配置声明式事务，我们就需要在代码中手动配置事务！</li>
<li>事务在项目的开发中非常重要，涉及到数据的一致性和完整性问题！</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://aruul.github.io/tag/ERT8qSV6q/" class="tag">
                    spring
                  </a>
                
                  <a href="https://aruul.github.io/tag/fABi2KP6qR/" class="tag">
                    java
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://aruul.github.io/post/iJ3Ze3gYo/">
                  <h3 class="post-title">
                    Lombook
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
