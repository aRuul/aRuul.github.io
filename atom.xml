<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aruul.github.io</id>
    <title>aRuul的无名小站</title>
    <updated>2021-07-04T07:52:18.715Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aruul.github.io"/>
    <link rel="self" href="https://aruul.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aruul.github.io/images/avatar.png</logo>
    <icon>https://aruul.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, aRuul的无名小站</rights>
    <entry>
        <title type="html"><![CDATA[代理模式]]></title>
        <id>https://aruul.github.io/post/YYF012ILo/</id>
        <link href="https://aruul.github.io/post/YYF012ILo/">
        </link>
        <updated>2021-07-04T07:51:46.000Z</updated>
        <content type="html"><![CDATA[<p>代理模式简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>代理模式有静态代理和动态代理两种实现方式。</p>
<h2 id="静态代理">静态代理</h2>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>例如：小明想要打官司，则他需要找到代理律师来帮他</p>
<p>​			代理律师负责将小明想说的话说出去，并在小明说话前面引用法律条文，在小明说话后发动道德谴责。</p>
<p>代码：</p>
<pre><code class="language-java">//说话的行为接口
interface Say{
    void sayMessage(String m);
}
//小明
class XiaoMing implements Say{
    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;小明说出案情--by&quot;+m);
    }
}

//静态代理 王律师
class LawyerWang implements Say{
    private final Say say;

    public LawyerWang(Say say) {
        this.say = say;
    }

    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;引用法律条文&quot;);
        say.sayMessage(m);
        System.out.println(&quot;使用道德谴责&quot;);
    }
}
</code></pre>
<p>但是当又有一人来找王律师的时候，就需要重写代理的代码，非常不实用。</p>
<hr>
<h2 id="动态代理">动态代理</h2>
<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<h3 id="jdk动态代理">JDK动态代理</h3>
<h3 id="介绍">介绍</h3>
<p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<ol>
<li><strong>InvocationHandler接口</strong></li>
</ol>
<blockquote>
<p>在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</p>
<pre><code>/**
 * 调用处理程序
 */
public interface InvocationHandler { 
    Object invoke(Object proxy, Method method, Object[] args); 
} 
复制代码
</code></pre>
<p>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。</p>
<p>当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中。</p>
<p>代理类对象作为proxy参数传入，</p>
<p>参数method标识了我们具体调用的是代理类的哪个方法，</p>
<p>args为这个方法的参数。</p>
<p>这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。<br>
作者：Chaexsy<br>
链接：https://juejin.cn/post/6844903591501627405<br>
来源：掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<ol start="2">
<li><strong><code>Proxy</code> 类</strong></li>
</ol>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<pre><code class="language-java">    public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        ......
    }Copy to clipboardErrorCopied
</code></pre>
<p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<hr>
<h3 id="接口和被代理委托方">接口和被代理(委托方)</h3>
<pre><code class="language-java">//说话的行为接口
interface Say{
    void sayMessage(String m);
}
//小明
class XiaoMing implements Say{
    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;小明说出案情--by&quot;+m);
    }
}
</code></pre>
<h3 id="中介类">中介类</h3>
<p>对于<strong>XiaoMing</strong>这个类来说<strong>LawyerProxy</strong>类是他的代理，构成了静态代理</p>
<pre><code class="language-java">class LawyerProxy implements InvocationHandler{
    final private Object object;

    public LawyerProxy(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;引用法律条文&quot;);
        method.invoke(object,args);
        System.out.println(&quot;使用道德谴责&quot;);
        return null;
    }
}
</code></pre>
<h3 id="实际调用">实际调用</h3>
<p>而对于<strong>LawyerProxy</strong>类来说，<strong>Proxy 类</strong>是它的代理，构成了静态代理</p>
<pre><code class="language-java">	//动态代理
  System.out.println(&quot;===动态代理===&quot;);
  LawyerProxy lawyerProxy = new LawyerProxy(new XiaoMing());
  Say s = (Say)Proxy.newProxyInstance(Say.class.getClassLoader(), new Class[]{Say.class}, lawyerProxy);
  s.sayMessage(&quot;动态代理类&quot;);
</code></pre>
<p>也就是说，<strong>动态代理关系由两组静态代理关系组成，这就是动态代理的原理</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反射（3）]]></title>
        <id>https://aruul.github.io/post/9RSSdqr6G/</id>
        <link href="https://aruul.github.io/post/9RSSdqr6G/">
        </link>
        <updated>2021-07-01T07:33:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="反射-得到对象的六种方式">反射-得到对象的六种方式</h3>
<pre><code class="language-java">  
        /*  1.Clss.forName
            已经知道一个类的全类名，
            应用场景：多用于配置文件，读取类全路径，加载类
        */
        final String classAllPath = &quot;org.example.Car&quot;;
        Class&lt;?&gt; cls1 = Class.forName(classAllPath);
        System.out.println(&quot;cls1 &quot;+cls1);

        /*  2.类名.class
            已经知道一个具体的类，
            应用场景：多用于参数传递，如通过反射得到对应的构造器对象
        */
        Class cls2 = Car.class;
        System.out.println(&quot;cls2 &quot;+cls2);

        /*  3.getClass()
            已经知道一个类的实例，调用该实例的getClass()方法获取Class对象，
            应用场景：通过创建好的对象，获取Class对象
        */
        Car car = new Car();
        Class cls3 = car.getClass();
        System.out.println(&quot;cls3 &quot;+cls3);

        /*  4.ClassLoader
            通过类加载器
            应用场景：
        */
        //(1)得到car类的加载器 
        ClassLoader classLoader = car.getClass().getClassLoader();
        //(2)通过类加载器，得到Class对象
        Class&lt;?&gt; cls4 = classLoader.loadClass(&quot;org.example.Car&quot;);
        System.out.println(&quot;cls4 &quot;+cls4);


        //cls1 cls2 cls3 cls4其实是同一个对象
        System.out.println(cls1.hashCode());
        System.out.println(cls2.hashCode());
        System.out.println(cls3.hashCode());
        System.out.println(cls4.hashCode());

        //5.基本数据类型获取Class对象
        Class&lt;?&gt; integerClass = int.class;
        System.out.println(integerClass);

        //6.基本数据类型对应的包装类，通过Type获取Class对象
        Class&lt;?&gt; type = Integer.TYPE;
        System.out.println(type);
</code></pre>
<hr>
<h3 id="反射-获取类相关的信息">反射-获取类相关的信息</h3>
<pre><code class="language-java">		Class&lt;?&gt; personClass = Class.forName(&quot;org.example.Person&quot;); //父类
        Class&lt;?&gt; studentClass = Class.forName(&quot;org.example.Student&quot;); //子类

        //获取全类名
        System.out.println(&quot;获取全类名&quot;+personClass.getName());

        //获取简单类名
        System.out.println(&quot;获取简单类名&quot;+personClass.getSimpleName());

        //获取所有public修饰的属性， 包括本类及父类
        Field[] fields = studentClass.getFields();
        System.out.println(&quot;获取所有public修饰的属性， 包括本类及父类&quot;);
        for (int i = 0; i &lt; fields.length; i++) {
            System.out.println(fields[i].getName());
        }

        //获取本类的所有属性
        Field[] fields2 = personClass.getDeclaredFields();
        System.out.println(&quot;获取本类的所有属性&quot;);
        for (int i = 0; i &lt; fields2.length; i++) {
            System.out.println(fields2[i].getName());
        }

        //获取本类和父类和超类所有public修饰的方法
        Method[] methods = studentClass.getMethods();
        System.out.println(&quot;获取本类和父类和超类所有public修饰的方法&quot;);
        for (int i = 0; i &lt; methods.length; i++) {
            System.out.println(methods[i].getName());
        }

        //获取本类中所有的方法
        Method[] methods2 = studentClass.getDeclaredMethods();
        System.out.println(&quot;获取本类中所有的方法&quot;);
        for (int i = 0; i &lt; methods2.length; i++) {
            System.out.println(methods2[i].getName());
        } 

        //获取本类所有public修饰的构造器，`
        Constructor[] constructors = studentClass.getConstructors();
        System.out.println(&quot;获取本类所有public修饰的构造器&quot;);
        for (int i = 0; i &lt; constructors.length; i++) {
            System.out.println(constructors[i].getName());
        }

        //获取本类所有构造器
        Constructor[] constructors2 = studentClass.getDeclaredConstructors();
        System.out.println(&quot;获取本类所有构造器&quot;);
        for (int i = 0; i &lt; constructors2.length; i++) {
            System.out.println(constructors2[i]);
        }

        //获取包名
        System.out.println(&quot;获取包名&quot;);
        System.out.println(studentClass.getPackage());

        //以Class的形式返回父类信息
        Class&lt;?&gt; superclass = studentClass.getSuperclass();
        System.out.println(&quot;以Class的形式返回父类信息&quot;);
        System.out.println(superclass);

        //以Class[]的形式返回接口信息
        Class[] interfaces = studentClass.getInterfaces();
        System.out.println(&quot;以Class[]的形式返回接口信息&quot;);
        for (int i = 0; i &lt; interfaces.length; i++) {
            System.out.println(interfaces[i]);
        }

        //以Annotation[]的形式得到注解信息
        Annotation[] annotations = studentClass.getAnnotations();
        System.out.println(&quot;以Annotation[]的形式得到注解信息&quot;);
        for (int i = 0; i &lt; annotations.length; i++) {
            System.out.println(annotations[i]);
        }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java中final变量的初始化]]></title>
        <id>https://aruul.github.io/post/Z708mjxH2/</id>
        <link href="https://aruul.github.io/post/Z708mjxH2/">
        </link>
        <updated>2021-06-15T04:18:56.000Z</updated>
        <content type="html"><![CDATA[<p>今天在看java中String的源码，发现了自己对final变量初始化的了解不够好，有遗漏的地方，之前只知道第一种初始化方法。</p>
<pre><code class="language-java">public class FinalStudy {
    //第一种 在定义后直接初始化
    private final int a = 1;
    //第二种 声明变量后在构造方法中为其赋值
    //如果采用用这种方式，那么每个构造方法中都要有j赋值的语句
    private final int b;
    public FinalStudy(int b) {
        this.b = b;
    }
    // 初始化方式三，声明变量后在构造代码块中为其赋值
    // 如果采用此方式，就不能在构造方法中再次为其赋值
    // 构造代码块中的代码会在构造函数之前执行，如果在构造函数中再次赋值，
    // 就会造成final变量的重复赋值
    private final int c;
    {
        c = 3;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iPad变成真正的生产力----编程]]></title>
        <id>https://aruul.github.io/post/EJmNDhozo/</id>
        <link href="https://aruul.github.io/post/EJmNDhozo/">
        </link>
        <updated>2021-05-16T11:54:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>iPad被知乎、b站很多人标榜为生产力，其实很早之前我一直觉得surface go才算生产力，毕竟可以编程。自己很偏激的把iPad看作电子垃圾。</p>
<p>但是，由于预算有限，我还是买了ipad2020 128G🤡，毕竟同等价位买surface go2的话，只能买个乞丐版的，而且还是裸机。</p>
<p>ipad买了之后我就有点小后悔，因为我发现我平时用ipad干的最多的就是读pdf，看视频。这完全可以被一个更便宜的安卓平板代替。</p>
<p>后来在想ipad上可不可以像surface go2那样配个键盘编程，于是就花买了一个罗技的蓝牙键盘，手感还不错，ipad、笔记本都可以用。一开始，我发现可以在leetcode网页上在线编程，但是这种在线编程有些难受；我便开始寻找新的解决方案。在ipad搜到了几个编程软件，但是都要付费，还挺贵，我就犹豫了。</p>
<p>就在今天，我刷知乎的时候，看到了github上的一个开源项目【<a href="https://github.com/cdr/code-server">code-server</a>】</p>
<h2 id="code-server">code-server</h2>
<blockquote>
<p><code>code-server</code> 实际上就是专门为浏览器设计优化的 VS Code，可以直接通过浏览器访问。</p>
<p>在远程 Linux 服务器上面部署 <code>code-server</code> 之后，<code>code-server</code> 实际上就相当于一个「中转站」，为我们提供一个直接在 Linux 服务器上面修改文件、访问数据库、执行指令等等操作的「窗口」，而由于这一「窗口」同样在 Linux 服务器上面运行，使用任何一个浏览器都可以打开，所以 iPad 也不例外。</p>
<p>这样，我们就能够借助在远程服务器上运行的 <code>code-server</code>，直接使用远程服务器上面的各种资源（包括服务器上强大的原生 Linux 环境、CPU / GPU 等计算资源、「无尽」的电量等等）进行开发工作。（当然，这也要求我们 iPad 端全程拥有网络连接。）</p>
</blockquote>
<p>所以说需要你有个服务器，非常巧的是我服务器基本上算是吃灰的状态，上面就跑了两个网址的服务。</p>
<h3 id="准备">准备</h3>
<p>我的服务器系统是ubuntu，在github【<a href="https://github.com/cdr/code-server/releases">code-server release</a>】中下载最新版的压缩包，并上传到服务器。</p>
<p>我选的是<a href="https://github.com/cdr/code-server/releases/download/v3.10.0/code-server-3.10.0-linux-amd64.tar.gz">code-server-3.10.0-linux-amd64.tar.gz</a></p>
<p>然后，你要在服务器上下载好screen，如果没下的话，执行一下快速安装命令就好</p>
<pre><code class="language-java">sudo apt-get install screen
</code></pre>
<h3 id="安装">安装</h3>
<p>进入code-server压缩包的目录，然后执行解压命令</p>
<pre><code class="language-java">tar -xvzf code-server-3.10.0-linux-amd64.tar.gz
</code></pre>
<p>再进入解压后的目录</p>
<pre><code class="language-java">cd code-server-3.10.0-linux-amd64
</code></pre>
<p>然后使用screen后台运行</p>
<pre><code>screen -S vscode
</code></pre>
<p>然后运行code-server</p>
<pre><code class="language-java">export PASSWORD=&quot;yourpassword&quot; &amp;&amp; ./code-server --port 888 --host 0.0.0.0 
</code></pre>
<ul>
<li>
<p><code>export PASSWORD=&quot;yourpassword&quot;</code>可以指定密码，将yourpassword替换为你的密码，<mark>引号不要去掉</mark></p>
<p>不加的话会默认生成一个，可以在运行后看到<code>yourpassword</code>为你的密码</p>
</li>
<li>
<p>--port 888为 指定端口运行，我这里是运行在888端口</p>
</li>
<li>
<p>--host 0.0.0.0 默认是127.0.0.1，只能本地访问，无法外网访问，所以得改成0.0.0.0，才能各个浏览器都能访问</p>
</li>
</ul>
<hr>
<p>之后访问你的服务器<code>公网ip:端口号</code>就可以访问了，当然也可以用nginx 代理到自己的域名上。</p>
<p>其他的操作和vscode没什么区别。</p>
<p>我自己配置了编写java用到的插件和配置。</p>
<p>下面是用到的插件</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210517200929.png" alt="image-20210517200928040" loading="lazy"></figure>
<hr>
<p>下面是配置文件,主要是<code>&quot;java.home&quot;:</code>  <code>&quot;java.requirements.JDK11Warning&quot;</code>    <code>&quot;java.semanticHighlighting.enabled&quot;</code>这几个。</p>
<pre><code class="language-java">{
    &quot;java.home&quot;: &quot;/usr/java/jdk1.8.0_121&quot;,
    &quot;java.requirements.JDK11Warning&quot;: false,
    &quot;java.semanticHighlighting.enabled&quot;: true,
    &quot;files.exclude&quot;: {
        &quot;**/.classpath&quot;: true,
        &quot;**/.project&quot;: true,
        &quot;**/.settings&quot;: true,
        &quot;**/.factorypath&quot;: true
    },
    &quot;java.completion.importOrder&quot;: [
        &quot;java&quot;,
        &quot;javax&quot;,
        &quot;com&quot;,
        &quot;org&quot;
    ],
    &quot;java.completion.favoriteStaticMembers&quot;: [
        &quot;org.junit.Assert.*&quot;,
        &quot;org.junit.Assume.*&quot;,
        &quot;org.junit.jupiter.api.Assertions.*&quot;,
        &quot;org.junit.jupiter.api.Assumptions.*&quot;,
        &quot;org.junit.jupiter.api.DynamicContainer.*&quot;,
        &quot;org.junit.jupiter.api.DynamicTest.*&quot;,
        &quot;org.mockito.Mockito.*&quot;,
        &quot;org.mockito.ArgumentMatchers.*&quot;,
        &quot;org.mockito.Answers.*&quot;
    ]
}
</code></pre>
<h2 id="在ipad上编程">在ipad上编程</h2>
<p>那么，怎么在ipad上运行呢。有两种方法：</p>
<ol>
<li>直接在浏览器访问你服务器code-server的网址。</li>
<li>在ipad App Store上搜索 Servediter</li>
</ol>
<p>我推荐第二种，Servediter是一款专门为 iPad 优化的用来连接 <code>code-server</code> 的 iOS 原生应用。我们使用 VSApp 可以直接连接我们自己的 <code>code-server</code> 实例，自动登录，打造畅快的在线 VS Code 体验。</p>
<p>Servediter原本是仅支持连接至它的开发者所部署的 <code>code-server</code> 上面的，因此也包含了 App 内购，最近才更新支持自部署服务器的连接。既然我们都已经自己部署了自己的 <code>code-server</code>，那么我们直接在菜单中选择「Self Hosted Server」，并依次填写：</p>
<ul>
<li>
<p>我们刚刚部署 <code>code-server</code> 的：</p>
</li>
<li>
<ul>
<li><code>code-server URL</code> 刚刚在 Safari 中打开的 URL：<code>{服务器 IP 地址}:{code-server 端口}</code></li>
<li><code>Instance password</code> 刚刚开启 <code>code-server</code> 时设置的密码</li>
</ul>
</li>
<li>
<p>以及，我们服务器自己的：</p>
</li>
<li>
<ul>
<li><code>Host</code>：服务器 IP 地址</li>
<li><code>Username</code>：默认登录用户名</li>
<li><code>Port</code>：登录 SSH 端口（默认 22 端口）</li>
<li><code>Authentication</code>：登录服务器时使用的密码或公钥私钥对</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210516204422.png" alt="image-20210516204421041" loading="lazy"></figure>
<p>这样，就可以愉快的在ipad上写代码了。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210516204906.jpg" alt="QQ图片20210516204848" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树]]></title>
        <id>https://aruul.github.io/post/t70ZdhScS/</id>
        <link href="https://aruul.github.io/post/t70ZdhScS/">
        </link>
        <updated>2021-05-13T11:52:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近一直在刷算法题，感觉还是需要把基础打牢一点，就暂停了刷题，从基本的算法书开始看。</p>
<p>《小灰的算法之旅》一个很基础的书</p>
<h2 id="二叉树">二叉树</h2>
<blockquote>
<p>什么是二叉树？官方是这样定义的：<strong>在计算机科学中，二叉树是每个结点最多有两个子树的树结构</strong>。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。</p>
</blockquote>
<p>其实这些都是很基础的东西，之前数据结构也都学过了。所以一些东西就省去不表。。。</p>
<p>二叉树的数据结构</p>
<pre><code class="language-java">public class TreeNode {
    public int data;
    public TreeNode leftChild;
    public TreeNode rightChild;

    public TreeNode(int data){
        this.data = data;
    }
}
</code></pre>
<h2 id="前序遍历生成二叉树">前序遍历生成二叉树</h2>
<p>我采用的是递归的方式，这样最容易明白</p>
<pre><code class="language-java">    //创建二叉树
	//inputList  存放前序遍历的二叉树的list
    public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inputList){
        TreeNode treeNode = null;
        if(inputList==null||inputList.isEmpty()){
            return null;
        }
        Integer data = inputList.removeFirst();
        if(data!=null){
            treeNode = new TreeNode(data);
            treeNode.leftChild = createBinaryTree(inputList);
            treeNode.rightChild = createBinaryTree(inputList);
        }
        return treeNode;

    }
</code></pre>
<p>测试代码：</p>
<pre><code class="language-java"> public static void main(String[] args) {
        LinkedList&lt;Integer&gt; inputList = new LinkedList&lt;Integer&gt;();
        inputList.add(3); 
        inputList.add(2);
        inputList.add(9);
        inputList.add(null);
        inputList.add(null);
        inputList.add(10);
        inputList.add(null);
        inputList.add(null);
        inputList.add(8);
        inputList.add(null);
        inputList.add(4);
        TreeNode head = createBinaryTree(inputList);

    }
</code></pre>
<h2 id="前序遍历二叉树">前序遍历二叉树</h2>
<h3 id="递归的写法">递归的写法</h3>
<pre><code class="language-java">    //前序遍历--递归的方式
    public static void qian(TreeNode head){
        if(head==null){
            return;
        }
        System.out.println(head.data);
        qian(head.leftChild);
        qian(head.rightChild);
    }
</code></pre>
<h3 id="非递归的写法">非递归的写法</h3>
<pre><code class="language-java">	//前序遍历--非递归的方式
    public static void qian2(TreeNode head){
        // 用栈来存放
        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
 
        while(head!=null||!stack.isEmpty()){
            //迭代访问节点的左节点，并入栈
            while(head!=null){
                System.out.println(head.data);
                stack.push(head);
                head = head.leftChild;
            }

            //若节点没有左孩子，栈中弹出栈顶结点，访问节点右节点
            if(!stack.isEmpty()){
                head = stack.pop();
                head = head.rightChild;
            }
        }
    }
</code></pre>
<h2 id="层次遍历">层次遍历</h2>
<p>大致思路：</p>
<p><img src="https://aruul.github.io/post-images/1620906969722.jpg" alt="" loading="lazy"><br>
<img src="https://aruul.github.io/post-images/1620906979070.jpg" alt="" loading="lazy"></p>
<pre><code class="language-java">//广度优先遍历--层次遍历
    public static void level(TreeNode head){
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(head);
        while (!queue.isEmpty()){
            TreeNode treeNode =queue.poll();
            System.out.println(treeNode.data);
            if(treeNode.leftChild!=null){
                queue.offer(treeNode.leftChild);
            }
            if(treeNode.rightChild!=null){
                queue.offer(treeNode.rightChild);
            }

        }

    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工厂模式]]></title>
        <id>https://aruul.github.io/post/PdwpIn0xO/</id>
        <link href="https://aruul.github.io/post/PdwpIn0xO/">
        </link>
        <updated>2021-05-10T13:24:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="工厂模式">工厂模式</h2>
<h3 id="1前言">1.前言</h3>
<p>设计模式大二的时候就学了，但是现在有些也忘得差不多了，现在决定重新学一遍。</p>
<p>立个flag，一周至少学三种设计模式。</p>
<blockquote>
<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<h3 id="2简单工厂模式">2.简单工厂模式</h3>
<p><strong>应用实例：</strong> 你需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</p>
<hr>
<pre><code class="language-java">/** 简单(静态)工厂模式
 * @author aRu
 * @date 2021/5/8 15:31
 */
public class CarFactory {
    public static Car getCar(String name){
        if(name.equals(&quot;大众&quot;)){
            return new DaZhong();
        }else if (name.equals(&quot;五菱&quot;)){
            return new WuLing();
        }
        return null;
    }
}
</code></pre>
<pre><code class="language-java">/**抽象汽车类
 * @author aRu
 * @date 2021/5/8 15:28
 */
public interface Car {
    void Name();
}
</code></pre>
<pre><code class="language-java">/** 大众
 * @author aRu
 * @date 2021/5/8 15:29
 */
public class DaZhong implements Car{
    @Override
    public void Name() {
        System.out.println(&quot;大众&quot;);
    }
}

----------------------------------------------------------------------------------------
    
/**五菱
 * @author aRu
 * @date 2021/5/8 15:30
 */
public class WuLing implements Car{
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}

</code></pre>
<p>测试</p>
<pre><code class="language-java">/** 测试类
 * @author aRu
 * @date 2021/5/8 15:34
 */

//测试 简单(静态)工厂模式
public class Test {
    public static void main(String[] args) {
        Car car1 = CarFactory.getCar(&quot;大众&quot;);
        Car car2 = CarFactory.getCar(&quot;五菱&quot;);

        car1.Name();
        car2.Name();
    }
}
</code></pre>
<hr>
<p><strong>缺点</strong>：试想当老板提出新需求要加一辆本田汽车的时候，你会发现，你此时不得不去修改<strong>CarFactory</strong>这个类，这就违反了开闭原则.</p>
<h3 id="3方法工厂模式">3.方法工厂模式</h3>
<p>针对上面简单工厂的缺点，我们引出方法工厂模式。</p>
<p>在方法工厂模式中，我们将<strong>工厂抽象起来</strong>，使得每个品牌的汽车都有自己的工厂，而不是像简单工厂模式里，一个大工厂建造不同品牌的车。</p>
<p>当我们需要新添加汽车时，只需要添加新的汽车类和对应的工厂就好。</p>
<hr>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508161257.png" alt="image-20210508161255712" loading="lazy"></figure>
<pre><code class="language-java">//抽象汽车工厂
public interface CarFactory {
    Car getCar();
}
</code></pre>
<pre><code class="language-java">//具体的汽车工厂  
public class WuLingFactory implements CarFactory{
    //五菱工厂
    @Override
    public Car getCar() {
        return new WuLing();
    }
}

----------------------------------------------
 public class DaZhongFactory implements CarFactory{
     //大众工厂
    @Override
    public Car getCar() {
        return new DaZhong();
    }
}
</code></pre>
<pre><code class="language-java">//抽象汽车类
public interface Car {
    void Name();
}
</code></pre>
<pre><code class="language-java">//具体汽车类
public class WuLing implements Car {
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}
----------------------------------------
public class WuLing implements Car {
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//方法工厂模式测试public class Test {    public static void main(String[] args) {        Car car = new WuLingFactory().getCar();        Car car2 = new DaZhongFactory().getCar();        car.Name();        car2.Name();    }}
</code></pre>
<h4 id="4抽象工厂模式">4.抽象工厂模式</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC25. K个一组翻转链表.]]></title>
        <id>https://aruul.github.io/post/ofb0ZIr8t/</id>
        <link href="https://aruul.github.io/post/ofb0ZIr8t/">
        </link>
        <updated>2021-05-09T13:15:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509195221.png" alt="image-20210509195220283" loading="lazy"></figure>
<pre><code class="language-java">输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
</code></pre>
</blockquote>
<h3 id="补充">补充</h3>
<p>ListNode定义如下</p>
<pre><code class="language-java">public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
</code></pre>
<h3 id="解法">解法</h3>
<pre><code class="language-java">    public static ListNode reverseKGroup(ListNode head, int k) {

        if(head == null) return head;
        ListNode a = head;
        ListNode b = head;
        for (int i = 0; i &lt; k; i++) {
            if(b == null) return head;
            b = b.next;
        }
        ListNode newNode = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newNode;
    }

    // 反转[a,b)个节点
    public static ListNode reverse(ListNode a, ListNode b) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=b){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<h3 id="思路">思路</h3>
<p>首先，由一道和他类似的题<a href="https://leetcode-cn.com/problems/reverse-linked-list/">【<strong>LC206. 反转链表</strong>】</a>引出我的解法。</p>
<p>在我之前的博客中这道题采用了递归解法。</p>
<p>其实，还有还可以用while循环来解。</p>
<pre><code class="language-java">    public static ListNode reverse(ListNode a) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<p>上面的代码完成了 给定一个链表头a，将这个链表反转。</p>
<p>具体步骤如下：</p>
<p>这是链表的初始状态：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509200639.png" alt="image-20210509200638636" loading="lazy"></figure>
<hr>
<hr>
<p>然后开始执行该函数, 将【前置节点pre】指为null，将【当前节点cur】指向a</p>
<pre><code class="language-java"> ListNode pre,cur,next;
 pre = null;
 cur = a;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509201429.png" alt="image-20210509201427829" loading="lazy"></figure>
<hr>
<hr>
<p>当【当前节点cur】不为空的时候，将【next节点】指向【当前节点cur的下一个】</p>
<pre><code class="language-java">while(cur!=null){
            next = cur.next;
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509201824.png" alt="image-20210509201823579" loading="lazy"></figure>
<hr>
<hr>
<p>之后将【当前节点cur】指向【前置节点pre】</p>
<pre><code class="language-java">cur.next = pre;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204604.png" alt="image-20210509204603462" loading="lazy"></figure>
<hr>
<hr>
<p>然后【pre、cur】开始向后移动一个节点，即：</p>
<ul>
<li>将【前置节点pre】移动到【当前节点cur】的位置</li>
<li>将【当前节点cur】移动到【后置节点next】的位置</li>
</ul>
<p><mark>注意：这时候没有移动next是因为不确定移动后【cur】是否为null。</mark></p>
<p><mark>当【cur】为null的时候再移动【后置节点next】会抛出空指针异常。这也是为什么循环的条件是【cur】不为null</mark></p>
<pre><code class="language-java">pre = cur;
cur = next;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204700.png" alt="image-20210509204659403" loading="lazy"></figure>
<hr>
<p>之后在while的循环条件中判断【cur】是否为空， 不为空则进入循环</p>
<p>进入循环中，重复之前的操作。将【next节点】指向【当前节点cur的下一个】</p>
<pre><code class="language-java">next = cur.next;
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204748.png" alt="image-20210509204747387" loading="lazy"></figure>
<hr>
<hr>
<p>之后将【当前节点cur】指向【前置节点pre】</p>
<pre><code class="language-java">cur.next = pre;
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204827.png" alt="image-20210509204825846" loading="lazy"></figure>
<hr>
<p>然后【pre、cur】开始向后移动一个节点，即：</p>
<ul>
<li>将【前置节点pre】移动到【当前节点cur】的位置</li>
<li>将【当前节点cur】移动到【后置节点next】的位置</li>
</ul>
<pre><code class="language-java">pre = cur;
cur = next;
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204904.png" alt="image-20210509204902250" loading="lazy"></figure>
<hr>
<p>以此类推，直到【当前节点cur】为null，停止循环，返回【前置节点pre】</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205131.png" alt="image-20210509205128892" loading="lazy"></figure>
<hr>
<p>那反转链表的一部分呢，比如反转【a，b）之间的节点 （左闭右开）</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205450.png" alt="image-20210509205449221" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205552.png" alt="image-20210509205551013" loading="lazy"></figure>
<p>你会发现，它其实和我们反转整个链表差不多，反转整个链表的时候，</p>
<p>是相当于反转【a，null）之间的节点，</p>
<p>和反转【a，b）之间的节点有异曲同工之妙啊~</p>
<p>所以说，反转【a，b）之间的节点的代码就应该在他的基础改一改，把</p>
<pre><code class="language-java">while(cur!=null)
</code></pre>
<p>改为</p>
<pre><code class="language-java">while(cur!=b)
</code></pre>
<p>代码如下：</p>
<pre><code class="language-java">    // 反转[a,b)个节点
    public static ListNode reverse(ListNode a, ListNode b) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=b){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<hr>
<p>这和 K个一组翻转链表反转 有啥子关系呢？</p>
<p>每K个一组就是相当于区间【a，b）之间的节点有K个，然后一一反转。</p>
<p>这就用到了递归</p>
<pre><code class="language-java">    public static ListNode reverseKGroup(ListNode head, int k) {

        if(head == null) return head;
        // 区间 [a, b) 包含 k 个待反转元素
        ListNode a = head;
        ListNode b = head;
        for (int i = 0; i &lt; k; i++) {
             // 不足 k 个，不需要反转
            if(b == null) return head;
            b = b.next;
        }
        // 反转前 k 个元素,并获得反转后的头节点
        ListNode newNode = reverse(a, b);
        // 递归反转后续链表并连接起来，这里a反转后由子节点中由头变为尾，所以和a.next拼接
        a.next = reverseKGroup(b, k);
        return newNode;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC206链表反转]]></title>
        <id>https://aruul.github.io/post/hM2JnmBVE/</id>
        <link href="https://aruul.github.io/post/hM2JnmBVE/">
        </link>
        <updated>2021-05-08T10:41:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508164053.png" alt="image-20210508164052248" loading="lazy"></figure>
<p>输入：head = [1,2,3,4,5]<br>
输出：[5,4,3,2,1]</p>
</blockquote>
<h3 id="补充">补充</h3>
<p>ListNode定义如下</p>
<pre><code class="language-java">public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
</code></pre>
<h3 id="解法">解法</h3>
<p>我之前刚好看过这个题的解析教程，所以就用递归小小的装个逼</p>
<pre><code class="language-java"> public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }

        ListNode last = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return last;
    }
</code></pre>
<p><strong>大概思路如下：</strong></p>
<p>这个递归其实做的是：</p>
<p>​	如果这和链表是个空的或者只有一个节点，则反转之后还是本身。</p>
<pre><code class="language-java">if(head==null||head.next==null){
            return head;
 }
</code></pre>
<hr>
<p>​	如果不是，则一直查找下一个节点，</p>
<pre><code class="language-java">ListNode last = reverseList(head.next);
</code></pre>
<hr>
<p>​	直到某个节点的next的next为null【其实就是找倒数第二个节点】</p>
<pre><code class="language-java">if(head==null||head.next==null){
     return head;
 }
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508165935.png" alt="image-20210508165933723" loading="lazy"></figure>
<hr>
<p>并将last=最后一个节点</p>
<pre><code class="language-java">ListNode last = reverseList(head.next);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170116.png" alt="image-20210508170111643" loading="lazy"></figure>
<hr>
<p>此时head=倒数第二个节点</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170608.png" alt="image-20210508170602536" loading="lazy"></figure>
<hr>
<p>在将此时head的next的next指向head，【其实就是把最后一个节点指向倒数第二个，做的就是反转链表】</p>
<pre><code class="language-java">head.next.next = head;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170950.png" alt="image-20210508170948257" loading="lazy"></figure>
<hr>
<p>这时候 将head.next=null 【把head指向空】</p>
<pre><code class="language-jav">head.next = null;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508171248.png" alt="image-20210508171244794" loading="lazy"></figure>
<hr>
<p>这时候，其实已经反转了一部分了。</p>
<p>然后再将last返回给上一级【也就是3】，此时last=最后一个节点【也就是5】。</p>
<p><strong>其他的节点 以此类推，直到结束</strong></p>
<p><strong>最后的时候，再返回一个last，也就是5</strong></p>
<h2 id=""><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508183828.png" alt="image-20210508183826788" loading="lazy"></h2>
<p>结束</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java反射(2)  反射调用的性能和优化方案]]></title>
        <id>https://aruul.github.io/post/L4U-TAPK3/</id>
        <link href="https://aruul.github.io/post/L4U-TAPK3/">
        </link>
        <updated>2021-05-04T08:51:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="反射调用的性能和优化方案">反射调用的性能和优化方案</h2>
<h3 id="对比">对比</h3>
<p>普通方法</p>
<pre><code class="language-java">    //普通方法
    public static void m1(){
        Cat cat = new Cat();

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            cat.say();
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;普通方法执行时间：&quot;+(end-start));
    }
</code></pre>
<p>通过反射</p>
<pre><code class="language-java">//反射
    public static void m2() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class aClass = Class.forName(&quot;org.example.Cat&quot;);
        Object o = aClass.newInstance();
        Method say = aClass.getMethod(&quot;say&quot;);

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            say.invoke(o);
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;反射机制执行时间：&quot;+(end-start));


    }
</code></pre>
<p>两者运行时间对比</p>
<pre><code>普通方法执行时间：3 ms
反射机制执行时间：175 ms
</code></pre>
<h3 id="优化">优化</h3>
<blockquote>
<p>反射调用优化-关闭访问检查</p>
<ol>
<li>Method和 Field、 Constructor象都有 setAccessible()方法</li>
<li>setAccessible()作用是启动和禁用访问安全检查的开关<br>
3.参数值为true表示反射的对象在使用时取消访向检查，提高反射的效率。<br>
参数值为 false则表示反射的对象执行访向检查</li>
</ol>
</blockquote>
<p>所以可以通过setAccessible()来优化反射。</p>
<p>其实呢，优化之后效率也没有高出很多。</p>
<pre><code class="language-java">    //反射优化
    public static void m3() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class aClass = Class.forName(&quot;org.example.Cat&quot;);
        Object o = aClass.newInstance();
        Method say = aClass.getMethod(&quot;say&quot;);

        //取消在反射调用方法时 取消访问检测
        say.setAccessible(true);


        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            say.invoke(o);
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;反射优化机制执行时间：&quot;+(end-start));

    }
</code></pre>
<hr>
<p>执行结果对比</p>
<pre><code>普通方法执行时间：3 ms
反射机制执行时间：176 ms
反射优化机制执行时间：129 ms
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java 反射(1)--快速开始]]></title>
        <id>https://aruul.github.io/post/s8pJIRpaT/</id>
        <link href="https://aruul.github.io/post/s8pJIRpaT/">
        </link>
        <updated>2021-05-03T13:18:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="快速开始">快速开始</h3>
<h4 id="1什么是反射">1.什么是反射？</h4>
<p>如果你研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。</p>
<p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<p><strong>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</strong></p>
<h4 id="2反射机制优缺点">2.反射机制优缺点</h4>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li>
</ul>
<h4 id="3由一个例子引出反射">3.由一个例子引出反射</h4>
<h5 id="31需求">3.1需求</h5>
<blockquote>
<p>根据配置文件re. properties指定信息，创建Cat过象并调用方法say</p>
</blockquote>
<p>re. properties文件</p>
<pre><code class="language-properties">classfullpath=org.example.Cat
method=say
</code></pre>
<p>Cat</p>
<pre><code class="language-java">package org.example;

/**
 * @author aRu
 * @date 2021/5/3 10:01
 */
public class Cat {
    private String name = &quot;招财猫&quot;;
    public int age= 3;

    public Cat() {
    }

    public Cat(String name) {
        this.name = name;
    }

    public void say(){
        System.out.println(&quot;miao~ i am &quot;+name);
    }
}
</code></pre>
<p>工程目录如下，本次代码写在org.example.quickStart_01下</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210503213409.png" alt="image-20210503213403742" loading="lazy"></figure>
<h5 id="32实现">3.2实现</h5>
<pre><code class="language-java">package org.example.quickStart_01;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

/**问题的引入
 * @author aRu
 * @date 2021/5/3 10:04
 */
public class ReflectionQuickStart {
    public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        //根据配置文件 创建Cat对象并调用 配置文件中指定的方法

        //1.读取配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\org\\example\\re.properties&quot;));
        String classfullpath = properties.get(&quot;classfullpath&quot;).toString();
        String method = properties.get(&quot;method&quot;).toString();
        System.out.println(&quot;类的全路径： &quot;+classfullpath);
        System.out.println(&quot;方法名： &quot;+method);

        //2.使用反射机制
        Class cls = Class.forName(classfullpath);
        //通过 cls 得到你加载的类 Cat的对象实例
        Object o = cls.newInstance();
        System.out.println(&quot;o的类型： &quot;+o.getClass());
        //通过cls 得到你加载的类Cat的 method 方法
        Method method1 = cls.getMethod(method);
        //通过method1 调用方法： 即，通过方法对象 来实现调用方法
        method1.invoke(o);
        

    }
}

</code></pre>
<hr>
<p>运行结果</p>
<pre><code>类的全路径： org.example.Cat
方法名： say
o的类型： class org.example.Cat
miao~ i am 招财猫
</code></pre>
<p>补充</p>
<pre><code class="language-java">        //得到类的成员变量
        //注意： cls.getField(&quot;name&quot;)不能得到私有的属性
        Field nameField = cls.getField(&quot;age&quot;);
        System.out.println(nameField.get(o));

        //得到对象的构造函数
        Constructor constructor = cls.getConstructor();//()中可以指定构造参数类型，这里没写，则返回无参构造
        System.out.println(&quot;无参构造：&quot;+constructor);

        Constructor constructor2 = cls.getConstructor(String.class);
        System.out.println(&quot;有参构造：&quot;+constructor2);
</code></pre>
]]></content>
    </entry>
</feed>