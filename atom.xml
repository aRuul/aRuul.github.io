<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aruul.github.io</id>
    <title>aRuul的无名小站</title>
    <updated>2021-05-09T13:16:01.408Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aruul.github.io"/>
    <link rel="self" href="https://aruul.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aruul.github.io/images/avatar.png</logo>
    <icon>https://aruul.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, aRuul的无名小站</rights>
    <entry>
        <title type="html"><![CDATA[LC25. K个一组翻转链表.]]></title>
        <id>https://aruul.github.io/post/ofb0ZIr8t/</id>
        <link href="https://aruul.github.io/post/ofb0ZIr8t/">
        </link>
        <updated>2021-05-09T13:15:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509195221.png" alt="image-20210509195220283" loading="lazy"></figure>
<pre><code class="language-java">输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
</code></pre>
</blockquote>
<h3 id="补充">补充</h3>
<p>ListNode定义如下</p>
<pre><code class="language-java">public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
</code></pre>
<h3 id="解法">解法</h3>
<pre><code class="language-java">    public static ListNode reverseKGroup(ListNode head, int k) {

        if(head == null) return head;
        ListNode a = head;
        ListNode b = head;
        for (int i = 0; i &lt; k; i++) {
            if(b == null) return head;
            b = b.next;
        }
        ListNode newNode = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newNode;
    }

    // 反转[a,b)个节点
    public static ListNode reverse(ListNode a, ListNode b) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=b){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<h3 id="思路">思路</h3>
<p>首先，由一道和他类似的题<a href="https://leetcode-cn.com/problems/reverse-linked-list/">【<strong>LC206. 反转链表</strong>】</a>引出我的解法。</p>
<p>在我之前的博客中这道题采用了递归解法。</p>
<p>其实，还有还可以用while循环来解。</p>
<pre><code class="language-java">    public static ListNode reverse(ListNode a) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<p>上面的代码完成了 给定一个链表头a，将这个链表反转。</p>
<p>具体步骤如下：</p>
<p>这是链表的初始状态：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509200639.png" alt="image-20210509200638636" loading="lazy"></figure>
<hr>
<hr>
<p>然后开始执行该函数, 将【前置节点pre】指为null，将【当前节点cur】指向a</p>
<pre><code class="language-java"> ListNode pre,cur,next;
 pre = null;
 cur = a;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509201429.png" alt="image-20210509201427829" loading="lazy"></figure>
<hr>
<hr>
<p>当【当前节点cur】不为空的时候，将【next节点】指向【当前节点cur的下一个】</p>
<pre><code class="language-java">while(cur!=null){
            next = cur.next;
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509201824.png" alt="image-20210509201823579" loading="lazy"></figure>
<hr>
<hr>
<p>之后将【当前节点cur】指向【前置节点pre】</p>
<pre><code class="language-java">cur.next = pre;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204604.png" alt="image-20210509204603462" loading="lazy"></figure>
<hr>
<hr>
<p>然后【pre、cur】开始向后移动一个节点，即：</p>
<ul>
<li>将【前置节点pre】移动到【当前节点cur】的位置</li>
<li>将【当前节点cur】移动到【后置节点next】的位置</li>
</ul>
<p><mark>注意：这时候没有移动next是因为不确定移动后【cur】是否为null。</mark></p>
<p><mark>当【cur】为null的时候再移动【后置节点next】会抛出空指针异常。这也是为什么循环的条件是【cur】不为null</mark></p>
<pre><code class="language-java">pre = cur;
cur = next;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204700.png" alt="image-20210509204659403" loading="lazy"></figure>
<hr>
<p>之后在while的循环条件中判断【cur】是否为空， 不为空则进入循环</p>
<p>进入循环中，重复之前的操作。将【next节点】指向【当前节点cur的下一个】</p>
<pre><code class="language-java">next = cur.next;
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204748.png" alt="image-20210509204747387" loading="lazy"></figure>
<hr>
<hr>
<p>之后将【当前节点cur】指向【前置节点pre】</p>
<pre><code class="language-java">cur.next = pre;
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204827.png" alt="image-20210509204825846" loading="lazy"></figure>
<hr>
<p>然后【pre、cur】开始向后移动一个节点，即：</p>
<ul>
<li>将【前置节点pre】移动到【当前节点cur】的位置</li>
<li>将【当前节点cur】移动到【后置节点next】的位置</li>
</ul>
<pre><code class="language-java">pre = cur;
cur = next;
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204904.png" alt="image-20210509204902250" loading="lazy"></figure>
<hr>
<p>以此类推，直到【当前节点cur】为null，停止循环，返回【前置节点pre】</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205131.png" alt="image-20210509205128892" loading="lazy"></figure>
<hr>
<p>那反转链表的一部分呢，比如反转【a，b）之间的节点 （左闭右开）</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205450.png" alt="image-20210509205449221" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205552.png" alt="image-20210509205551013" loading="lazy"></figure>
<p>你会发现，它其实和我们反转整个链表差不多，反转整个链表的时候，</p>
<p>是相当于反转【a，null）之间的节点，</p>
<p>和反转【a，b）之间的节点有异曲同工之妙啊~</p>
<p>所以说，反转【a，b）之间的节点的代码就应该在他的基础改一改，把</p>
<pre><code class="language-java">while(cur!=null)
</code></pre>
<p>改为</p>
<pre><code class="language-java">while(cur!=b)
</code></pre>
<p>代码如下：</p>
<pre><code class="language-java">    // 反转[a,b)个节点
    public static ListNode reverse(ListNode a, ListNode b) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=b){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<hr>
<p>这和 K个一组翻转链表反转 有啥子关系呢？</p>
<p>每K个一组就是相当于区间【a，b）之间的节点有K个，然后一一反转。</p>
<p>这就用到了递归</p>
<pre><code class="language-java">    public static ListNode reverseKGroup(ListNode head, int k) {

        if(head == null) return head;
        // 区间 [a, b) 包含 k 个待反转元素
        ListNode a = head;
        ListNode b = head;
        for (int i = 0; i &lt; k; i++) {
             // 不足 k 个，不需要反转
            if(b == null) return head;
            b = b.next;
        }
        // 反转前 k 个元素,并获得反转后的头节点
        ListNode newNode = reverse(a, b);
        // 递归反转后续链表并连接起来，这里a反转后由子节点中由头变为尾，所以和a.next拼接
        a.next = reverseKGroup(b, k);
        return newNode;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC206链表反转]]></title>
        <id>https://aruul.github.io/post/hM2JnmBVE/</id>
        <link href="https://aruul.github.io/post/hM2JnmBVE/">
        </link>
        <updated>2021-05-08T10:41:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508164053.png" alt="image-20210508164052248" loading="lazy"></figure>
<p>输入：head = [1,2,3,4,5]<br>
输出：[5,4,3,2,1]</p>
</blockquote>
<h3 id="补充">补充</h3>
<p>ListNode定义如下</p>
<pre><code class="language-java">public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
</code></pre>
<h3 id="解法">解法</h3>
<p>我之前刚好看过这个题的解析教程，所以就用递归小小的装个逼</p>
<pre><code class="language-java"> public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }

        ListNode last = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return last;
    }
</code></pre>
<p><strong>大概思路如下：</strong></p>
<p>这个递归其实做的是：</p>
<p>​	如果这和链表是个空的或者只有一个节点，则反转之后还是本身。</p>
<pre><code class="language-java">if(head==null||head.next==null){
            return head;
 }
</code></pre>
<hr>
<p>​	如果不是，则一直查找下一个节点，</p>
<pre><code class="language-java">ListNode last = reverseList(head.next);
</code></pre>
<hr>
<p>​	直到某个节点的next的next为null【其实就是找倒数第二个节点】</p>
<pre><code class="language-java">if(head==null||head.next==null){
     return head;
 }
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508165935.png" alt="image-20210508165933723" loading="lazy"></figure>
<hr>
<p>并将last=最后一个节点</p>
<pre><code class="language-java">ListNode last = reverseList(head.next);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170116.png" alt="image-20210508170111643" loading="lazy"></figure>
<hr>
<p>此时head=倒数第二个节点</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170608.png" alt="image-20210508170602536" loading="lazy"></figure>
<hr>
<p>在将此时head的next的next指向head，【其实就是把最后一个节点指向倒数第二个，做的就是反转链表】</p>
<pre><code class="language-java">head.next.next = head;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170950.png" alt="image-20210508170948257" loading="lazy"></figure>
<hr>
<p>这时候 将head.next=null 【把head指向空】</p>
<pre><code class="language-jav">head.next = null;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508171248.png" alt="image-20210508171244794" loading="lazy"></figure>
<hr>
<p>这时候，其实已经反转了一部分了。</p>
<p>然后再将last返回给上一级【也就是3】，此时last=最后一个节点【也就是5】。</p>
<p><strong>其他的节点 以此类推，直到结束</strong></p>
<p><strong>最后的时候，再返回一个last，也就是5</strong></p>
<h2 id=""><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508183828.png" alt="image-20210508183826788" loading="lazy"></h2>
<p>结束</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java反射(2)  反射调用的性能和优化方案]]></title>
        <id>https://aruul.github.io/post/L4U-TAPK3/</id>
        <link href="https://aruul.github.io/post/L4U-TAPK3/">
        </link>
        <updated>2021-05-04T08:51:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="反射调用的性能和优化方案">反射调用的性能和优化方案</h2>
<h3 id="对比">对比</h3>
<p>普通方法</p>
<pre><code class="language-java">    //普通方法
    public static void m1(){
        Cat cat = new Cat();

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            cat.say();
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;普通方法执行时间：&quot;+(end-start));
    }
</code></pre>
<p>通过反射</p>
<pre><code class="language-java">//反射
    public static void m2() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class aClass = Class.forName(&quot;org.example.Cat&quot;);
        Object o = aClass.newInstance();
        Method say = aClass.getMethod(&quot;say&quot;);

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            say.invoke(o);
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;反射机制执行时间：&quot;+(end-start));


    }
</code></pre>
<p>两者运行时间对比</p>
<pre><code>普通方法执行时间：3 ms
反射机制执行时间：175 ms
</code></pre>
<h3 id="优化">优化</h3>
<blockquote>
<p>反射调用优化-关闭访问检查</p>
<ol>
<li>Method和 Field、 Constructor象都有 setAccessible()方法</li>
<li>setAccessible()作用是启动和禁用访问安全检查的开关<br>
3.参数值为true表示反射的对象在使用时取消访向检查，提高反射的效率。<br>
参数值为 false则表示反射的对象执行访向检查</li>
</ol>
</blockquote>
<p>所以可以通过setAccessible()来优化反射。</p>
<p>其实呢，优化之后效率也没有高出很多。</p>
<pre><code class="language-java">    //反射优化
    public static void m3() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class aClass = Class.forName(&quot;org.example.Cat&quot;);
        Object o = aClass.newInstance();
        Method say = aClass.getMethod(&quot;say&quot;);

        //取消在反射调用方法时 取消访问检测
        say.setAccessible(true);


        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            say.invoke(o);
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;反射优化机制执行时间：&quot;+(end-start));

    }
</code></pre>
<hr>
<p>执行结果对比</p>
<pre><code>普通方法执行时间：3 ms
反射机制执行时间：176 ms
反射优化机制执行时间：129 ms
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java 反射(1)--快速开始]]></title>
        <id>https://aruul.github.io/post/s8pJIRpaT/</id>
        <link href="https://aruul.github.io/post/s8pJIRpaT/">
        </link>
        <updated>2021-05-03T13:18:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="快速开始">快速开始</h3>
<h4 id="1什么是反射">1.什么是反射？</h4>
<p>如果你研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。</p>
<p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<p><strong>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</strong></p>
<h4 id="2反射机制优缺点">2.反射机制优缺点</h4>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li>
</ul>
<h4 id="3由一个例子引出反射">3.由一个例子引出反射</h4>
<h5 id="31需求">3.1需求</h5>
<blockquote>
<p>根据配置文件re. properties指定信息，创建Cat过象并调用方法say</p>
</blockquote>
<p>re. properties文件</p>
<pre><code class="language-properties">classfullpath=org.example.Cat
method=say
</code></pre>
<p>Cat</p>
<pre><code class="language-java">package org.example;

/**
 * @author aRu
 * @date 2021/5/3 10:01
 */
public class Cat {
    private String name = &quot;招财猫&quot;;
    public int age= 3;

    public Cat() {
    }

    public Cat(String name) {
        this.name = name;
    }

    public void say(){
        System.out.println(&quot;miao~ i am &quot;+name);
    }
}
</code></pre>
<p>工程目录如下，本次代码写在org.example.quickStart_01下</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210503213409.png" alt="image-20210503213403742" loading="lazy"></figure>
<h5 id="32实现">3.2实现</h5>
<pre><code class="language-java">package org.example.quickStart_01;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

/**问题的引入
 * @author aRu
 * @date 2021/5/3 10:04
 */
public class ReflectionQuickStart {
    public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        //根据配置文件 创建Cat对象并调用 配置文件中指定的方法

        //1.读取配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\org\\example\\re.properties&quot;));
        String classfullpath = properties.get(&quot;classfullpath&quot;).toString();
        String method = properties.get(&quot;method&quot;).toString();
        System.out.println(&quot;类的全路径： &quot;+classfullpath);
        System.out.println(&quot;方法名： &quot;+method);

        //2.使用反射机制
        Class cls = Class.forName(classfullpath);
        //通过 cls 得到你加载的类 Cat的对象实例
        Object o = cls.newInstance();
        System.out.println(&quot;o的类型： &quot;+o.getClass());
        //通过cls 得到你加载的类Cat的 method 方法
        Method method1 = cls.getMethod(method);
        //通过method1 调用方法： 即，通过方法对象 来实现调用方法
        method1.invoke(o);
        

    }
}

</code></pre>
<hr>
<p>运行结果</p>
<pre><code>类的全路径： org.example.Cat
方法名： say
o的类型： class org.example.Cat
miao~ i am 招财猫
</code></pre>
<p>补充</p>
<pre><code class="language-java">        //得到类的成员变量
        //注意： cls.getField(&quot;name&quot;)不能得到私有的属性
        Field nameField = cls.getField(&quot;age&quot;);
        System.out.println(nameField.get(o));

        //得到对象的构造函数
        Constructor constructor = cls.getConstructor();//()中可以指定构造参数类型，这里没写，则返回无参构造
        System.out.println(&quot;无参构造：&quot;+constructor);

        Constructor constructor2 = cls.getConstructor(String.class);
        System.out.println(&quot;有参构造：&quot;+constructor2);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java注解浅谈]]></title>
        <id>https://aruul.github.io/post/3NqPQbqyz/</id>
        <link href="https://aruul.github.io/post/3NqPQbqyz/">
        </link>
        <updated>2021-05-03T13:13:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="注解">注解</h3>
<hr>
<h4 id="内置注解">内置注解</h4>
<ul>
<li>
<p>@Override</p>
<p>表示一个方法声名打算重写超类中的另一个方法声明。</p>
</li>
<li>
<p>@Deprecated</p>
<p>表示不鼓励程序员使用这样的元素</p>
</li>
<li>
<p>@SuppressWarnings()</p>
<p>抑制编译时的警告信息</p>
<p>如@SuppressWarnings(&quot;all&quot;)等</p>
<hr>
<h4 id="元注解">元注解</h4>
<p>除了直接使用JDK 定义好的注解，我们还可以自定义注解，在JDK 1.5中提供了4个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：</p>
</li>
<li>
<p>@Target</p>
<p>Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方</p>
</li>
<li>
<p>@Retention</p>
<p>Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）</p>
<p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。</p>
<p><mark>RUNTIME一般较常用</mark></p>
<pre><code>SOURCE,    // 源文件保留
CLASS,       // 编译期保留，默认值
RUNTIME   // 运行期保留，可通过反射去获取注解信息
</code></pre>
</li>
<li>
<p>@Documented</p>
<p>表示是否将注解生成在JavaDoc中</p>
</li>
<li>
<p>@Inherited</p>
<p>子类可以继承父类的注解</p>
</li>
</ul>
<p>我们可以使用这4个元注解来对我们自定义的注解类型进行注解</p>
<hr>
<h4 id="自定义注解">自定义注解</h4>
<p>使用@interface</p>
<pre><code class="language-JAVA">//定义一个注解
@Target(value = {ElementType.METHOD,ElementType.TYPE})  //表示注解可以用在方法、类上
@Retention(value = RetentionPolicy.RUNTIME)             //表示注解在什么时候有效RUNTIME&gt;class&gt;sources
@Documented                                             //表示是否将注解生成在JavaDoc中
@Inherited                                              //子类可以继承父类的注解
public @interface MyAnnotation{

}
</code></pre>
<pre><code class="language-java">//定义一个注解
@Target(value = {ElementType.METHOD,ElementType.TYPE})  //表示注解可以用在方法、类上
@Retention(value = RetentionPolicy.RUNTIME)             //表示注解在什么时候有效RUNTIME&gt;class&gt;sources
@Documented                                             //表示是否将注解生成在JavaDoc中
@Inherited                                              //子类可以继承父类的注解
public @interface MyAnnotation{
    //注解的参数： 参数类型+参数名()
    String name() default &quot;&quot;;  //default 表示默认值  这里是默认值为空
    int age() default 0;
    int id() default -1;    //默认值为-1，代表不存在

    String [] schools();
}


@Target(value = {ElementType.METHOD,ElementType.TYPE})  //表示注解可以用在方法、类上
@Retention(value = RetentionPolicy.RUNTIME)             //表示注解在什么时候有效RUNTIME&gt;class&gt;sources
public @interface MyAnnotation2{
    String value();  //如果注解中只有一个参数，则建议定义为value，这样在使用的时候直接写  @MyAnnotation2(&quot;赋值&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ubuntu ngnix的安装和配置]]></title>
        <id>https://aruul.github.io/post/xeGoYob77/</id>
        <link href="https://aruul.github.io/post/xeGoYob77/">
        </link>
        <updated>2021-04-30T01:24:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1>
<h2 id="什么是-nginx">什么是 Nginx</h2>
<p>一个项目或平台，用户使用量少，并发量小的情况下，一台 Tomcat 服务器就可以满足需求。但当平台用户量增多，并发量增大时，一台 Tomcat 服务器就不能够很好地支撑。于是就需要做横向扩展，多增加几台服务器，并设置一个代理服务器。用户如果要访问平台首先会经过代理服务器，代理服务器实现处理用户的请求和转发到真实服务器，也就是反向代理。在做横向扩展后，每台服务器的大小、性能可能各不相同。代理服务器需要根据用户的请求，服务器的状态等实际情况实现选择和转发，也就是负载均衡。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudybda5ac84-227d-47b9-8711-d19567828c6d.png" alt="img" loading="lazy"><br>
Nginx（ engine x ）是一个高性能的 HTTP 和反向代理 web 服务器。<br>
Nginx 特点是占用内存少，并发能力强。1M 左右的内存支持高达 50000 个并发连接数的响应，而 Tomcat 只支持 500~600 个响应。<br>
Nginx 安装简单，配置文件简洁，启动容易且能持续运行。<br>
Nginx 的作用简单来说就是反向代理和负载均衡。</p>
<h2 id="正向代理和反向代理">正向代理和反向代理</h2>
<p>正向代理基于客户端，代理客户端，是一种主动地行为。比如使用 VPN 访问外网，用户需要手动选择香港、日本或美国的节点，通过节点转发到外网服务器，这些节点代理了外网的服务器。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy872b3db7-d641-4ef7-9811-73a748fd1c27.png" alt="img" loading="lazy"><br>
反向代理基于服务端，代理服务端，是一种被动地行为。比如访问百度，百度的服务器可能不在同一个地方，但是用户可以通过访问百度的域名 www.baidu.com，由代理服务器实现转发，这个过程用户是无感知的。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyeacfb3ba-66bf-467e-b414-33bd466b046c.png" alt="img" loading="lazy"></p>
<h2 id="负载均衡">负载均衡</h2>
<p>Nginx 提供的负载均衡策略有 2 种：内置策略和扩展策略。内置策略分为轮询，加权轮询，Ip hash。扩展策略由程序员自行创造。<br>
轮询<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy33a6e959-9de6-4361-9452-63add93d36db.png" alt="img" loading="lazy"><br>
加权轮询<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyce51f657-9c95-44eb-a473-46b12f3e173c.png" alt="img" loading="lazy"><br>
Ip hash<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy8406dd2c-6596-4292-8890-3423e095f28f.png" alt="img" loading="lazy"><br>
动静分离<br>
一个项目中，有些请求需要后台处理，而有些请求不需要后台处理，如 HTML、CSS、JavaScript 等文件，这些文件统称为静态资源。在开发中将不经常变动地资源与经常变动地资源分离，将这些静态资源缓存到本地 Nginx 中，由 Nginx 直接返回，可以大大提高资源响应的速度和网页的健壮性。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy4ffdae63-5189-4289-b465-94b1be9e731d.png" alt="img" loading="lazy"></p>
<hr>
<h1 id="nginx-安装">Nginx 安装</h1>
<p>1、下载 nginx。<br>
下载 Linux 安装包，使用<code>tar -zxvf</code>命令解压到对应的目录即可。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy2700bc18-8194-43ba-aa31-6fbb78906ed1.png" alt="img" loading="lazy"><br>
2、安装 nginx 所需依赖。</p>
<pre><code>yum install gcc-c++
yum install -y pcre pcre-devel
yum install -y openssl openssl-devel
</code></pre>
<p>3、进入 nginx 目录，执行以下两个命令。</p>
<pre><code>./configuremake install
</code></pre>
<p>4、查找 nginx 安装路径并进入。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyf7a7e81f-7e8c-49af-a17a-b2a5794fb73c.png" alt="img" loading="lazy"><br>
5、启动 nginx。</p>
<pre><code>./nginx
</code></pre>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudycedd22d3-3f9a-4672-8262-403135731260.png" alt="img" loading="lazy"><br>
6、查看 nginx 配置文件.<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyda8d055d-e44a-45f3-937e-6c9eefc4877a.png" alt="img" loading="lazy"><br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy47e6db4a-df2b-43a9-a501-47e1e2fbc1df.png" alt="img" loading="lazy"><br>
7、检查 nginx 是否启动成功。<br>
访问 服务器 ip:80，如果出现以下画面则说明 nginx 启动成功。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy5d020ccc-718c-4774-a07b-70168482f697.png" alt="img" loading="lazy"><br>
如果访问失败，检查服务器防火墙和阿里云安全组的端口是否开启。</p>
<hr>
<h1 id="nginx-常用命令">Nginx 常用命令</h1>
<pre><code class="language-java">cd /usr/local/nginx/sbin/
./nginx  启动
./nginx -s stop  停止
./nginx -s quit  安全退出
# reload命令十分常用，如果在线上部署的时候想要更改配置文件，完成后直接使用reload就可以快速重新加载。
./nginx -s reload  重新加载配置文件
ps aux|grep nginx  查看nginx进程
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC136只出现一次的数字]]></title>
        <id>https://aruul.github.io/post/AyhAIG8Q_/</id>
        <link href="https://aruul.github.io/post/AyhAIG8Q_/">
        </link>
        <updated>2021-04-29T14:19:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>现在有一个整数类型的数组，数组中素只有一个元素只出现一次，其余的元素都出现两次。</p>
<p><strong>注意：</strong></p>
<p>你需要给出一个线性时间复杂度的算法，你能在不使用额外内存空间的情况下解决这个问题么？</p>
<p>示例1</p>
<h2 id="输入">输入</h2>
<p>[复制](javascript:void(0)😉</p>
<pre><code>[1,0,1]
</code></pre>
<h2 id="返回值">返回值</h2>
<p>[复制](javascript:void(0)😉</p>
<pre><code>0
</code></pre>
<hr>
<h4 id="本菜鸡的解题代码">本菜鸡的解题代码</h4>
<p>大概思路是暴力对比，暴力就完事了。</p>
<p>二重循环，先提前在外层循环设定一个初始标志，为0，</p>
<p>内存循环 ，如果找到相同的，则将标志设为1。</p>
<p>外层在根据标志判断是否找到相同的，否则返回出不同的值。</p>
<pre><code class="language-java">public class Solution {
    /**
     * 
     * @param A int整型一维数组 
     * @return int整型
     */
    public int singleNumber (int[] A) {
        // write code here
        for (int i = 0; i&lt;A.length ;i++) {
            int hasSame=0;
            for (int j = 0; j&lt;A.length; j++){
                if(i==j){
                    System.out.println(&quot;相同索引  A[&quot;+i+&quot;]=&quot;+A[i]+&quot; ,i=&quot;+i+&quot;, j=&quot;+j);
                    continue;
                }
                if(A[i]==A[j]){
                    hasSame=1;
                    break;
                }
            }
            if(hasSame==0){
                return A[i];
            }
        }
        return 0;
    }
}
</code></pre>
<hr>
<h3 id="大佬的代码">大佬的代码</h3>
<blockquote>
<p>链接：https://www.nowcoder.com/questionTerminal/0bc646909e474ac5b031ec6836a47768<br>
来源：牛客网</p>
</blockquote>
<p>根据异或运算特点：</p>
<p>两个相同的数进行异或，结果为0</p>
<pre><code class="language-java">	public static int singleNumber(int[] A) {
		int num = 0;
		for(int i=0;i&lt;A.length;i++){
			num^=A[i];
		}
		return num;
	}
</code></pre>
<p>其实只要记住：</p>
<p>​    1.异或满足交换律。</p>
<p>​    2.相同两个数异或为0。</p>
<p>​    3.0异或一个数为那个数本身。</p>
<p>最后结果即出现1次的那个数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阿里云https]]></title>
        <id>https://aruul.github.io/post/j3kVP0ZjV/</id>
        <link href="https://aruul.github.io/post/j3kVP0ZjV/">
        </link>
        <updated>2021-04-29T09:49:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1白嫖阿里云ssl证书">1.白嫖阿里云ssl证书</h3>
<ul>
<li><a href="https://common-buy.aliyun.com/?spm=5176.15089375.J_5834642020.3.360f65c3prTSPX&amp;commodityCode=cas_dv_public_cn&amp;request=%7B%22ord_time%22:%221:Year%22,%22order_num%22:1,%22product%22:%22cert_product%22,%22domain%22:%22all%22,%22productCode%22:%22symantec-dv-1-starter%22,%22service_num%22:2%7D">进入购买网址</a></li>
<li>选择如下图所示</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429170518.png" alt="image-20210429170510021" loading="lazy"></figure>
<ul>
<li>点击购买</li>
</ul>
<h3 id="2控制台证书申请">2.控制台证书申请</h3>
<p>毕竟是免费的，所以有点麻烦，买了之后还要去ssl控制台去申请，   <a href="https://yundun.console.aliyun.com/?p=cas#/certExtend">SSL控制台</a></p>
<ul>
<li>选择右侧的SSL证书------》再点击证书申请</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429171100.png" alt="image-20210429171051664" loading="lazy"></figure>
<ul>
<li>
<p>弹出如下界面，点击确认</p>
<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429171318.png" alt="image-20210429171314073" style="zoom: 67%;" />
</li>
<li>
<p>证书申请之后，点击【免费证书】</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429171555.png" alt="image-20210429171553744" loading="lazy"></figure>
<ul>
<li>
<p>再点击证书申请，再弹出的页面中填写个人信息即可，之后再点击验证，验证成功后就可以领证书了</p>
</li>
<li>
<p>之后再根据自己的情况下载对应的证书</p>
</li>
</ul>
<hr>
<h3 id="3nginx配置https">3.nginx配置https</h3>
<p>在阿里云在点击证书下载的时候会有相关的文档，我这里配置的是nginx</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429172922.png" alt="image-20210429172920399" loading="lazy"></figure>
<p>下载证书后将其上传的nginx的配置文件conf根目录中，可以建立一个cert文件夹，然后放入。</p>
<p>接着在配置文件中添加一个新的server</p>
<pre><code class="language-xml">#以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。
server {
         listen 443 ssl; #配置HTTPS的默认访问端口号为443。此处如果未配置HTTPS的默认访问端口，可能会造成Nginx无法启动。Nginx 1.15.0以上版本请使用listen 443 ssl代替listen 443和ssl on。
         server_name www.certificatestests.com; #将www.certificatestests.com修改为您证书绑定的域名，例如：www.example.com。如果您购买的是通配符域名证书，要修改为通配符域名，例如：*.aliyun.com。
         root html;
         index index.html index.htm;
         ssl_certificate cert/domain name.pem;  #将domain name.pem替换成您证书的文件名称。
         ssl_certificate_key cert/domain name.key; #将domain name.key替换成您证书的密钥文件名称。
         ssl_session_timeout 5m;
         ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。
         ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。
         ssl_prefer_server_ciphers on;
         location / {
         	root html;  #站点目录。
         	index index.html index.htm;
         }
}
</code></pre>
<p><mark>注意开启443端口哈</mark></p>
<h4 id="3-1-可能出现的错误">3. 1 可能出现的错误</h4>
<pre><code class="language-xml">the &quot;ssl&quot; parameter requires ngx_http_ssl_module
</code></pre>
<p>原因是在你装nginx的时候没有配置SSL模块</p>
<p><strong>说明：我的nginx安装目录为：/usr/local/nginx ， 源码包在/usr/src/nginx-1.8.0目录</strong></p>
<h4 id="nginx开启ssl模块">Nginx开启SSL模块：</h4>
<p>切换到源码包：<br>
<code>cd /usr/src/nginx-1.8.0</code></p>
<p>查看nginx原有的模块<br>
<code>/usr/local/nginx/sbin/nginx -V</code></p>
<p>在configure arguments:后面显示的原有的configure参数如下：<br>
<code>--prefix=/usr/local/nginx --with-http_stub_status_module</code></p>
<h4 id="二从新配置ssl模块">二：从新配置SSL模块：</h4>
<p>进入nginx源码包目录，运行：<br>
<code>./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</code></p>
<p>配置完成后，运行命令make命令：</p>
<h4 id="make">make</h4>
<p>注意：此处不能进行make install，否则就是覆盖安装</p>
<h4 id="三替换已安装好的nginx包">三：替换已安装好的nginx包</h4>
<p>替换之前先备份：<br>
<code>cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</code></p>
<h4 id="先停止nginx服务">先停止nginx服务：</h4>
<p>//查询nginx主进程号<br>
<code>$ ps -ef | grep nginx</code></p>
<p>//从容停止Nginx：<br>
<code>$kill -QUIT 主进程号</code></p>
<p>//快速停止Nginx：<br>
<code>kill -TERM 主进程号</code></p>
<p>//强制停止Nginx：<br>
<code>pkill -9 nginx</code><br>
将刚刚编译好的nginx覆盖掉原有的nginx</p>
<p><code>cp ./objs/nginx /usr/local/nginx/sbin/</code><br>
然后启动nginx，仍可以通过命令查看是否已经加入成功</p>
<pre><code>/usr/local/nginx/sbin/nginx -V
</code></pre>
<p>此时应该显示为即配置成功：<br>
<code>configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</code></p>
<hr>
<p>之后照常开启nginx即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新的开始]]></title>
        <id>https://aruul.github.io/post/newbegain/</id>
        <link href="https://aruul.github.io/post/newbegain/">
        </link>
        <updated>2021-04-11T01:41:56.000Z</updated>
        <content type="html"><![CDATA[<p>今天开始使用Gridea写博客辣！<br>
之前的博客会陆续补上来的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSM整合]]></title>
        <id>https://aruul.github.io/post/0PVi5Fwu4/</id>
        <link href="https://aruul.github.io/post/0PVi5Fwu4/">
        </link>
        <updated>2021-03-25T04:49:19.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#0%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96">0.导入依赖</a></li>
<li><a href="#1%E6%95%B4%E5%90%88mybatis">1.整合mybatis</a>
<ul>
<li><a href="#11%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">1.1建数据库</a></li>
<li><a href="#12%E7%BC%96%E5%86%99%E5%AF%B9%E5%BA%94%E7%9A%84pojo%E5%B1%82">1.2编写对应的pojo层</a></li>
<li><a href="#13%E7%BC%96%E5%86%99%E5%AF%B9%E5%BA%94%E7%9A%84dao%E5%B1%82">1.3编写对应的dao层</a></li>
<li><a href="#14%E7%BC%96%E5%86%99mybatis-configxml">1.4编写mybatis-config.xml</a></li>
<li><a href="#15%E7%BC%96%E5%86%99mybatis-configxml">1.5编写mybatis-config.xml</a></li>
</ul>
</li>
<li><a href="#2%E6%95%B4%E5%90%88service%E5%B1%82">2.整合service层</a>
<ul>
<li><a href="#21%E7%BC%96%E5%86%99service%E5%B1%82java%E4%BB%A3%E7%A0%81">2.1编写service层java代码</a></li>
<li><a href="#22%E7%BC%96%E5%86%99service%E5%B1%82%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6spring-servicexml">2.2编写service层配置文件spring-service.xml</a></li>
</ul>
</li>
<li><a href="#3%E6%95%B4%E5%90%88springmvc%E5%B1%82">3.整合SpringMVC层</a>
<ul>
<li><a href="#31%E7%BC%96%E5%86%99spring-mvcxml">3.1编写spring-mvc.xml</a></li>
<li><a href="#32%E7%BC%96%E5%86%99applicationcontextxml">3.2编写applicationContext.xml</a></li>
<li><a href="#33%E7%BC%96%E5%86%99webxml%E6%96%87%E4%BB%B6">3.3编写web.xml文件</a></li>
<li><a href="#34%E7%BC%96%E5%86%99controller%E5%B1%82">3.4编写controller层</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="0导入依赖">0.导入依赖</h3>
<pre><code class="language-xml"> &lt;!--依赖  junit 数据库驱动 连接池  servlet jsp mybatis mybatis-spring spring --&gt;
    &lt;dependencies&gt;
        &lt;!--Junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--数据库驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.22&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 数据库连接池 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mchange&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;0.9.5.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Servlet - JSP --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.4&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Spring--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;!--静态资源导出问题--&gt;
    &lt;build&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;false&lt;/filtering&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;false&lt;/filtering&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
</code></pre>
<h3 id="1整合mybatis">1.整合mybatis</h3>
<h4 id="11建数据库">1.1建数据库</h4>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210325091806.png" alt="image-20210325091806560" loading="lazy"></figure>
<h4 id="12编写对应的pojo层">1.2编写对应的pojo层</h4>
<pre><code class="language-java">public class Books {
    private int bookID;
    private String bookName;
    private int bookCounts;
    private String detail;

    public Books() {
    }

    public Books(int bookID, String bookName, int bookCounts, String detail) {
        this.bookID = bookID;
        this.bookName = bookName;
        this.bookCounts = bookCounts;
        this.detail = detail;
    }

    public int getBookID() {
        return bookID;
    }

    public void setBookID(int bookID) {
        this.bookID = bookID;
    }

    public String getBookName() {
        return bookName;
    }

    public void setBookName(String bookName) {
        this.bookName = bookName;
    }

    public int getBookCounts() {
        return bookCounts;
    }

    public void setBookCounts(int bookCounts) {
        this.bookCounts = bookCounts;
    }

    public String getDetail() {
        return detail;
    }

    public void setDetail(String detail) {
        this.detail = detail;
    }

    @Override
    public String toString() {
        return &quot;Books{&quot; +
                &quot;bookID=&quot; + bookID +
                &quot;, bookName='&quot; + bookName + '\'' +
                &quot;, bookCounts=&quot; + bookCounts +
                &quot;, detail='&quot; + detail + '\'' +
                '}';
    }
}
</code></pre>
<h4 id="13编写对应的dao层">1.3编写对应的dao层</h4>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="language-java">public interface BookMapper {

    //增
    int addBook(Books books);
    // 删
    int deleteBookById(@Param(&quot;bookID&quot;) int id);
    // 改
    int updateBook(Books books);
    // 查
    Books queryBookBuId(@Param(&quot;bookID&quot;) int id);
    //查全部的书
    List&lt;Books&gt; queryAllBook();

}
</code></pre>
<ul>
<li>UserMapper.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;!--namespace 是要绑定的类的路径--&gt;
&lt;mapper namespace=&quot;org.example.dao.BookMapper&quot;&gt;

    &lt;insert id=&quot;addBook&quot; parameterType=&quot;books&quot;&gt;
        insert into ssmbuild.books (bookID, bookName, bookCounts, detail)
        values (#{bookID},#{bookName},#{bookCounts},#{detail})
    &lt;/insert&gt;

    &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt;
        delete from ssmbuild.books where bookID = #{bookID}
    &lt;/delete&gt;

    &lt;update id=&quot;updateBook&quot; parameterType=&quot;books&quot;&gt;
        update ssmbuild.books set bookName=#{bookName},bookCounts=#{bookCounts}，detail=#{detail}
        where bookID=#{bookID}
    &lt;/update&gt;

    &lt;select id=&quot;queryBookBuId&quot; parameterType=&quot;int&quot; resultType=&quot;books&quot;&gt;
        select * from ssmbuild.books where bookID=#{bookID}
    &lt;/select&gt;

    &lt;select id=&quot;queryAllBook&quot; resultType=&quot;books&quot;&gt;
        select * from ssmbuild.books
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<h4 id="14编写mybatis-configxml">1.4编写mybatis-config.xml</h4>
<p><mark>这里的话mybatis-config.xml中不用写数据库连接池，而是统一交由spring来处理</mark></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;!--设置日志--&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;/settings&gt;
    &lt;!--别名--&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;org.example.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;!--mapper映射  扫描dao包--&gt;
    &lt;mappers&gt;
        &lt;package name=&quot;org.example.dao&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h4 id="15编写mybatis-configxml">1.5编写mybatis-config.xml</h4>
<p><mark>也就是将dao层整合到spring中</mark></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--关联数据库 c3p0连接池 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot;
                  value=&quot;jdbc:mysql://localhost:3306/ssmbuild?serverTimezone=Asia/Shanghai&amp;amp;useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;

        &lt;!-- c3p0连接池的私有属性 --&gt;
        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;
        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;
        &lt;!-- 关闭连接后不自动commit --&gt;
        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;
        &lt;!-- 获取连接超时时间 --&gt;
        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;
        &lt;!-- 当获取连接失败重试次数 --&gt;
        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--SqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!-- 绑定mybatis全局配置文件:mybatis-config.xml --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置dao接口扫描包，动态的实现了Dao接口可以注册到Spring容器--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!--注入sqlSessionFactory--&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
        &lt;!--扫描要扫描的包--&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;org.example.dao&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<hr>
<h3 id="2整合service层">2.整合service层</h3>
<h4 id="21编写service层java代码">2.1编写service层java代码</h4>
<pre><code class="language-java">package org.example.service;

import org.apache.ibatis.annotations.Param;
import org.example.pojo.Books;

import java.util.List;

/**
 * @author aRu
 * @date 2021/3/24 21:29
 */
public interface BookService {
    //增
    int addBook(Books books);
    // 删
    int deleteBookById(@Param(&quot;bookID&quot;) int id);
    // 改
    int updateBook(Books books);
    // 查
    Books queryBookBuId(@Param(&quot;bookID&quot;) int id);
    //查全部的书
    List&lt;Books&gt; queryAllBook();
}
</code></pre>
<pre><code class="language-java">package org.example.service;

import org.example.dao.BookMapper;
import org.example.pojo.Books;

import java.util.List;

/**
 * @author aRu
 * @date 2021/3/24 21:30
 */
public class BookServiceImp implements BookService{
    //service调用dao层   组合dao
    private BookMapper bookMapper;

    public void setBookMapper(BookMapper bookMapper) {
        this.bookMapper = bookMapper;
    }

    @Override
    public int addBook(Books books) {
        return bookMapper.addBook(books);
    }

    @Override
    public int deleteBookById(int id) {
        return bookMapper.deleteBookById(id);
    }

    @Override
    public int updateBook(Books books) {
        return bookMapper.updateBook(books);
    }

    @Override
    public Books queryBookBuId(int id) {
        return bookMapper.queryBookBuId(id);
    }

    @Override
    public List&lt;Books&gt; queryAllBook() {
        return bookMapper.queryAllBook();
    }
}
</code></pre>
<h4 id="22编写service层配置文件spring-servicexml">2.2编写service层配置文件spring-service.xml</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--扫描service下的包--&gt;
    &lt;context:component-scan base-package=&quot;org.example.service&quot; /&gt;

    &lt;!--ServiceImpl注入到IOC容器中--&gt;
    &lt;bean id=&quot;BookServiceImp&quot; class=&quot;org.example.service.BookServiceImp&quot;&gt;
        &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 配置事务管理器 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!-- 注入数据库连接池 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<hr>
<h3 id="3整合springmvc层">3.整合SpringMVC层</h3>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210325093214.png" alt="image-20210325093214157" loading="lazy"></figure>
<p>添加 Framework Support</p>
<h4 id="31编写spring-mvcxml">3.1编写spring-mvc.xml</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 1.开启SpringMVC注解驱动 --&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!-- 2.静态资源默认servlet配置--&gt;
    &lt;mvc:default-servlet-handler/&gt;

    &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 4.扫描web相关的bean --&gt;
    &lt;context:component-scan base-package=&quot;org.example.controller&quot; /&gt;

&lt;/beans&gt;
</code></pre>
<p><mark>记得在WEB-INF在新建jsp的文件</mark></p>
<h4 id="32编写applicationcontextxml">3.2编写applicationContext.xml</h4>
<p>将之前的<strong>spring-dao.xml  spring-service.xml spring-mvc.xml</strong>引入<strong>applicationContext.xml</strong>中</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<h4 id="33编写webxml文件">3.3编写web.xml文件</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--DispatcherServlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;!--一定要注意:这里加载的是总的配置文件，之前被这里坑了！--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;!--encodingFilter--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;
            org.springframework.web.filter.CharacterEncodingFilter
        &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!--Session过期时间--&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;

&lt;/web-app&gt;
</code></pre>
<h4 id="34编写controller层">3.4编写controller层</h4>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/book&quot;)
public class BookController {
    //controller层 调用service层
    @Autowired
    @Qualifier(&quot;BookServiceImp&quot;)
    private BookService bookService;

    //查询全部书籍，并返回给展示页
    @RequestMapping(&quot;/allBook&quot;)
    public String list(Model model){
        List&lt;Books&gt; books=bookService.queryAllBook();
        model.addAttribute(&quot;list&quot;,books);

        return &quot;allBook&quot;;
    }
    
}
</code></pre>
]]></content>
    </entry>
</feed>