<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aruul.github.io</id>
    <title>aRuul的无名小站</title>
    <updated>2021-05-04T09:07:54.106Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aruul.github.io"/>
    <link rel="self" href="https://aruul.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aruul.github.io/images/avatar.png</logo>
    <icon>https://aruul.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, aRuul的无名小站</rights>
    <entry>
        <title type="html"><![CDATA[java反射(2)  反射调用的性能和优化方案]]></title>
        <id>https://aruul.github.io/post/L4U-TAPK3/</id>
        <link href="https://aruul.github.io/post/L4U-TAPK3/">
        </link>
        <updated>2021-05-04T08:51:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="反射调用的性能和优化方案">反射调用的性能和优化方案</h2>
<h3 id="对比">对比</h3>
<p>普通方法</p>
<pre><code class="language-java">    //普通方法
    public static void m1(){
        Cat cat = new Cat();

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            cat.say();
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;普通方法执行时间：&quot;+(end-start));
    }
</code></pre>
<p>通过反射</p>
<pre><code class="language-java">//反射
    public static void m2() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class aClass = Class.forName(&quot;org.example.Cat&quot;);
        Object o = aClass.newInstance();
        Method say = aClass.getMethod(&quot;say&quot;);

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            say.invoke(o);
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;反射机制执行时间：&quot;+(end-start));


    }
</code></pre>
<p>两者运行时间对比</p>
<pre><code>普通方法执行时间：3 ms
反射机制执行时间：175 ms
</code></pre>
<h3 id="优化">优化</h3>
<blockquote>
<p>反射调用优化-关闭访问检查</p>
<ol>
<li>Method和 Field、 Constructor象都有 setAccessible()方法</li>
<li>setAccessible()作用是启动和禁用访问安全检查的开关<br>
3.参数值为true表示反射的对象在使用时取消访向检查，提高反射的效率。<br>
参数值为 false则表示反射的对象执行访向检查</li>
</ol>
</blockquote>
<p>所以可以通过setAccessible()来优化反射。</p>
<p>其实呢，优化之后效率也没有高出很多。</p>
<pre><code class="language-java">    //反射优化
    public static void m3() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class aClass = Class.forName(&quot;org.example.Cat&quot;);
        Object o = aClass.newInstance();
        Method say = aClass.getMethod(&quot;say&quot;);

        //取消在反射调用方法时 取消访问检测
        say.setAccessible(true);


        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            say.invoke(o);
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;反射优化机制执行时间：&quot;+(end-start));

    }
</code></pre>
<hr>
<p>执行结果对比</p>
<pre><code>普通方法执行时间：3 ms
反射机制执行时间：176 ms
反射优化机制执行时间：129 ms
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java 反射(1)--快速开始]]></title>
        <id>https://aruul.github.io/post/s8pJIRpaT/</id>
        <link href="https://aruul.github.io/post/s8pJIRpaT/">
        </link>
        <updated>2021-05-03T13:18:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="快速开始">快速开始</h3>
<h4 id="1什么是反射">1.什么是反射？</h4>
<p>如果你研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。</p>
<p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<p><strong>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</strong></p>
<h4 id="2反射机制优缺点">2.反射机制优缺点</h4>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li>
</ul>
<h4 id="3由一个例子引出反射">3.由一个例子引出反射</h4>
<h5 id="31需求">3.1需求</h5>
<blockquote>
<p>根据配置文件re. properties指定信息，创建Cat过象并调用方法say</p>
</blockquote>
<p>re. properties文件</p>
<pre><code class="language-properties">classfullpath=org.example.Cat
method=say
</code></pre>
<p>Cat</p>
<pre><code class="language-java">package org.example;

/**
 * @author aRu
 * @date 2021/5/3 10:01
 */
public class Cat {
    private String name = &quot;招财猫&quot;;
    public int age= 3;

    public Cat() {
    }

    public Cat(String name) {
        this.name = name;
    }

    public void say(){
        System.out.println(&quot;miao~ i am &quot;+name);
    }
}
</code></pre>
<p>工程目录如下，本次代码写在org.example.quickStart_01下</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210503213409.png" alt="image-20210503213403742" loading="lazy"></figure>
<h5 id="32实现">3.2实现</h5>
<pre><code class="language-java">package org.example.quickStart_01;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

/**问题的引入
 * @author aRu
 * @date 2021/5/3 10:04
 */
public class ReflectionQuickStart {
    public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        //根据配置文件 创建Cat对象并调用 配置文件中指定的方法

        //1.读取配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\org\\example\\re.properties&quot;));
        String classfullpath = properties.get(&quot;classfullpath&quot;).toString();
        String method = properties.get(&quot;method&quot;).toString();
        System.out.println(&quot;类的全路径： &quot;+classfullpath);
        System.out.println(&quot;方法名： &quot;+method);

        //2.使用反射机制
        Class cls = Class.forName(classfullpath);
        //通过 cls 得到你加载的类 Cat的对象实例
        Object o = cls.newInstance();
        System.out.println(&quot;o的类型： &quot;+o.getClass());
        //通过cls 得到你加载的类Cat的 method 方法
        Method method1 = cls.getMethod(method);
        //通过method1 调用方法： 即，通过方法对象 来实现调用方法
        method1.invoke(o);
        

    }
}

</code></pre>
<hr>
<p>运行结果</p>
<pre><code>类的全路径： org.example.Cat
方法名： say
o的类型： class org.example.Cat
miao~ i am 招财猫
</code></pre>
<p>补充</p>
<pre><code class="language-java">        //得到类的成员变量
        //注意： cls.getField(&quot;name&quot;)不能得到私有的属性
        Field nameField = cls.getField(&quot;age&quot;);
        System.out.println(nameField.get(o));

        //得到对象的构造函数
        Constructor constructor = cls.getConstructor();//()中可以指定构造参数类型，这里没写，则返回无参构造
        System.out.println(&quot;无参构造：&quot;+constructor);

        Constructor constructor2 = cls.getConstructor(String.class);
        System.out.println(&quot;有参构造：&quot;+constructor2);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java注解浅谈]]></title>
        <id>https://aruul.github.io/post/3NqPQbqyz/</id>
        <link href="https://aruul.github.io/post/3NqPQbqyz/">
        </link>
        <updated>2021-05-03T13:13:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="注解">注解</h3>
<hr>
<h4 id="内置注解">内置注解</h4>
<ul>
<li>
<p>@Override</p>
<p>表示一个方法声名打算重写超类中的另一个方法声明。</p>
</li>
<li>
<p>@Deprecated</p>
<p>表示不鼓励程序员使用这样的元素</p>
</li>
<li>
<p>@SuppressWarnings()</p>
<p>抑制编译时的警告信息</p>
<p>如@SuppressWarnings(&quot;all&quot;)等</p>
<hr>
<h4 id="元注解">元注解</h4>
<p>除了直接使用JDK 定义好的注解，我们还可以自定义注解，在JDK 1.5中提供了4个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：</p>
</li>
<li>
<p>@Target</p>
<p>Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方</p>
</li>
<li>
<p>@Retention</p>
<p>Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）</p>
<p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。</p>
<p><mark>RUNTIME一般较常用</mark></p>
<pre><code>SOURCE,    // 源文件保留
CLASS,       // 编译期保留，默认值
RUNTIME   // 运行期保留，可通过反射去获取注解信息
</code></pre>
</li>
<li>
<p>@Documented</p>
<p>表示是否将注解生成在JavaDoc中</p>
</li>
<li>
<p>@Inherited</p>
<p>子类可以继承父类的注解</p>
</li>
</ul>
<p>我们可以使用这4个元注解来对我们自定义的注解类型进行注解</p>
<hr>
<h4 id="自定义注解">自定义注解</h4>
<p>使用@interface</p>
<pre><code class="language-JAVA">//定义一个注解
@Target(value = {ElementType.METHOD,ElementType.TYPE})  //表示注解可以用在方法、类上
@Retention(value = RetentionPolicy.RUNTIME)             //表示注解在什么时候有效RUNTIME&gt;class&gt;sources
@Documented                                             //表示是否将注解生成在JavaDoc中
@Inherited                                              //子类可以继承父类的注解
public @interface MyAnnotation{

}
</code></pre>
<pre><code class="language-java">//定义一个注解
@Target(value = {ElementType.METHOD,ElementType.TYPE})  //表示注解可以用在方法、类上
@Retention(value = RetentionPolicy.RUNTIME)             //表示注解在什么时候有效RUNTIME&gt;class&gt;sources
@Documented                                             //表示是否将注解生成在JavaDoc中
@Inherited                                              //子类可以继承父类的注解
public @interface MyAnnotation{
    //注解的参数： 参数类型+参数名()
    String name() default &quot;&quot;;  //default 表示默认值  这里是默认值为空
    int age() default 0;
    int id() default -1;    //默认值为-1，代表不存在

    String [] schools();
}


@Target(value = {ElementType.METHOD,ElementType.TYPE})  //表示注解可以用在方法、类上
@Retention(value = RetentionPolicy.RUNTIME)             //表示注解在什么时候有效RUNTIME&gt;class&gt;sources
public @interface MyAnnotation2{
    String value();  //如果注解中只有一个参数，则建议定义为value，这样在使用的时候直接写  @MyAnnotation2(&quot;赋值&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ubuntu ngnix的安装和配置]]></title>
        <id>https://aruul.github.io/post/xeGoYob77/</id>
        <link href="https://aruul.github.io/post/xeGoYob77/">
        </link>
        <updated>2021-04-30T01:24:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1>
<h2 id="什么是-nginx">什么是 Nginx</h2>
<p>一个项目或平台，用户使用量少，并发量小的情况下，一台 Tomcat 服务器就可以满足需求。但当平台用户量增多，并发量增大时，一台 Tomcat 服务器就不能够很好地支撑。于是就需要做横向扩展，多增加几台服务器，并设置一个代理服务器。用户如果要访问平台首先会经过代理服务器，代理服务器实现处理用户的请求和转发到真实服务器，也就是反向代理。在做横向扩展后，每台服务器的大小、性能可能各不相同。代理服务器需要根据用户的请求，服务器的状态等实际情况实现选择和转发，也就是负载均衡。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudybda5ac84-227d-47b9-8711-d19567828c6d.png" alt="img" loading="lazy"><br>
Nginx（ engine x ）是一个高性能的 HTTP 和反向代理 web 服务器。<br>
Nginx 特点是占用内存少，并发能力强。1M 左右的内存支持高达 50000 个并发连接数的响应，而 Tomcat 只支持 500~600 个响应。<br>
Nginx 安装简单，配置文件简洁，启动容易且能持续运行。<br>
Nginx 的作用简单来说就是反向代理和负载均衡。</p>
<h2 id="正向代理和反向代理">正向代理和反向代理</h2>
<p>正向代理基于客户端，代理客户端，是一种主动地行为。比如使用 VPN 访问外网，用户需要手动选择香港、日本或美国的节点，通过节点转发到外网服务器，这些节点代理了外网的服务器。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy872b3db7-d641-4ef7-9811-73a748fd1c27.png" alt="img" loading="lazy"><br>
反向代理基于服务端，代理服务端，是一种被动地行为。比如访问百度，百度的服务器可能不在同一个地方，但是用户可以通过访问百度的域名 www.baidu.com，由代理服务器实现转发，这个过程用户是无感知的。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyeacfb3ba-66bf-467e-b414-33bd466b046c.png" alt="img" loading="lazy"></p>
<h2 id="负载均衡">负载均衡</h2>
<p>Nginx 提供的负载均衡策略有 2 种：内置策略和扩展策略。内置策略分为轮询，加权轮询，Ip hash。扩展策略由程序员自行创造。<br>
轮询<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy33a6e959-9de6-4361-9452-63add93d36db.png" alt="img" loading="lazy"><br>
加权轮询<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyce51f657-9c95-44eb-a473-46b12f3e173c.png" alt="img" loading="lazy"><br>
Ip hash<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy8406dd2c-6596-4292-8890-3423e095f28f.png" alt="img" loading="lazy"><br>
动静分离<br>
一个项目中，有些请求需要后台处理，而有些请求不需要后台处理，如 HTML、CSS、JavaScript 等文件，这些文件统称为静态资源。在开发中将不经常变动地资源与经常变动地资源分离，将这些静态资源缓存到本地 Nginx 中，由 Nginx 直接返回，可以大大提高资源响应的速度和网页的健壮性。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy4ffdae63-5189-4289-b465-94b1be9e731d.png" alt="img" loading="lazy"></p>
<hr>
<h1 id="nginx-安装">Nginx 安装</h1>
<p>1、下载 nginx。<br>
下载 Linux 安装包，使用<code>tar -zxvf</code>命令解压到对应的目录即可。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy2700bc18-8194-43ba-aa31-6fbb78906ed1.png" alt="img" loading="lazy"><br>
2、安装 nginx 所需依赖。</p>
<pre><code>yum install gcc-c++
yum install -y pcre pcre-devel
yum install -y openssl openssl-devel
</code></pre>
<p>3、进入 nginx 目录，执行以下两个命令。</p>
<pre><code>./configuremake install
</code></pre>
<p>4、查找 nginx 安装路径并进入。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyf7a7e81f-7e8c-49af-a17a-b2a5794fb73c.png" alt="img" loading="lazy"><br>
5、启动 nginx。</p>
<pre><code>./nginx
</code></pre>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudycedd22d3-3f9a-4672-8262-403135731260.png" alt="img" loading="lazy"><br>
6、查看 nginx 配置文件.<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyda8d055d-e44a-45f3-937e-6c9eefc4877a.png" alt="img" loading="lazy"><br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy47e6db4a-df2b-43a9-a501-47e1e2fbc1df.png" alt="img" loading="lazy"><br>
7、检查 nginx 是否启动成功。<br>
访问 服务器 ip:80，如果出现以下画面则说明 nginx 启动成功。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy5d020ccc-718c-4774-a07b-70168482f697.png" alt="img" loading="lazy"><br>
如果访问失败，检查服务器防火墙和阿里云安全组的端口是否开启。</p>
<hr>
<h1 id="nginx-常用命令">Nginx 常用命令</h1>
<pre><code class="language-java">cd /usr/local/nginx/sbin/
./nginx  启动
./nginx -s stop  停止
./nginx -s quit  安全退出
# reload命令十分常用，如果在线上部署的时候想要更改配置文件，完成后直接使用reload就可以快速重新加载。
./nginx -s reload  重新加载配置文件
ps aux|grep nginx  查看nginx进程
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC15出现一次的数字]]></title>
        <id>https://aruul.github.io/post/AyhAIG8Q_/</id>
        <link href="https://aruul.github.io/post/AyhAIG8Q_/">
        </link>
        <updated>2021-04-29T14:19:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>现在有一个整数类型的数组，数组中素只有一个元素只出现一次，其余的元素都出现两次。</p>
<p><strong>注意：</strong></p>
<p>你需要给出一个线性时间复杂度的算法，你能在不使用额外内存空间的情况下解决这个问题么？</p>
<p>示例1</p>
<h2 id="输入">输入</h2>
<p>[复制](javascript:void(0)😉</p>
<pre><code>[1,0,1]
</code></pre>
<h2 id="返回值">返回值</h2>
<p>[复制](javascript:void(0)😉</p>
<pre><code>0
</code></pre>
<hr>
<h4 id="本菜鸡的解题代码">本菜鸡的解题代码</h4>
<p>大概思路是暴力对比，暴力就完事了。</p>
<p>二重循环，先提前在外层循环设定一个初始标志，为0，</p>
<p>内存循环 ，如果找到相同的，则将标志设为1。</p>
<p>外层在根据标志判断是否找到相同的，否则返回出不同的值。</p>
<pre><code class="language-java">public class Solution {
    /**
     * 
     * @param A int整型一维数组 
     * @return int整型
     */
    public int singleNumber (int[] A) {
        // write code here
        for (int i = 0; i&lt;A.length ;i++) {
            int hasSame=0;
            for (int j = 0; j&lt;A.length; j++){
                if(i==j){
                    System.out.println(&quot;相同索引  A[&quot;+i+&quot;]=&quot;+A[i]+&quot; ,i=&quot;+i+&quot;, j=&quot;+j);
                    continue;
                }
                if(A[i]==A[j]){
                    hasSame=1;
                    break;
                }
            }
            if(hasSame==0){
                return A[i];
            }
        }
        return 0;
    }
}
</code></pre>
<hr>
<h3 id="大佬的代码">大佬的代码</h3>
<blockquote>
<p>链接：https://www.nowcoder.com/questionTerminal/0bc646909e474ac5b031ec6836a47768<br>
来源：牛客网</p>
</blockquote>
<p>根据异或运算特点：</p>
<p>两个相同的数进行异或，结果为0</p>
<pre><code class="language-java">	public static int singleNumber(int[] A) {
		int num = 0;
		for(int i=0;i&lt;A.length;i++){
			num^=A[i];
		}
		return num;
	}
</code></pre>
<p>其实只要记住：</p>
<p>​    1.异或满足交换律。</p>
<p>​    2.相同两个数异或为0。</p>
<p>​    3.0异或一个数为那个数本身。</p>
<p>最后结果即出现1次的那个数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阿里云https]]></title>
        <id>https://aruul.github.io/post/j3kVP0ZjV/</id>
        <link href="https://aruul.github.io/post/j3kVP0ZjV/">
        </link>
        <updated>2021-04-29T09:49:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1白嫖阿里云ssl证书">1.白嫖阿里云ssl证书</h3>
<ul>
<li><a href="https://common-buy.aliyun.com/?spm=5176.15089375.J_5834642020.3.360f65c3prTSPX&amp;commodityCode=cas_dv_public_cn&amp;request=%7B%22ord_time%22:%221:Year%22,%22order_num%22:1,%22product%22:%22cert_product%22,%22domain%22:%22all%22,%22productCode%22:%22symantec-dv-1-starter%22,%22service_num%22:2%7D">进入购买网址</a></li>
<li>选择如下图所示</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429170518.png" alt="image-20210429170510021" loading="lazy"></figure>
<ul>
<li>点击购买</li>
</ul>
<h3 id="2控制台证书申请">2.控制台证书申请</h3>
<p>毕竟是免费的，所以有点麻烦，买了之后还要去ssl控制台去申请，   <a href="https://yundun.console.aliyun.com/?p=cas#/certExtend">SSL控制台</a></p>
<ul>
<li>选择右侧的SSL证书------》再点击证书申请</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429171100.png" alt="image-20210429171051664" loading="lazy"></figure>
<ul>
<li>
<p>弹出如下界面，点击确认</p>
<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429171318.png" alt="image-20210429171314073" style="zoom: 67%;" />
</li>
<li>
<p>证书申请之后，点击【免费证书】</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429171555.png" alt="image-20210429171553744" loading="lazy"></figure>
<ul>
<li>
<p>再点击证书申请，再弹出的页面中填写个人信息即可，之后再点击验证，验证成功后就可以领证书了</p>
</li>
<li>
<p>之后再根据自己的情况下载对应的证书</p>
</li>
</ul>
<hr>
<h3 id="3nginx配置https">3.nginx配置https</h3>
<p>在阿里云在点击证书下载的时候会有相关的文档，我这里配置的是nginx</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429172922.png" alt="image-20210429172920399" loading="lazy"></figure>
<p>下载证书后将其上传的nginx的配置文件conf根目录中，可以建立一个cert文件夹，然后放入。</p>
<p>接着在配置文件中添加一个新的server</p>
<pre><code class="language-xml">#以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。
server {
         listen 443 ssl; #配置HTTPS的默认访问端口号为443。此处如果未配置HTTPS的默认访问端口，可能会造成Nginx无法启动。Nginx 1.15.0以上版本请使用listen 443 ssl代替listen 443和ssl on。
         server_name www.certificatestests.com; #将www.certificatestests.com修改为您证书绑定的域名，例如：www.example.com。如果您购买的是通配符域名证书，要修改为通配符域名，例如：*.aliyun.com。
         root html;
         index index.html index.htm;
         ssl_certificate cert/domain name.pem;  #将domain name.pem替换成您证书的文件名称。
         ssl_certificate_key cert/domain name.key; #将domain name.key替换成您证书的密钥文件名称。
         ssl_session_timeout 5m;
         ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。
         ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。
         ssl_prefer_server_ciphers on;
         location / {
         	root html;  #站点目录。
         	index index.html index.htm;
         }
}
</code></pre>
<p><mark>注意开启443端口哈</mark></p>
<h4 id="3-1-可能出现的错误">3. 1 可能出现的错误</h4>
<pre><code class="language-xml">the &quot;ssl&quot; parameter requires ngx_http_ssl_module
</code></pre>
<p>原因是在你装nginx的时候没有配置SSL模块</p>
<p><strong>说明：我的nginx安装目录为：/usr/local/nginx ， 源码包在/usr/src/nginx-1.8.0目录</strong></p>
<h4 id="nginx开启ssl模块">Nginx开启SSL模块：</h4>
<p>切换到源码包：<br>
<code>cd /usr/src/nginx-1.8.0</code></p>
<p>查看nginx原有的模块<br>
<code>/usr/local/nginx/sbin/nginx -V</code></p>
<p>在configure arguments:后面显示的原有的configure参数如下：<br>
<code>--prefix=/usr/local/nginx --with-http_stub_status_module</code></p>
<h4 id="二从新配置ssl模块">二：从新配置SSL模块：</h4>
<p>进入nginx源码包目录，运行：<br>
<code>./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</code></p>
<p>配置完成后，运行命令make命令：</p>
<h4 id="make">make</h4>
<p>注意：此处不能进行make install，否则就是覆盖安装</p>
<h4 id="三替换已安装好的nginx包">三：替换已安装好的nginx包</h4>
<p>替换之前先备份：<br>
<code>cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</code></p>
<h4 id="先停止nginx服务">先停止nginx服务：</h4>
<p>//查询nginx主进程号<br>
<code>$ ps -ef | grep nginx</code></p>
<p>//从容停止Nginx：<br>
<code>$kill -QUIT 主进程号</code></p>
<p>//快速停止Nginx：<br>
<code>kill -TERM 主进程号</code></p>
<p>//强制停止Nginx：<br>
<code>pkill -9 nginx</code><br>
将刚刚编译好的nginx覆盖掉原有的nginx</p>
<p><code>cp ./objs/nginx /usr/local/nginx/sbin/</code><br>
然后启动nginx，仍可以通过命令查看是否已经加入成功</p>
<pre><code>/usr/local/nginx/sbin/nginx -V
</code></pre>
<p>此时应该显示为即配置成功：<br>
<code>configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</code></p>
<hr>
<p>之后照常开启nginx即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新的开始]]></title>
        <id>https://aruul.github.io/post/newbegain/</id>
        <link href="https://aruul.github.io/post/newbegain/">
        </link>
        <updated>2021-04-11T01:41:56.000Z</updated>
        <content type="html"><![CDATA[<p>今天开始使用Gridea写博客辣！<br>
之前的博客会陆续补上来的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSM整合]]></title>
        <id>https://aruul.github.io/post/0PVi5Fwu4/</id>
        <link href="https://aruul.github.io/post/0PVi5Fwu4/">
        </link>
        <updated>2021-03-25T04:49:19.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#0%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96">0.导入依赖</a></li>
<li><a href="#1%E6%95%B4%E5%90%88mybatis">1.整合mybatis</a>
<ul>
<li><a href="#11%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">1.1建数据库</a></li>
<li><a href="#12%E7%BC%96%E5%86%99%E5%AF%B9%E5%BA%94%E7%9A%84pojo%E5%B1%82">1.2编写对应的pojo层</a></li>
<li><a href="#13%E7%BC%96%E5%86%99%E5%AF%B9%E5%BA%94%E7%9A%84dao%E5%B1%82">1.3编写对应的dao层</a></li>
<li><a href="#14%E7%BC%96%E5%86%99mybatis-configxml">1.4编写mybatis-config.xml</a></li>
<li><a href="#15%E7%BC%96%E5%86%99mybatis-configxml">1.5编写mybatis-config.xml</a></li>
</ul>
</li>
<li><a href="#2%E6%95%B4%E5%90%88service%E5%B1%82">2.整合service层</a>
<ul>
<li><a href="#21%E7%BC%96%E5%86%99service%E5%B1%82java%E4%BB%A3%E7%A0%81">2.1编写service层java代码</a></li>
<li><a href="#22%E7%BC%96%E5%86%99service%E5%B1%82%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6spring-servicexml">2.2编写service层配置文件spring-service.xml</a></li>
</ul>
</li>
<li><a href="#3%E6%95%B4%E5%90%88springmvc%E5%B1%82">3.整合SpringMVC层</a>
<ul>
<li><a href="#31%E7%BC%96%E5%86%99spring-mvcxml">3.1编写spring-mvc.xml</a></li>
<li><a href="#32%E7%BC%96%E5%86%99applicationcontextxml">3.2编写applicationContext.xml</a></li>
<li><a href="#33%E7%BC%96%E5%86%99webxml%E6%96%87%E4%BB%B6">3.3编写web.xml文件</a></li>
<li><a href="#34%E7%BC%96%E5%86%99controller%E5%B1%82">3.4编写controller层</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h3 id="0导入依赖">0.导入依赖</h3>
<pre><code class="language-xml"> &lt;!--依赖  junit 数据库驱动 连接池  servlet jsp mybatis mybatis-spring spring --&gt;
    &lt;dependencies&gt;
        &lt;!--Junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--数据库驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.22&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 数据库连接池 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mchange&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;0.9.5.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Servlet - JSP --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
            &lt;version&gt;2.5&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.4&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Spring--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;!--静态资源导出问题--&gt;
    &lt;build&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;false&lt;/filtering&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;false&lt;/filtering&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
</code></pre>
<h3 id="1整合mybatis">1.整合mybatis</h3>
<h4 id="11建数据库">1.1建数据库</h4>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210325091806.png" alt="image-20210325091806560" loading="lazy"></figure>
<h4 id="12编写对应的pojo层">1.2编写对应的pojo层</h4>
<pre><code class="language-java">public class Books {
    private int bookID;
    private String bookName;
    private int bookCounts;
    private String detail;

    public Books() {
    }

    public Books(int bookID, String bookName, int bookCounts, String detail) {
        this.bookID = bookID;
        this.bookName = bookName;
        this.bookCounts = bookCounts;
        this.detail = detail;
    }

    public int getBookID() {
        return bookID;
    }

    public void setBookID(int bookID) {
        this.bookID = bookID;
    }

    public String getBookName() {
        return bookName;
    }

    public void setBookName(String bookName) {
        this.bookName = bookName;
    }

    public int getBookCounts() {
        return bookCounts;
    }

    public void setBookCounts(int bookCounts) {
        this.bookCounts = bookCounts;
    }

    public String getDetail() {
        return detail;
    }

    public void setDetail(String detail) {
        this.detail = detail;
    }

    @Override
    public String toString() {
        return &quot;Books{&quot; +
                &quot;bookID=&quot; + bookID +
                &quot;, bookName='&quot; + bookName + '\'' +
                &quot;, bookCounts=&quot; + bookCounts +
                &quot;, detail='&quot; + detail + '\'' +
                '}';
    }
}
</code></pre>
<h4 id="13编写对应的dao层">1.3编写对应的dao层</h4>
<ul>
<li>UserMapper.java</li>
</ul>
<pre><code class="language-java">public interface BookMapper {

    //增
    int addBook(Books books);
    // 删
    int deleteBookById(@Param(&quot;bookID&quot;) int id);
    // 改
    int updateBook(Books books);
    // 查
    Books queryBookBuId(@Param(&quot;bookID&quot;) int id);
    //查全部的书
    List&lt;Books&gt; queryAllBook();

}
</code></pre>
<ul>
<li>UserMapper.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;!--namespace 是要绑定的类的路径--&gt;
&lt;mapper namespace=&quot;org.example.dao.BookMapper&quot;&gt;

    &lt;insert id=&quot;addBook&quot; parameterType=&quot;books&quot;&gt;
        insert into ssmbuild.books (bookID, bookName, bookCounts, detail)
        values (#{bookID},#{bookName},#{bookCounts},#{detail})
    &lt;/insert&gt;

    &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt;
        delete from ssmbuild.books where bookID = #{bookID}
    &lt;/delete&gt;

    &lt;update id=&quot;updateBook&quot; parameterType=&quot;books&quot;&gt;
        update ssmbuild.books set bookName=#{bookName},bookCounts=#{bookCounts}，detail=#{detail}
        where bookID=#{bookID}
    &lt;/update&gt;

    &lt;select id=&quot;queryBookBuId&quot; parameterType=&quot;int&quot; resultType=&quot;books&quot;&gt;
        select * from ssmbuild.books where bookID=#{bookID}
    &lt;/select&gt;

    &lt;select id=&quot;queryAllBook&quot; resultType=&quot;books&quot;&gt;
        select * from ssmbuild.books
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<h4 id="14编写mybatis-configxml">1.4编写mybatis-config.xml</h4>
<p><mark>这里的话mybatis-config.xml中不用写数据库连接池，而是统一交由spring来处理</mark></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;!--设置日志--&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;/settings&gt;
    &lt;!--别名--&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;org.example.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;!--mapper映射  扫描dao包--&gt;
    &lt;mappers&gt;
        &lt;package name=&quot;org.example.dao&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h4 id="15编写mybatis-configxml">1.5编写mybatis-config.xml</h4>
<p><mark>也就是将dao层整合到spring中</mark></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--关联数据库 c3p0连接池 --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot;
                  value=&quot;jdbc:mysql://localhost:3306/ssmbuild?serverTimezone=Asia/Shanghai&amp;amp;useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;

        &lt;!-- c3p0连接池的私有属性 --&gt;
        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;
        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;
        &lt;!-- 关闭连接后不自动commit --&gt;
        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;
        &lt;!-- 获取连接超时时间 --&gt;
        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;
        &lt;!-- 当获取连接失败重试次数 --&gt;
        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--SqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!-- 绑定mybatis全局配置文件:mybatis-config.xml --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置dao接口扫描包，动态的实现了Dao接口可以注册到Spring容器--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!--注入sqlSessionFactory--&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
        &lt;!--扫描要扫描的包--&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;org.example.dao&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<hr>
<h3 id="2整合service层">2.整合service层</h3>
<h4 id="21编写service层java代码">2.1编写service层java代码</h4>
<pre><code class="language-java">package org.example.service;

import org.apache.ibatis.annotations.Param;
import org.example.pojo.Books;

import java.util.List;

/**
 * @author aRu
 * @date 2021/3/24 21:29
 */
public interface BookService {
    //增
    int addBook(Books books);
    // 删
    int deleteBookById(@Param(&quot;bookID&quot;) int id);
    // 改
    int updateBook(Books books);
    // 查
    Books queryBookBuId(@Param(&quot;bookID&quot;) int id);
    //查全部的书
    List&lt;Books&gt; queryAllBook();
}
</code></pre>
<pre><code class="language-java">package org.example.service;

import org.example.dao.BookMapper;
import org.example.pojo.Books;

import java.util.List;

/**
 * @author aRu
 * @date 2021/3/24 21:30
 */
public class BookServiceImp implements BookService{
    //service调用dao层   组合dao
    private BookMapper bookMapper;

    public void setBookMapper(BookMapper bookMapper) {
        this.bookMapper = bookMapper;
    }

    @Override
    public int addBook(Books books) {
        return bookMapper.addBook(books);
    }

    @Override
    public int deleteBookById(int id) {
        return bookMapper.deleteBookById(id);
    }

    @Override
    public int updateBook(Books books) {
        return bookMapper.updateBook(books);
    }

    @Override
    public Books queryBookBuId(int id) {
        return bookMapper.queryBookBuId(id);
    }

    @Override
    public List&lt;Books&gt; queryAllBook() {
        return bookMapper.queryAllBook();
    }
}
</code></pre>
<h4 id="22编写service层配置文件spring-servicexml">2.2编写service层配置文件spring-service.xml</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--扫描service下的包--&gt;
    &lt;context:component-scan base-package=&quot;org.example.service&quot; /&gt;

    &lt;!--ServiceImpl注入到IOC容器中--&gt;
    &lt;bean id=&quot;BookServiceImp&quot; class=&quot;org.example.service.BookServiceImp&quot;&gt;
        &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 配置事务管理器 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!-- 注入数据库连接池 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<hr>
<h3 id="3整合springmvc层">3.整合SpringMVC层</h3>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210325093214.png" alt="image-20210325093214157" loading="lazy"></figure>
<p>添加 Framework Support</p>
<h4 id="31编写spring-mvcxml">3.1编写spring-mvc.xml</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 1.开启SpringMVC注解驱动 --&gt;
    &lt;mvc:annotation-driven/&gt;
    &lt;!-- 2.静态资源默认servlet配置--&gt;
    &lt;mvc:default-servlet-handler/&gt;

    &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 4.扫描web相关的bean --&gt;
    &lt;context:component-scan base-package=&quot;org.example.controller&quot; /&gt;

&lt;/beans&gt;
</code></pre>
<p><mark>记得在WEB-INF在新建jsp的文件</mark></p>
<h4 id="32编写applicationcontextxml">3.2编写applicationContext.xml</h4>
<p>将之前的<strong>spring-dao.xml  spring-service.xml spring-mvc.xml</strong>引入<strong>applicationContext.xml</strong>中</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-service.xml&quot;/&gt;
    &lt;import resource=&quot;classpath:spring-mvc.xml&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<h4 id="33编写webxml文件">3.3编写web.xml文件</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--DispatcherServlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;!--一定要注意:这里加载的是总的配置文件，之前被这里坑了！--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;!--encodingFilter--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;
            org.springframework.web.filter.CharacterEncodingFilter
        &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!--Session过期时间--&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;

&lt;/web-app&gt;
</code></pre>
<h4 id="34编写controller层">3.4编写controller层</h4>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/book&quot;)
public class BookController {
    //controller层 调用service层
    @Autowired
    @Qualifier(&quot;BookServiceImp&quot;)
    private BookService bookService;

    //查询全部书籍，并返回给展示页
    @RequestMapping(&quot;/allBook&quot;)
    public String list(Model model){
        List&lt;Books&gt; books=bookService.queryAllBook();
        model.addAttribute(&quot;list&quot;,books);

        return &quot;allBook&quot;;
    }
    
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring5课堂笔记]]></title>
        <id>https://aruul.github.io/post/E7oM6mwEJ/</id>
        <link href="https://aruul.github.io/post/E7oM6mwEJ/">
        </link>
        <updated>2021-03-20T03:27:35.000Z</updated>
        <summary type="html"><![CDATA[<p>这是看b站狂神的视频总结的笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>这是看b站狂神的视频总结的笔记</p>
<!--more-->
<p><ul class="markdownIt-TOC">
<li><a href="#spring5">Spring5</a>
<ul>
<li><a href="#1-spring">1.、Spring</a>
<ul>
<li><a href="#11-%E7%AE%80%E4%BB%8B">1.1、简介</a></li>
<li><a href="#12-%E4%BC%98%E7%82%B9">1.2 优点</a></li>
<li><a href="#13-%E7%BB%84%E6%88%90">1.3 组成</a></li>
<li><a href="#14-%E6%89%A9%E5%B1%95">1.4、扩展</a></li>
</ul>
</li>
<li><a href="#2-ioc%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E7%90%86%E8%AE%BA%E6%8E%A8%E5%AF%BC">2、IoC（控制反转）理论推导</a>
<ul>
<li><a href="#ioc%E6%9C%AC%E8%B4%A8">IoC本质</a></li>
</ul>
</li>
<li><a href="#3-hollespring">3、HolleSpring</a></li>
<li><a href="#4-ioc%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F">4、IoC创建对象的方式</a></li>
<li><a href="#5-spring%E9%85%8D%E7%BD%AE">5、Spring配置</a>
<ul>
<li><a href="#51-%E5%88%AB%E5%90%8D">5.1、别名</a></li>
<li><a href="#52-bean%E7%9A%84%E9%85%8D%E7%BD%AE">5.2、Bean的配置</a></li>
<li><a href="#53-import">5.3、import</a></li>
</ul>
</li>
<li><a href="#6-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di">6、依赖注入（DI）</a>
<ul>
<li><a href="#61-%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5">6.1、构造器注入</a></li>
<li><a href="#62-set%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5%E9%87%8D%E7%82%B9">6.2、set方式注入【重点】</a></li>
<li><a href="#63-%E6%8B%93%E5%B1%95%E6%B3%A8%E5%85%A5">6.3、拓展注入</a></li>
<li><a href="#64-bean%E4%BD%9C%E7%94%A8%E5%9F%9F">6.4、Bean作用域</a></li>
</ul>
</li>
<li><a href="#7-bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">7、Bean的自动装配</a>
<ul>
<li><a href="#71%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">7.1测试：自动装配</a></li>
<li><a href="#72-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">7.2、使用注解实现自动装配</a>
<ul>
<li><a href="#721-autowired">7.2.1、@Autowired</a></li>
<li><a href="#722-autowiredqualifier">7.2.2、@Autowired+@Qualifier</a></li>
<li><a href="#723-resource">7.2.3、@Resource</a></li>
<li><a href="#%E5%8C%BA%E5%88%AB">区别：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91">8、使用注解开发</a>
<ul>
<li><a href="#81-bean">8.1、bean</a></li>
<li><a href="#82-%E5%B1%9E%E6%80%A7%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5value">8.2、属性如何注入@value</a></li>
<li><a href="#83-%E8%A1%8D%E7%94%9F%E7%9A%84%E6%B3%A8%E8%A7%A3">8.3、衍生的注解</a></li>
<li><a href="#84-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%BD%AE">8.4、自动装配置</a></li>
<li><a href="#85-%E4%BD%9C%E7%94%A8%E5%9F%9Fscope">8.5、作用域@scope</a></li>
<li><a href="#86-%E5%B0%8F%E7%BB%93">8.6、小结</a></li>
</ul>
</li>
<li><a href="#9-%E4%BD%BF%E7%94%A8java%E7%9A%84%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AEspring">9、使用Java的方式配置Spring</a></li>
<li><a href="#10-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">10、动态代理</a>
<ul>
<li><a href="#101-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">10.1、静态代理</a></li>
<li><a href="#102-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">10.2、动态代理</a></li>
</ul>
</li>
<li><a href="#11-aop">11、AOP</a>
<ul>
<li><a href="#111-%E4%BB%80%E4%B9%88%E6%98%AFaop">11.1、什么是AOP</a></li>
<li><a href="#112-aop%E5%9C%A8spring%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8">11.2、AOP在Spring中的使用</a></li>
<li><a href="#113-%E4%BD%BF%E7%94%A8spring%E5%AE%9E%E7%8E%B0aop">11.3、使用Spring实现AOP</a>
<ul>
<li><a href="#1131-%E6%96%B9%E6%B3%95%E4%B8%80%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fspring%E6%8E%A5%E5%8F%A3">11.3.1、方法一：使用原生spring接口</a></li>
<li><a href="#1132-%E6%96%B9%E6%B3%95%E4%BA%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%AE%9E%E7%8E%B0aop">11.3.2、方法二：自定义类实现AOP</a></li>
<li><a href="#1133-%E6%96%B9%E6%B3%95%E4%B8%89%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0">11.3.3、方法三：使用注解实现</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#12-%E6%95%B4%E5%90%88mybatis">12、整合mybatis</a>
<ul>
<li><a href="#121-mybatis-spring-%E6%96%B9%E5%BC%8F%E4%B8%80">12.1、mybatis-spring-方式一</a></li>
<li><a href="#122-mybatis-spring-%E6%96%B9%E5%BC%8F%E4%BA%8C">12.2、mybatis-spring-方式二</a></li>
</ul>
</li>
<li><a href="#13-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1">13. 声明式事务</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="spring5">Spring5</h1>
<h2 id="1-spring">1.、Spring</h2>
<h3 id="11-简介">1.1、简介</h3>
<ul>
<li>
<p>Spring ——&gt; 春天，为开源软件带来了春天</p>
</li>
<li>
<p>2002，首次推出了Spring框架的雏形：interface21框架！</p>
</li>
<li>
<p>Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版</p>
</li>
<li>
<p>Spring的理念：使用现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！</p>
</li>
<li>
<p>SSH：Struct2 + Spring + Hibernate（全自动持久化框架）！</p>
</li>
<li>
<p>SSM：SpringMVC + Spring + MyBatis（半自动持久化框架，可自定义性质更强）！</p>
</li>
</ul>
<p>spring官网： https://spring.io/projects/spring-framework#overview</p>
<p>官方下载： https://repo.spring.io/release/org/springframework/spring/</p>
<p>GitHub： https://github.com/spring-projects/spring-framework</p>
<p>Spring Web MVC： <a href="https://mvnrepository.com/artifact/org.springframework/spring-webmvc/5.2.7.RELEASE">spring-webmvc最新版</a></p>
<p>Spring Web MVC和Spring-JDBC的pom配置文件：</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="12-优点">1.2 优点</h3>
<ul>
<li>Spring是一个开源的免费的框架（容器）！</li>
<li>Spring是一个轻量级的、非入侵式的框架！</li>
<li>控制反转（IoC），面向切面编程（AOP）</li>
<li>支持事务的处理，对框架整合的支持！（几乎市面上所有热门框架都能整合进去）！</li>
</ul>
<p>=== 总结一句话：Spring就是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的框架！ ===</p>
<h3 id="13-组成">1.3 组成</h3>
<figure data-type="image" tabindex="1"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvU3ByaW5nNyVFNSVBNCVBNyVFNiVBOCVBMSVFNSU5RCU5Ny5wbmc" alt="img" loading="lazy"></figure>
<h3 id="14-扩展">1.4、扩展</h3>
<p>现代化的java开发 -&gt; 基于Spring的开发！</p>
<figure data-type="image" tabindex="2"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvMjAyMDA4MDEwMzA4MjAucG5n" alt="img" loading="lazy"></figure>
<ul>
<li>Spring Boot
<ul>
<li>一个快速开发的脚手架</li>
<li>基于SpringBoot可以快速开发单个微服务</li>
<li>约定大于配置！</li>
</ul>
</li>
<li>Spring Cloud
<ul>
<li>SpringCloud是基于SpringBoot实现的！</li>
</ul>
</li>
</ul>
<p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！</p>
<h2 id="2-ioc控制反转理论推导">2、IoC（控制反转）理论推导</h2>
<p><strong>传统</strong>的调用</p>
<ol>
<li>
<p>UserDao</p>
<pre><code class="language-java">package dao;
public interface UserDao {
	void getUser();
}
</code></pre>
</li>
<li>
<p>UserDaoImp</p>
<pre><code class="language-java">package dao;
public class UserDaoImpl implements UserDao{
	public void getUser() {
		System.out.println(&quot;默认获取用户数据&quot;);	
	}
}
</code></pre>
</li>
<li>
<p>UserSevice</p>
<pre><code class="language-java">package Service;
public interface UserService {
	void getUser();
}
</code></pre>
</li>
<li>
<p>UserServiceImp</p>
<pre><code class="language-java">package Service;
import dao.UserDao;
import dao.UserDaoImpl;

public class UserServiceImpl implements UserService{
		UserDao userDao = new UserDaoImpl();		
		public void getUser(){
			userDao.getUser();
		}	
}
</code></pre>
</li>
</ol>
<p>测试</p>
<pre><code class="language-java">package holle0;
import Service.UserService;
import Service.UserServiceImpl;

public class MyTest0 {
	public static void main(String[] args) {
		// 用户实际调用的是业务层，dao层他们不需要接触
		UserService userService = new UserServiceImpl();
		userService.getUser();
	}
}
</code></pre>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！</p>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExMjI3NDI1ODEucG5n" alt="image-20200801122742581" loading="lazy"><br>
**改良：**我们使用一个Set接口实现。已经发生了革命性的变化！</p>
<pre><code class="language-java">//在Service层的实现类(UserServiceImpl)增加一个Set()方法
//利用set动态实现值的注入！
//DAO层并不写死固定调用哪一个UserDao的实现类
//而是通过Service层调用方法设置实现类！
private UserDao userDao;
public void setUserDao(UserDao userDao){
    this.userDao = userDao;
}
</code></pre>
<p>set() 方法实际上是动态改变了 UserDao userDao 的 初始化部分（<strong>new UserDaoImpl()</strong>）</p>
<p>测试中加上</p>
<pre><code class="language-java">((UserServiceImpl)userService).setUserDao(new UserDaoImpl());
</code></pre>
<ul>
<li>之前，程序是主动创建对象！<strong>控制权在程序猿手上</strong>！</li>
<li>使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！（<strong>主动权在客户手上</strong>）</li>
</ul>
<p>本质上解决了问题，程序员不用再去管理对象的创建</p>
<p>系统的耦合性大大降低，可以更专注在业务的实现上</p>
<p>这是IoC（控制反转）的原型，反转(理解)：主动权交给了用户</p>
<figure data-type="image" tabindex="3"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExMjI4MDU3NjkucG5n" alt="image-20200801122805769" loading="lazy"></figure>
<h3 id="ioc本质">IoC本质</h3>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExMjM1MTg5NzQucG5n" alt="image-20200801123518974" loading="lazy"><br>
<img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvMjAyMDA4MDExMjMyMzUucG5n" alt="img" loading="lazy"><br>
<img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExMjMzNDgyMDcucG5n" alt="image-20200801123348207" loading="lazy"><br>
<img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExMjM0NTA4OTcucG5n" alt="image-20200801123450897" loading="lazy"></p>
<h2 id="3-hollespring">3、HolleSpring</h2>
<p>在父模块中导入jar包</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
	&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
	&lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>pojo的Hello.java</p>
<pre><code class="language-java">package pojo;

public class Hello {

	private String str;
	
	public String getStr() {
		return str;
	}

	public void setStr(String str) {
		this.str = str;
	}
	
	@Override
	public String toString() {
		return &quot;Holle [str=&quot; + str + &quot;]&quot;;
	}
}
</code></pre>
<p>在resource里面的xml配置</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


    &lt;!--在Spring中创建对象，在Spring这些都称为bean
    	类型 变量名 = new 类型();
    	Holle holle = new Holle();
    	
    	bean = 对象(holle)
    	id = 变量名(holle)
    	class = new的对象(new Holle();)
    	property 相当于给对象中的属性设值,让str=&quot;Spring&quot;
    --&gt;
    
    &lt;bean id=&quot;hello&quot; class=&quot;pojo.Hello&quot;&gt;
        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试类MyTest</p>
<pre><code class="language-java">package holle1;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import pojo.Hello;

public class MyTest {

	public static void main(String[] args) {
		//获取Spring的上下文对象
		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
		//我们的对象下能在都在spring·中管理了，我们要使用，直接取出来就可以了
		Hello holle = (Hello) context.getBean(&quot;hello&quot;);
		System.out.println(holle.toString());
	}

}
</code></pre>
<p>核心用set注入，所以必须要有下面的se()方法</p>
<pre><code class="language-java">//Hello类
public void setStr(String str) {
		this.str = str;
	}
</code></pre>
<p><strong>思考：</strong></p>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDExNjUxNTYyNTkucG5n" alt="image-20200801165156259" loading="lazy"><br>
IoC：对象由Spring 来创建，管理，装配！</p>
<p><strong>弹幕评论里面的理解：</strong></p>
<p>原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待，就相当于你请人吃饭<br>
现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的你需要的菜送上来<br>
IoC：炒菜这件事，不再由你自己来做，而是委托给了第三方__餐厅来做</p>
<p>此时的区别就是，如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来</p>
<p>.</p>
<p>在前面第一个module试试引入Spring</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;userDaomSql&quot; class=&quot;dao.UserDaoMysqlImpl&quot;&gt;&lt;/bean&gt;

    &lt;bean id=&quot;userServiceImpl&quot; class=&quot;service.UserServiceImp&quot;&gt;
        &lt;!--ref引用spring中已经创建很好的对象--&gt;
        &lt;!--value是一个具体的值,基本数据类型--&gt;
        &lt;property name=&quot;userDao&quot; ref=&quot;userDaomSql&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>第一个module改良后测试</p>
<pre><code class="language-java">package holle0;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import service.UserServiceImpl;

public class MyTest0 {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
		UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(&quot;userServiceImpl&quot;);
		userServiceImpl.getUser();
	}
}
</code></pre>
<p><strong>总结：</strong></p>
<p>所有的类都要装配的beans.xml 里面；</p>
<p>所有的bean 都要通过容器去取；</p>
<p>容器里面取得的bean，拿出来就是一个对象，用对象调用方法即可；</p>
<h2 id="4-ioc创建对象的方式">4、IoC创建对象的方式</h2>
<ol>
<li>使用无参构造创建对象，默认。</li>
<li>使用有参构造（如下）</li>
</ol>
<p>下标赋值</p>
<p>index指的是有参构造中参数的下标，下标从0开始;</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;chen&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>类型赋值（不建议使用）</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;kuang&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>直接通过参数名（掌握）</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;kuang&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
&lt;!-- 比如参数名是name，则有name=&quot;具体值&quot; --&gt;
</code></pre>
<p>注册bean之后就对象的初始化了（<strong>类似 new 类名()</strong>）</p>
<p>弹幕评论：</p>
<p>name方式还需要无参构造和set方法,index和type只需要有参构造</p>
<p>就算是new 两个对象，也是只有一个实例（<strong>单例模式：全局唯一</strong>）</p>
<pre><code class="language-java">User user = (User) context.getBean(&quot;user&quot;);
User user2 = (User) context.getBean(&quot;user&quot;);
system.out.println(user == user2)//结果为true
</code></pre>
<p>总结：在配置文件加载的时候，容器(&lt; bean&gt;)中管理的对象就已经初始化了</p>
<h2 id="5-spring配置">5、Spring配置</h2>
<h3 id="51-别名">5.1、别名</h3>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;chen&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;alias name=&quot;user&quot; alias=&quot;userLove&quot;/&gt;
&lt;!-- 使用时
	User user2 = (User) context.getBean(&quot;userLove&quot;);	
--&gt;
</code></pre>
<h3 id="52-bean的配置">5.2、Bean的配置</h3>
<pre><code class="language-xml">&lt;!--id：bean的唯一标识符，也就是相当于我们学的对象名
class：bean对象所对应的会限定名：包名+类型
name：也是别名，而且name可以同时取多个别名 --&gt;
&lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; name=&quot;u1 u2,u3;u4&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;chen&quot;/&gt;
&lt;/bean&gt;
&lt;!-- 使用时
	User user2 = (User) context.getBean(&quot;u1&quot;);	
--&gt;
</code></pre>
<h3 id="53-import">5.3、import</h3>
<p>import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个</p>
<p>假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利<br>
用import将所有人的beans.xml合并为一个总的！</p>
<ul>
<li>
<p>张三(beans.xm1)</p>
</li>
<li>
<p>李四(beans2.xm1)</p>
</li>
<li>
<p>王五(beans3.xm1)</p>
</li>
<li>
<p>applicationContext.xml</p>
<pre><code class="language-xml">&lt;import resource=&quot;beans.xm1&quot;/&gt;
&lt;import resource=&quot;beans2.xml&quot;/&gt;
&lt;import resource=&quot;beans3.xm1&quot;/&gt;
</code></pre>
</li>
</ul>
<p><strong>使用的时候，直接使用总的配置就可以了</strong></p>
<p>弹幕评论：</p>
<p>按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个</p>
<h2 id="6-依赖注入di">6、依赖注入（DI）</h2>
<h3 id="61-构造器注入">6.1、构造器注入</h3>
<p>第4点有提到</p>
<h3 id="62-set方式注入重点">6.2、set方式注入【重点】</h3>
<p>依赖注入：set注入！</p>
<ul>
<li>依赖：bean对象的创建依赖于容器</li>
<li>注入：bean对象中的所有属性，由容器来注入</li>
</ul>
<p>【环境搭建】</p>
<ol>
<li>
<p>复杂类型</p>
<p>Address类</p>
</li>
<li>
<p>真实测试对象</p>
<p>Student类</p>
</li>
<li>
<p>beans.xml</p>
</li>
<li>
<p>测试</p>
<p>MyTest3</p>
</li>
</ol>
<p>Student类</p>
<pre><code class="language-java">package pojo;

import java.util.*;
@Get
@Set
public class Student {
//别忘了写get和set方法（用lombok注解也行）
    private String name;
    private Address address;

    private String[] books;
    private List&lt;String&gt; hobbies;

    private Map&lt;String, String&gt; card;
    private Set&lt;String&gt; game;

    private Properties infor;
    private String wife;

    @Override
    public String toString() {
        return &quot;Student{&quot; +&quot;\n&quot;+
                &quot;name='&quot; + name + '\'' +&quot;\n&quot;+
                &quot;, address=&quot; + address.toString() +&quot;\n&quot;+
                &quot;, books=&quot; + Arrays.toString(books) +&quot;\n&quot;+
                &quot;, hobbies=&quot; + hobbies +&quot;\n&quot;+
                &quot;, card=&quot; + card +&quot;\n&quot;+
                &quot;, game=&quot; + game +&quot;\n&quot;+
                &quot;, infor=&quot; + infor +&quot;\n&quot;+
                &quot;, wife='&quot; + wife + '\'' +&quot;\n&quot;+
                '}';
    }
}
</code></pre>
<p>Address类</p>
<pre><code class="language-java">package pojo;

public class Address {

    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &quot;Address{&quot; +
                &quot;address='&quot; + address + '\'' +
                '}';
    }
}
</code></pre>
<p>beans.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

	&lt;bean id=&quot;address&quot; class=&quot;pojo.Address&quot;&gt;
		&lt;property name=&quot;address&quot; value=&quot;address你好&quot; /&gt;
	&lt;/bean&gt;

	&lt;bean id=&quot;student&quot; class=&quot;pojo.Student&quot;&gt;
		&lt;!--第一种，普通值注入 --&gt;
		&lt;property name=&quot;name&quot; value=&quot;name你好&quot; /&gt;
		&lt;!--第二种，ref注入 --&gt;
		&lt;property name=&quot;address&quot; ref=&quot;address&quot; /&gt;

		&lt;!--数组注入 --&gt;
		&lt;property name=&quot;books&quot;&gt;
			&lt;array&gt;
				&lt;value&gt;三国&lt;/value&gt;
				&lt;value&gt;西游&lt;/value&gt;
				&lt;value&gt;水浒&lt;/value&gt;
			&lt;/array&gt;
		&lt;/property&gt;

		&lt;!--list列表注入 --&gt;
		&lt;property name=&quot;hobbies&quot;&gt;
			&lt;list&gt;
				&lt;value&gt;唱&lt;/value&gt;
				&lt;value&gt;跳&lt;/value&gt;
				&lt;value&gt;rap&lt;/value&gt;
				&lt;value&gt;篮球&lt;/value&gt;
			&lt;/list&gt;
		&lt;/property&gt;

		&lt;!--map键值对注入 --&gt;
		&lt;property name=&quot;card&quot;&gt;
			&lt;map&gt;
				&lt;entry key=&quot;username&quot; value=&quot;root&quot; /&gt;
				&lt;entry key=&quot;password&quot; value=&quot;root&quot; /&gt;
			&lt;/map&gt;
		&lt;/property&gt;

		&lt;!--set(可去重)注入 --&gt;
		&lt;property name=&quot;game&quot;&gt;
			&lt;set&gt;
				&lt;value&gt;wangzhe&lt;/value&gt;
				&lt;value&gt;lol&lt;/value&gt;
				&lt;value&gt;galname&lt;/value&gt;
			&lt;/set&gt;
		&lt;/property&gt;

		&lt;!--空指针null注入 --&gt;
		&lt;property name=&quot;wife&quot;&gt;
			&lt;null&gt;&lt;/null&gt;
		&lt;/property&gt;

		&lt;!--properties常量注入 --&gt;
		&lt;property name=&quot;infor&quot;&gt;
			&lt;props&gt;
				&lt;prop key=&quot;id&quot;&gt;20200802&lt;/prop&gt;
				&lt;prop key=&quot;name&quot;&gt;cbh&lt;/prop&gt;
			&lt;/props&gt;
		&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>MyTest3</p>
<pre><code class="language-java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import pojo.Student;

public class MyTest3 {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
		Student stu = (Student) context.getBean(&quot;student&quot;);
		System.out.println(stu.toString());
	}	
}
</code></pre>
<h3 id="63-拓展注入">6.3、拓展注入</h3>
<p>官方文档位置</p>
<figure data-type="image" tabindex="4"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIxNDI3MTcyMTYucG5n" alt="image-20200802142717216" loading="lazy"></figure>
<p>pojo增加User类</p>
<pre><code class="language-java">package pojo;

public class User {
    private String name;
    private int id;
	public User() {
        
	}
	public User(String name, int id) {
		super();
		this.name = name;
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	@Override
	public String toString() {
		return &quot;User [name=&quot; + name + &quot;, id=&quot; + id + &quot;]&quot;;
	}
}
</code></pre>
<p>注意： beans 里面加上这下面两行</p>
<p>使用p和c命名空间需要导入xml约束</p>
<p>xmlns:p=“http://www.springframework.org/schema/p”<br>
xmlns:c=“http://www.springframework.org/schema/c”</p>
<pre><code class="language-xml">?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--p命名空间注入/set注入，可以直接注入属性的值-》property--&gt;
    &lt;bean id=&quot;user&quot; class=&quot;pojo.User&quot; p:name=&quot;cxk&quot; p:id=&quot;20&quot; &gt;
    &lt;/bean&gt;

    &lt;!--c命名空间，通过构造器注入，需要写入有参和无参构造方法-》construct-args--&gt;
    &lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:name=&quot;cbh&quot; c:id=&quot;22&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="language-java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
User user = context.getBean(&quot;user&quot;,User.class);//确定class对象，就不用再强转了
System.out.println(user.toString());
</code></pre>
<h3 id="64-bean作用域">6.4、Bean作用域</h3>
<figure data-type="image" tabindex="5"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIxNDM0MDExNjUucG5n" alt="image-20200802143401165" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIxNDMzNDI1ODYucG5n" alt="image-20200802143342586" loading="lazy"></figure>
<ol>
<li>
<p>单例模式（默认）</p>
<pre><code class="language-xml">&lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:name=&quot;cxk&quot; c:age=&quot;19&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
1
</code></pre>
</li>
</ol>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIxNDM4MDIwMDUucG5n" alt="image-20200802143802005" loading="lazy"><br>
弹幕评论：单例模式是把对象放在pool中，需要再取出来，使用的都是同一个对象实例</p>
<ol>
<li>
<p>原型模式: 每次从容器中get的时候，都产生一个新对象！</p>
<pre><code class="language-xml">&lt;bean id=&quot;user2&quot; class=&quot;pojo.User&quot; c:name=&quot;cxk&quot; c:age=&quot;19&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
1
</code></pre>
</li>
</ol>
<figure data-type="image" tabindex="7"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIxNDM4MjYyMjcucG5n" alt="image-20200802143826227" loading="lazy"></figure>
<ol>
<li>其余的request、session、application这些只能在web开放中使用！</li>
</ol>
<h2 id="7-bean的自动装配">7、Bean的自动装配</h2>
<ul>
<li>自动装配是Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文自动寻找，并自动给bean装配属性</li>
</ul>
<p>在Spring中有三种装配的方式</p>
<ol>
<li>
<p>在xml中显示配置</p>
</li>
<li>
<p>在java中显示配置</p>
</li>
<li>
<p>隐式的自动装配bean 【重要】</p>
</li>
<li>
<p>环境搭建：一个人有两个宠物</p>
</li>
<li>
<p>byType自动装配：byType会自动查找，和自己对象set方法参数的类型相同的bean</p>
<p>保证所有的class唯一(类为全局唯一)</p>
</li>
<li>
<p>byName自动装配：byName会自动查找，和自己对象set对应的值对应的id</p>
<p>保证所有id唯一，并且和set注入的值一致</p>
<pre><code class="language-xml">&lt;!-- 找不到id和多个相同class --&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;pojo.Cat&quot;/&gt;
&lt;!-- 找不到 id=cat，且有两个Cat --&gt;
</code></pre>
</li>
</ol>
<h3 id="71测试自动装配">7.1测试：自动装配</h3>
<p>pojo的Cat类</p>
<pre><code class="language-java">public class Cat {
    public void shut(){
        System.out.println(&quot;miao&quot;);
    }
}
</code></pre>
<p>pojo的Dog类</p>
<pre><code class="language-java">public class Dog {

    public void shut(){
        System.out.println(&quot;wow&quot;);
    }

}
</code></pre>
<p>pojo的People类</p>
<pre><code class="language-java">package pojo;
public class People {
    
    private Cat cat;
    private Dog dog;
    private String name;

    public Cat getCat() {
        return cat;
    }

    public void setCat(Cat cat) {
        this.cat = cat;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return &quot;People{&quot; +
                &quot;cat=&quot; + cat +
                &quot;, dog=&quot; + dog +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p>xml配置 -&gt; byType 自动装配</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;cat&quot; class=&quot;pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;/&gt;
    
    &lt;!--byType会在容器自动查找，和自己对象属性相同的bean
		例如，Dog dog; 那么就会查找pojo的Dog类，再进行自动装配
	--&gt;
    &lt;bean id=&quot;people&quot; class=&quot;pojo.People&quot; autowire=&quot;byType&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;cbh&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>xml配置 -&gt; byName 自动装配</p>
<pre><code class="language-xml">&lt;bean id=&quot;cat&quot; class=&quot;pojo.Cat&quot;/&gt;
&lt;bean id=&quot;dog&quot; class=&quot;pojo.Dog&quot;/&gt;
&lt;!--byname会在容器自动查找，和自己对象set方法的set后面的值对应的id
  例如:setDog()，取set后面的字符作为id，则要id = dog 才可以进行自动装配
  
 --&gt;
&lt;bean id=&quot;people&quot; class=&quot;pojo.People&quot; autowire=&quot;byName&quot;&gt;
	&lt;property name=&quot;name&quot; value=&quot;cbh&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>弹幕评论：byName只能取到小写，大写取不到</p>
<h3 id="72-使用注解实现自动装配">7.2、使用注解实现自动装配</h3>
<p>jdk1.5支持的注解，spring2.5支持的注解</p>
<p>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.（翻译：基于注释的配置的引入提出了一个问题，即这种方法是否比XML“更好”）</p>
<ol>
<li>导入context约束</li>
</ol>
<pre><code class="language-xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
</code></pre>
<ol>
<li>配置注解的支持：&lt; context:annotation-config/&gt;</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="721-autowired">7.2.1、@Autowired</h4>
<p><strong>默认是byType方式，如果匹配不上，就会byName</strong></p>
<p>在属性上个使用，也可以在set上使用</p>
<p>我们可以不用编写set方法了，前提是自动装配的属性在Spring容器里，且要符合ByName 自动装配</p>
<pre><code class="language-java">public class People {
    @Autowired
    private Cat cat;
    @Autowired
    private Dog dog;
    private String name;
}
</code></pre>
<blockquote>
<p>@Nullable 字段标记了这个注解，说明该字段可以为空</p>
<p>public name(@Nullable String name){</p>
<p>}</p>
</blockquote>
<pre><code class="language-java">//源码
public @interface Autowired { 
	boolean required() default true; 
}
</code></pre>
<p>如果定义了Autowire的require属性为false，说明这个对象可以为null，否则不允许为空（false表示找不到装配，不抛出异常）</p>
<h4 id="722-autowiredqualifier">7.2.2、@Autowired+@Qualifier</h4>
<p><strong>@Autowired不能唯一装配时，需要@Autowired+@Qualifier</strong></p>
<p>如果@Autowired自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用@Qualifier(value = “dog”)去配合使用，指定一个唯一的id对象</p>
<pre><code class="language-java">public class People {
    @Autowired
    private Cat cat;
    @Autowired
    @Qualifier(value = &quot;dog&quot;)
    private Dog dog;
    private String name;
}
</code></pre>
<p>弹幕评论：</p>
<p>如果xml文件中同一个对象被多个bean使用，Autowired无法按类型找到，可以用@Qualifier指定id查找</p>
<h4 id="723-resource">7.2.3、@Resource</h4>
<p><strong>默认是byName方式，如果匹配不上，就会byType</strong></p>
<pre><code class="language-java">public class People {
    Resource(name=&quot;cat&quot;)
    private Cat cat;
    Resource(name=&quot;dog&quot;)
    private Dog dog;
    private String name;
}
</code></pre>
<p>弹幕评论：</p>
<p>Autowired是byType，@Autowired+@Qualifier = byType || byName</p>
<p>Autowired是先byteType,如果唯一則注入，否则byName查找。resource是先byname,不符合再继续byType</p>
<h4 id="区别">区别：</h4>
<p>@Resource和@Autowired的区别：</p>
<ul>
<li>都是用来自动装配的，都可以放在属性字段上</li>
<li>@Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】</li>
<li>@Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】</li>
<li>执行顺序不同：@Autowired通过byType的方式实现。@Resource默认通过byname的方式实现</li>
</ul>
<h2 id="8-使用注解开发">8、使用注解开发</h2>
<p>在spring4之后，使用注解开发，必须要保证aop包的导入<br>
<img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIyMDE5MjQ0OTAucG5n" alt="image-20200802201924490" loading="lazy"><br>
使用注解需要导入contex的约束</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="81-bean">8.1、bean</h3>
<p>弹幕评论：<br>
有了&lt; context:component-scan&gt;，另一个&lt; context:annotation-config/&gt;标签可以移除掉，因为已经被包含进去了。</p>
<pre><code class="language-xml">&lt;!--指定要扫描的包，这个包下面的注解才会生效
	别只扫一个com.kuang.pojo包--&gt; 
&lt;context:component-scan base-package=&quot;com.kuang&quot;/&gt; 
&lt;context:annotation-config/&gt;
</code></pre>
<pre><code class="language-java">//@Component 组件
//等价于&lt;bean id=&quot;user&quot; classs&quot;pojo.User&quot;/&gt; 
@Component
public class User {  
     public String name =&quot;秦疆&quot;;
}
</code></pre>
<h3 id="82-属性如何注入value">8.2、属性如何注入@value</h3>
<pre><code class="language-java">@Component
public class User { 
    //相当于&lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt; 
    @value(&quot;kuangshen&quot;) 
    public String name; 
    
    //也可以放在set方法上面
    //@value(&quot;kuangshen&quot;)
    public void setName(String name) { 
        this.name = name; 
    }
}
</code></pre>
<h3 id="83-衍生的注解">8.3、衍生的注解</h3>
<p>@Component有几个衍生注解，会按照web开发中，mvc架构中分层。</p>
<ul>
<li>dao （@Repository）</li>
<li>service（@Service）</li>
<li>controller（@Controller）</li>
</ul>
<p><strong>这四个注解的功能是一样的，都是代表将某个类注册到容器中</strong></p>
<h3 id="84-自动装配置">8.4、自动装配置</h3>
<p>@Autowired：默认是byType方式，如果匹配不上，就会byName</p>
<p>@Nullable：字段标记了这个注解，说明该字段可以为空</p>
<p>@Resource：默认是byName方式，如果匹配不上，就会byType</p>
<h3 id="85-作用域scope">8.5、作用域@scope</h3>
<pre><code class="language-java">//原型模式prototype，单例模式singleton
//scope(&quot;prototype&quot;)相当于&lt;bean scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
@Component 
@scope(&quot;prototype&quot;)
public class User { 
    
    //相当于&lt;property name=&quot;name&quot; value=&quot;kuangshen&quot;/&gt; 
    @value(&quot;kuangshen&quot;) 
    public String name; 
    
    //也可以放在set方法上面
    @value(&quot;kuangshen&quot;)
    public void setName(String name) { 
        this.name = name; 
    }
}
</code></pre>
<h3 id="86-小结">8.6、小结</h3>
<p><strong>xml与注解：</strong></p>
<ul>
<li>xml更加万能，维护简单，适用于任何场合</li>
<li>注解，不是自己的类使用不了，维护复杂</li>
</ul>
<p><strong>最佳实践：</strong></p>
<ul>
<li>xml用来管理bean</li>
<li>注解只用来完成属性的注入</li>
<li>要开启注解支持</li>
</ul>
<h2 id="9-使用java的方式配置spring">9、使用Java的方式配置Spring</h2>
<p>不使用Spring的xml配置，完全交给java来做！</p>
<p>Spring的一个子项目，在spring4之后，，，它成为了核心功能</p>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDIyMTU3NTI4NjgucG5n" alt="image-20200802215752868" loading="lazy"><br>
<strong>实体类：pojo的User.java</strong></p>
<pre><code class="language-java">//这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中 
@component 
public class User { 
    private String name;
    
    public String getName() { 
    	return name; 
    } 
    //属性注入值
    @value(&quot;QINJIANG')  
    public void setName(String name) { 
    	this.name = name; 
    } 
    @Override 
    public String toString() { 
        return &quot;user{&quot; + 
        &quot;name='&quot; + name + '\''+ 
        '}'; 
    } 
}
</code></pre>
<p>弹幕评论：要么使用@Bean，要么使用@Component和ComponentScan，两种效果一样</p>
<p><strong>配置文件：config中的kuang.java</strong></p>
<p>@Import(KuangConfig2.class)，用@import来包含KuangConfig2.java</p>
<pre><code class="language-java">//这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component 
// @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于&lt;beans&gt;标签
@Configuration 
@componentScan(&quot;com.Kuang.pojo&quot;) //开启扫描
//@Import(KuangConfig2.class)
public class KuangConfig { 
    //注册一个bean , 就相当于我们之前写的一个bean 标签 
    //这个方法的名字,就相当于bean 标签中的 id 属性 -&gt;getUser
    //这个方法的返同值,就相当于bean 标签中的class 属性 -&gt;User
    
    //@Bean 
    public User getUser(){ 
    	return new User(); //就是返回要注入到bean的对象! 
    } 
}
</code></pre>
<p>弹幕评论：ComponentScan、@Component(&quot;pojo”) 这两个注解配合使用</p>
<p><strong>测试类</strong></p>
<pre><code class="language-java">public class MyTest { 
    public static void main(String[ ] args) { 
    //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! 
    ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象
    User getUser =(User)context.getBean( &quot;getUser&quot;); //方法名getUser
    System.out.Println(getUser.getName()); 
    } 
}
</code></pre>
<p><strong>会创建两个相同对象问题的说明：</strong></p>
<p><strong>弹幕总结 - -&gt; @Bean是相当于&lt; bean&gt;标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了</strong></p>
<pre><code class="language-java">//这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component 
// @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于&lt;beans&gt;标签
@Configuration 
@componentScan(&quot;com.Kuang.pojo&quot;) //开启扫描
//@Import(KuangConfig2.class)
public class KuangConfig { 
    //注册一个bean , 就相当于我们之前写的一个bean 标签 
    //这个方法的名字,就相当于bean 标签中的 id 属性 -&gt;getUser
    //这个方法的返同值,就相当于bean 标签中的class 属性 -&gt;User
    
    //@Bean 
    public User getUser(){ 
    	return new User(); //就是返回要注入到bean的对象! 
    } 
}
</code></pre>
<p>弹幕评论：ComponentScan、@Component(&quot;pojo”) 这两个注解配合使用</p>
<p><strong>测试类</strong></p>
<pre><code class="language-java">public class MyTest { 
    public static void main(String[ ] args) { 
    //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! 
    ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象
    User getUser =(User)context.getBean( &quot;getUser&quot;); //方法名getUser
    System.out.Println(getUser.getName()); 
    } 
}
</code></pre>
<p><strong>会创建两个相同对象问题的说明：</strong></p>
<p><strong>弹幕总结 - -&gt; @Bean是相当于&lt; bean&gt;标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了</strong></p>
<h2 id="10-动态代理">10、动态代理</h2>
<p>代理模式是SpringAOP的底层</p>
<p>分类：动态代理和静态代理</p>
<figure data-type="image" tabindex="8"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMDE0Mjc4NDYucG5n" alt="image-20200803101427846" loading="lazy"></figure>
<h3 id="101-静态代理">10.1、静态代理</h3>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMDE2MjE4NjgucG5n" alt="image-20200803101621868" loading="lazy"><br>
代码步骤：</p>
<p>1、接口</p>
<pre><code class="language-java">package pojo;
public interface Host {
	public void rent();
}
</code></pre>
<p>2、真实角色</p>
<pre><code class="language-java">package pojo;
public class HostMaster implements Host{	
    
	public void rent() {
		System.out.println(&quot;房东要出租房子&quot;);
	}
}
</code></pre>
<p>3、代理角色</p>
<pre><code class="language-java">package pojo;
public class Proxy {

	public Host host;
	
	public Proxy() {
		
	}
	
	public Proxy(Host host) {
		super();
		this.host = host;
	}
	
	public void rent() {
		seeHouse();
		host.rent();
		fee();
		sign();
	}
	//看房
	public void seeHouse() {
		System.out.println(&quot;看房子&quot;);
	}
	//收费
	public void fee() {
		System.out.println(&quot;收中介费&quot;);
	}
	//合同
	public void sign() {
		System.out.println(&quot;签合同&quot;);
	}		
}
</code></pre>
<p>4、客户端访问代理角色</p>
<pre><code class="language-java">package holle4_proxy;

import pojo.Host;
import pojo.HostMaster;
import pojo.Proxy;

public class My {

	public static void main(String[] args) {
		//房东要出租房子
		Host host = new HostMaster();
		//中介帮房东出租房子，但也收取一定费用（增加一些房东不做的操作）
		Proxy proxy = new Proxy(host);
		//看不到房东，但通过代理，还是租到了房子
		proxy.rent();
		
	}
}
</code></pre>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMDUyMjk0NzgucG5n" alt="image-20200803105229478" loading="lazy"><br>
代码翻倍：几十个真实角色就得写几十个代理</p>
<p>AOP横向开发</p>
<figure data-type="image" tabindex="9"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMTE1Mzk2MjEucG5n" alt="image-20200803111539621" loading="lazy"></figure>
<h3 id="102-动态代理">10.2、动态代理</h3>
<p>动态代理和静态角色一样，动态代理底层是反射机制</p>
<p>动态代理类是动态生成的，不是我们直接写好的！</p>
<p>动态代理(两大类)：基于接口，基于类</p>
<ul>
<li>基于接口：JDK的动态代理【使用ing】</li>
<li>基于类：cglib</li>
<li>java字节码实现：javasisit</li>
</ul>
<p>了解两个类<br>
1、Proxy：代理<br>
2、InvocationHandler：调用处理程序<br>
<img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMTI2MTk4NjgucG5n" alt="image-20200803112619868" loading="lazy"></p>
<p>实例：</p>
<p>接口 Host.java</p>
<pre><code class="language-java">//接口
package pojo2;
public interface Host {
	public void rent();
	
}
</code></pre>
<p>接口Host实现类 HostMaster.java</p>
<pre><code class="language-java">//接口实现类
package pojo2;
public class HostMaster implements Host{	
	public void rent() {
		System.out.println(&quot;房东要租房子&quot;);
	}
}
</code></pre>
<p>代理角色的处理程序类 ProxyInvocationHandler.java</p>
<pre><code class="language-java">package pojo2;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

///用这个类，自动生成代理
public class ProxyInvocationHandler implements InvocationHandler {

	// Foo f =(Foo) Proxy.NewProxyInstance(Foo. Class.GetClassLoader(),
	// new Class&lt;?&gt;[] { Foo.Class },
	// handler);

	// 被代理的接口
	public HostMaster hostMaster ;
	
	public void setHostMaster(HostMaster hostMaster) {
		this.hostMaster = hostMaster;
	}

	// 得到生成的代理类 
	public Object getProxy() {
		// newProxyInstance() -&gt; 生成代理对象，就不用再写具体的代理类了
		// this.getClass().getClassLoader() -&gt; 找到加载类的位置
		// hostMaster.getClass().getInterfaces() -&gt; 代理的具体接口
		// this -&gt; 代表了接口InvocationHandler的实现类ProxyInvocationHandler
		return Proxy.newProxyInstance(this.getClass().getClassLoader(), hostMaster.getClass().getInterfaces(), this);


	// 处理代理实例并返回结果
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		seeHouse();
		// 动态代理的本质，就是使用反射机制实现的
        // invoke()执行它真正要执行的方法
		Object result = method.invoke(hostMaster, args);
		fee();
		return result;
	}

	public void seeHouse() {
		System.out.println(&quot;看房子&quot;);
	}

	public void fee() {
		System.out.println(&quot;收中介费&quot;);
	}

}

</code></pre>
<p>用户类 My2.java</p>
<pre><code class="language-java">package holle4_proxy;

import pojo2.Host;
import pojo2.Host2;
import pojo2.HostMaster;
import pojo2.ProxyInvocationHandler;

public class My2 {

	public static void main(String[] args) {
        
		//真实角色
		HostMaster hostMaster = new HostMaster();
        
		//代理角色，现在没有；用代理角色的处理程序来实现Host接口的调用
		ProxyInvocationHandler pih = new ProxyInvocationHandler();
        
        //pih -&gt; HostMaster接口类 -&gt; Host接口
		pih.setHostMaster(hostMaster);
        
		//获取newProxyInstance动态生成代理类
		Host proxy = (Host) pih.getProxy();
		
		proxy.rent();

	}
}
</code></pre>
<p>弹幕评论：<br>
什么时候调用invoke方法的?<br>
代理实例调用方法时invoke方法就会被调用，可以debug试试</p>
<p>改为<strong>万能代理类</strong></p>
<pre><code class="language-java">///用这个类，自动生代理
public class ProxyInvocationHandler implements InvocationHandler {

	// 被代理的接口
	public Object target;

	public void setTarget(Object target) {
		this.target = target;
	}

	// 得到生成的代理类 -&gt; 固定的代码
	public Object getProxy() {
		return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
	}

	// 处理代理实例并返回结果
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		// 动态代理的本质，就是使用反射机制实现的
		// invoke()执行它真正要执行的方法
		Object result = method.invoke(target, args);
		return result;
	}

}
</code></pre>
<figure data-type="image" tabindex="10"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMzMwMzU0ODQlMjAtJTIwJUU1JThBJUE4JUU2JTgwJTgxJUU0JUJCJUEzJUU3JTkwJTg2LnBuZw" alt="image-20200803133035484" loading="lazy"></figure>
<h2 id="11-aop">11、AOP</h2>
<h3 id="111-什么是aop">11.1、什么是AOP</h3>
<figure data-type="image" tabindex="11"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMzQ1MDIxNjklMjAtJTIwQU9QLnBuZw" alt="image-20200803134502169" loading="lazy"></figure>
<h3 id="112-aop在spring中的使用">11.2、AOP在Spring中的使用</h3>
<p>提供声明式事务，允许用户自定义切面</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等…</li>
<li>切面(Aspect)：横切关注点 被模块化的特殊对象。即，它是一个类。（Log类）</li>
<li>通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。（Log类中的方法）</li>
<li>目标(Target)：被通知对象。（生成的代理类)</li>
<li>代理(Proxy)：向目标对象应用通知之后创建的对象。（生成的代理类）</li>
<li>切入点(PointCut)：切面通知执行的”地点”的定义。（最后两点：在哪个地方执行，比如：method.invoke()）</li>
<li>连接点(JointPoint)：与切入点匹配的执行点。</li>
</ul>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxNTQwNDM5MDkucG5n" alt="image-20200803154043909" loading="lazy"><br>
SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxMzU5Mzc0MzUucG5n" alt="image-20200803135937435" loading="lazy"><br>
<strong>即AOP在不改变原有代码的情况下，去增加新的功能。</strong>（代理）</p>
<h3 id="113-使用spring实现aop">11.3、使用Spring实现AOP</h3>
<p>导入jar包</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="1131-方法一使用原生spring接口">11.3.1、方法一：使用原生spring接口</h4>
<p>springAPI接口实现</p>
<p>applicationContext.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!--注册bean--&gt;
    &lt;bean id=&quot;userservice&quot; class=&quot;service.UserServiceImpl&quot;/&gt;
    &lt;bean id=&quot;log&quot; class=&quot;log.Log&quot;/&gt;
    &lt;bean id=&quot;afterLog&quot; class=&quot;log.AfterLog&quot;/&gt;
	&lt;!--方式一，使用原生Spring API接口--&gt;
    &lt;!--配置aop,还需要导入aop约束--&gt;
    &lt;aop:config&gt;
        &lt;!--切入点：expression:表达式，execution（要执行的位置）--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt;
        &lt;!--UserServiceImpl.*(..) -》 UserServiceImpl类下的所以方法(参数)--&gt;
        &lt;!--执行环绕增加--&gt;
        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;!-- 环绕,在id=&quot;pointcut&quot;的前后切入 --&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>execution(返回类型，类名，方法名(参数)) -&gt; execution(* com.service.<em>,</em>(…))</p>
<p>UserService.java</p>
<pre><code class="language-java">package service;
public interface UserService {   
	    public void add() ;
	    public void delete() ;
	    public void query() ;
	    public void update();
}
</code></pre>
<p>UserService 的实现类 UserServiceImp.java</p>
<pre><code class="language-java">package service;

public class UserServiceImpl implements UserService {

    public void add() {
        System.out.println(&quot;add增&quot;);
    }
    public void delete() {
        System.out.println(&quot;delete删&quot;);
    }
    public void update() {
        System.out.println(&quot;update改&quot;);
    }
    public void query() {
        System.out.println(&quot;query查&quot;);
    }
}
</code></pre>
<p>前置Log.java</p>
<pre><code class="language-java">package log;
import org.springframework.aop.MethodBeforeAdvice;
import java.lang.reflect.Method;

public class Log implements MethodBeforeAdvice {
    //method：要执行的目标对象的方法
    //args：参数
    //target：目标对象
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println(target.getClass().getName()+&quot;的&quot;+method.getName()+&quot;被执行了&quot;);
    }
}
</code></pre>
<p>后置AfterLog.java</p>
<pre><code class="language-java">package log;
import java.lang.reflect.Method;
import org.springframework.aop.AfterReturningAdvice;

public class AfterLog implements AfterReturningAdvice {
    //returnVaule: 返回值
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
    	System.out.println(&quot;执行了&quot;+method.getName()+&quot;方法，返回值是&quot;+returnValue);
    }
}
</code></pre>
<p>测试类MyTest5</p>
<pre><code class="language-java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import service.UserService;

public class MyTest5 {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //注意:动态代理代理的是接口
        UserService userService = (UserService) context.getBean(&quot;userservice&quot;);
        userService.add();
    }
}
</code></pre>
<h4 id="1132-方法二自定义类实现aop">11.3.2、方法二：自定义类实现AOP</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
   	https://www.springframework.org/schema/beans/spring-beans.xsd
   	http://www.springframework.org/schema/aop
   	https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

   &lt;!--注册bean--&gt;
   &lt;bean id=&quot;userservice&quot; class=&quot;service.UserServiceImpl&quot;/&gt;
   &lt;bean id=&quot;log&quot; class=&quot;log.Log&quot;/&gt;
   &lt;bean id=&quot;afterLog&quot; class=&quot;log.AfterLog&quot;/&gt;
   &lt;!-- 方式二，自定义 --&gt;
   &lt;bean id=&quot;diy&quot; class=&quot;diy.DiyPointcut&quot;/&gt;
   &lt;aop:config&gt;
       &lt;!--自定义切面--&gt;
       &lt;aop:aspect ref=&quot;diy&quot;&gt;
           &lt;!--切入点--&gt;
           &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* service.UserServiceImpl.*(..))&quot;/&gt;
           &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;
           &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;
       &lt;/aop:aspect&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">package diy;
public class DiyPointcut {

    public void before(){
        System.out.println(&quot;插入到前面&quot;);
    }

    public void after(){
        System.out.println(&quot;插入到后面&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//测试
public class MyTest5 {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //注意:动态代理代理的是接口
        UserService userService = (UserService) context.getBean(&quot;userservice&quot;);
        userService.add();
    }
}
</code></pre>
<h4 id="1133-方法三使用注解实现">11.3.3、方法三：使用注解实现</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
	
    &lt;!-- 注册 --&gt;
    &lt;bean id=&quot;userservice&quot; class=&quot;service.UserServiceImpl&quot;/&gt;
    &lt;!--方式三，使用注解实现--&gt;
    &lt;bean id=&quot;diyAnnotation&quot; class=&quot;diy.DiyAnnotation&quot;&gt;&lt;/bean&gt;
    
    &lt;!-- 开启自动代理 
		实现方式：默认JDK (proxy-targer-class=&quot;fasle&quot;)
    			 cgbin (proxy-targer-class=&quot;true&quot;)--&gt;
	&lt;aop:aspectj-autoproxy/&gt;
    
&lt;/beans&gt;
</code></pre>
<p>DiyAnnotation.java</p>
<pre><code class="language-java">package diy;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect  //标注这个类是一个切面
public class DiyAnnotation {
	
    @Before(&quot;execution(* service.UserServiceImpl.*(..))&quot;)
    public void before(){
        System.out.println(&quot;=====方法执行前=====&quot;);
    }

    @After(&quot;execution(* service.UserServiceImpl.*(..))&quot;)
    public void after(){
        System.out.println(&quot;=====方法执行后=====&quot;);
    }

    //在环绕增强中，我们可以给地暖管一个参数，代表我们要获取切入的点
    @Around(&quot;execution(* service.UserServiceImpl.*(..))&quot;)
    public void around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;环绕前&quot;);

        Object proceed = joinPoint.proceed();

        System.out.println(&quot;环绕后&quot;);
    }
}
</code></pre>
<p>测试</p>
<pre><code class="language-java">public class MyTest5 {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //注意:动态代理代理的是接口
        UserService userService = (UserService) context.getBean(&quot;userservice&quot;);
        userService.add();
    }
}
</code></pre>
<p>输出结果：</p>
<figure data-type="image" tabindex="12"><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDMxNzU2NDIwNjQucG5n" alt="image-20200803175642064" loading="lazy"></figure>
<h2 id="12-整合mybatis">12、整合mybatis</h2>
<p>mybatis-spring官网：https://mybatis.org/spring/zh/</p>
<p><strong>mybatis的配置流程：</strong></p>
<ol>
<li>编写实体类</li>
<li>编写核心配置文件</li>
<li>编写接口</li>
<li>编写Mapper.xmi</li>
<li>测试</li>
</ol>
<h3 id="121-mybatis-spring-方式一">12.1、mybatis-spring-方式一</h3>
<ol>
<li>编写数据源配置</li>
<li>sqISessionFactory</li>
<li>sqISessionTemplate（相当于sqISession）</li>
<li>需要给接口加实现类【new】</li>
<li>将自己写的实现类，注入到Spring中</li>
<li>测试！</li>
</ol>
<p>先导入jar包</p>
<pre><code class="language-xml">&lt;dependencies&gt;

    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.9.4&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.2&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.4&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.12&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.12&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
	
&lt;!--在build中配置resources，来防止资源导出失败的问题--&gt;
&lt;!-- Maven解决静态资源过滤问题 --&gt;
&lt;build&gt;
&lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.properties&lt;/include&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.properties&lt;/include&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
    &lt;/resource&gt;
&lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<p><img src="Spring5%E8%AF%BE%E5%A0%82%E7%AC%94.assets/aHR0cHM6Ly9naXRlZS5jb20vd29fYmVsbC9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvaW1hZ2UvaW1hZ2UtMjAyMDA4MDQxMjMyMTA1NjAucG5n" alt="文件路径" loading="lazy"><br>
<strong>编写顺序：</strong><br>
<strong>User -&gt; UserMapper -&gt; UserMapper.xml -&gt; spring-dao.xml -&gt; UserServiceImpl -&gt; applicationContext.xml -&gt; MyTest6</strong></p>
<p><strong>代码步骤：</strong></p>
<p>pojo实体类 User</p>
<pre><code class="language-java">package pojo;
import lombok.Data;
@Data
public class User {
	private int id;
	private String name;
	private String pwd;
}
</code></pre>
<p>mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml</p>
<p>接口UserMapper</p>
<pre><code class="language-java">package mapper;
import java.util.List;
import pojo.User;
public interface UserMapper {
	public List&lt;User&gt; getUser();
}
</code></pre>
<p>UserMapperImpl</p>
<pre><code class="language-java">package mapper;
import java.util.List;
import org.mybatis.spring.SqlSessionTemplate;
import pojo.User;

public class UserMapperImpl implements UserMapper{
	
	//我们的所有操作，在原来都使用sqlSession来执行，现在都使用SqlSessionTemplate；
	private SqlSessionTemplate sqlSessionTemplate;

	public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {
		this.sqlSessionTemplate = sqlSessionTemplate;
	}

	public List&lt;User&gt; getUser() {
		UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class);
		return mapper.getUser();
	}
}
</code></pre>
<p>UserMapper.xml （狂神给面子才留下来的）</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        
&lt;!-- 绑定接口 --&gt;
&lt;mapper namespace=&quot;mapper.UserMapper&quot;&gt;
	&lt;select id=&quot;getUser&quot; resultType=&quot;pojo.User&quot;&gt;
		select * from mybatis.mybatis
	&lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml</p>
<p>mybatis-config.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
	&lt;!--开启日志--&gt;
	&lt;settings&gt;
		&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;
	&lt;/settings&gt;
	
	&lt;!--可以给实体类起别名 --&gt;
	&lt;typeAliases&gt; 
		&lt;package name=&quot;pojo&quot; /&gt;
	&lt;/typeAliases&gt;

&lt;/configuration&gt;
</code></pre>
<p>spring-dao.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
		
	&lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 
		这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt;
	&lt;!--data source --&gt;
	&lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
		&lt;property name=&quot;driverClassName&quot;
			value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;
		&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
		&lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
		&lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
	&lt;/bean&gt;
	
	&lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt;
        &lt;!--绑定 mybatis 配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;
    &lt;/bean&gt;

	&lt;!-- sqlSessionTemplate 就是之前使用的：sqlsession --&gt;
    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
    	&lt;!-- 只能使用构造器注入sqlSessionFactory 原因：它没有set方法--&gt;	
        &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt;
    &lt;/bean&gt;
		
&lt;/beans&gt;
</code></pre>
<p>applicationContext.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
    
	&lt;!-- 导入spring-dao.xml --&gt;
	&lt;import resource=&quot;spring-dao.xml&quot;/&gt;
	
    &lt;bean id=&quot;userMapper&quot; class=&quot;mapper.UserMapperImpl&quot;&gt;
        &lt;property name=&quot;sqlSessionTemplate&quot; ref=&quot;sqlSession&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试类</p>
<pre><code class="language-java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import mapper.UserMapper;
import pojo.User;
public class MyTest6 {
	public static void main(String[] args) {
        
		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
		
		UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;);
		
		for (User user : userMapper.getUser()) {
			System.out.println(user);
		}
	}
}
</code></pre>
<h3 id="122-mybatis-spring-方式二">12.2、mybatis-spring-方式二</h3>
<p>UserServiceImpl2</p>
<pre><code class="language-java">package mapper;
import pojo.User;
import org.apache.ibatis.session.SqlSession;
import org.mybatis.spring.support.SqlSessionDaoSupport;
import java.util.List;
//继承SqlSessionDaoSupport 类
public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper {
    public List&lt;User&gt; getUser() {
        SqlSession sqlSession = getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.getUser();
        //或者一句话：return getSqlSession().getMapper(UserMapper.class).getUser();
    }
}
</code></pre>
<p>spring-dao.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
		
	&lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 c3p0 dbcp druid 
		这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt;
	&lt;!--data source --&gt;
	&lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
		&lt;property name=&quot;driverClassName&quot;
			value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;
		&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
		&lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
		&lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
	&lt;/bean&gt;
	
	&lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt;
        &lt;!--绑定 mybatis 配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;
    &lt;/bean&gt;
    
	&lt;!-- 方法二：SqlSessionTemplate 可以不写了--&gt;
    
&lt;/beans&gt;
</code></pre>
<p>applicationContext.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

	&lt;import resource=&quot;spring-dao.xml&quot; /&gt;

	&lt;!-- 方法二 --&gt;
	&lt;bean id=&quot;userMapper2&quot; class=&quot;mapper.UserMapperImpl2&quot;&gt;
		&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="language-java">public class MyTest6 {
	public static void main(String[] args) {
		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
		UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper2&quot;);
		for (User user : userMapper.getUser()) {
			System.out.println(user);
		}
	}
}
</code></pre>
<h2 id="13-声明式事务">13. 声明式事务</h2>
<ul>
<li>把一组业务当成一个业务来做；要么都成功，要么都失败！</li>
<li>事务在项目开发中，十分的重要，涉及到数据的一致性问题</li>
<li>确保完整性和一致性</li>
</ul>
<p>事务的ACID原则：<br>
1、原子性<br>
2、隔离性<br>
3、一致性<br>
4、持久性</p>
<p>ACID参考文章：https://www.cnblogs.com/malaikuangren/archive/2012/04/06/2434760.html</p>
<p>Spring中的事务管理</p>
<ul>
<li>声明式事务：AOP</li>
<li>编程式事务：需要再代码中，进行事务管理</li>
</ul>
<p><strong>声明式事务</strong></p>
<p>先导入jar包</p>
<pre><code class="language-xml">&lt;dependencies&gt;

    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.9.4&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
        &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.5.2&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
        &lt;version&gt;2.0.4&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.12&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.12&lt;/version&gt;
    &lt;/dependency&gt;

&lt;/dependencies&gt;
	
&lt;!--在build中配置resources，来防止资源导出失败的问题--&gt;
&lt;!-- Maven解决静态资源过滤问题 --&gt;
&lt;build&gt;
&lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/java&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.properties&lt;/include&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
    &lt;/resource&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
        &lt;includes&gt;
            &lt;include&gt;**/*.properties&lt;/include&gt;
            &lt;include&gt;**/*.xml&lt;/include&gt;
        &lt;/includes&gt;
        &lt;filtering&gt;false&lt;/filtering&gt;
    &lt;/resource&gt;
&lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<p><strong>代码步骤：</strong></p>
<p>pojo实体类 User</p>
<pre><code class="language-java">package pojo;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
	private int id;
	private String name;
	private String pwd;
}
</code></pre>
<p>mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml</p>
<p>接口UserMapper</p>
<pre><code class="language-java">package mapper;
import java.util.List;
import org.apache.ibatis.annotations.Param;
import pojo.User;

public interface UserMapper {
	public List&lt;User&gt; getUser();
	
	public int insertUser(User user); 
	
	public int delUser(@Param(&quot;id&quot;) int id); 
}
</code></pre>
<p>UserMapperImpl</p>
<pre><code class="language-java">package mapper;

import pojo.User;
import org.apache.ibatis.session.SqlSession;
import org.mybatis.spring.support.SqlSessionDaoSupport;
import java.util.List;

public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper {
    public List&lt;User&gt; getUser() {
    	User user = new User(5,&quot;你好&quot;,&quot;ok&quot;);
    	insertUser(user);
    	delUser(5);
        SqlSession sqlSession = getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        return mapper.getUser();
        //或者return  getSqlSession().getMapper(UserMapper.class).getUser();
    }
    //插入
	public int insertUser(User user) {
		return getSqlSession().getMapper(UserMapper.class).insertUser(user);
	}
	//删除
	public int delUser(int id) {
		return getSqlSession().getMapper(UserMapper.class).delUser(id);
	}
}
</code></pre>
<p>UserMapper.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        
&lt;!-- 绑定接口 --&gt;
&lt;mapper namespace=&quot;mapper.UserMapper&quot;&gt;
	&lt;select id=&quot;getUser&quot; resultType=&quot;pojo.User&quot;&gt;
		select * from mybatis.mybatis
	&lt;/select&gt;
	
	&lt;insert id=&quot;insertUser&quot;  parameterType=&quot;pojo.User&quot; &gt;
		insert into  mybatis.mybatis (id,name,pwd) values (#{id},#{name},#{pwd})
	&lt;/insert&gt;
	
	&lt;delete id=&quot;delUser&quot; parameterType=&quot;_int&quot;&gt;
		deleteAAAAA from mybatis.mybatis where id = #{id}
		&lt;!-- deleteAAAAA是故意写错的 --&gt;
	&lt;/delete&gt;

&lt;/mapper&gt;
</code></pre>
<p>resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml</p>
<p>mybatis-config.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;!-- configuration --&gt;
&lt;configuration&gt;
	
	&lt;!--开启日志--&gt;
	&lt;settings&gt;
		&lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot; /&gt;
	&lt;/settings&gt;
	
	&lt;!--可以给实体类起别名--&gt;
	&lt;typeAliases&gt; 
		&lt;package name=&quot;pojo&quot; /&gt;
	&lt;/typeAliases&gt;

&lt;/configuration&gt;
</code></pre>
<p>spring-dao.xml（已导入约束）</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
		
	&lt;!--data source --&gt;
	&lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
		&lt;property name=&quot;driverClassName&quot;
			value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;
		&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;
		&lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
		&lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
	&lt;/bean&gt;
	
	&lt;!--sqlSessionFactory--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt;
        &lt;!--绑定 mybatis 配置文件--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;
    &lt;/bean&gt;
	
	&lt;!--声明式事务--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;constructor-arg ref=&quot;datasource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--结合aop实现事务织入--&gt;
    &lt;!--配置事务的通知类--&gt;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;!--给哪些方法配置事务--&gt;
        &lt;!--新东西：配置事务的传播特性 propagation--&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;query&quot; read-only=&quot;true&quot;/&gt;
            &lt;!-- *号包含上面4个方法：
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; --&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;

    &lt;!--配置事务切入--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txpointcut&quot; expression=&quot;execution(* mapper.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txpointcut&quot;/&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>applicationContext.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/aop
		https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

	&lt;import resource=&quot;spring-dao.xml&quot; /&gt;

	&lt;bean id=&quot;userMapper&quot; class=&quot;mapper.UserMapperImpl&quot;&gt;
		&lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;
	&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>测试类</p>
<pre><code class="language-java">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import mapper.UserMapper;import pojo.User;
public class MyTest7 {
	public static void main(String[] args) {

		ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
		
		UserMapper userMapper = (UserMapper) context.getBean(&quot;userMapper&quot;);
		
		for (User user : userMapper.getUser()) {
			System.out.println(user);
		}
	}
}
</code></pre>
<p><strong>思考：</strong><br>
为什么需要事务？</p>
<ul>
<li>如果不配置事务，可能存在数据提交不一致的情况下；</li>
<li>如果不在spring中去配置声明式事务，我们就需要在代码中手动配置事务！</li>
<li>事务在项目的开发中非常重要，涉及到数据的一致性和完整性问题！</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lombook]]></title>
        <id>https://aruul.github.io/post/iJ3Ze3gYo/</id>
        <link href="https://aruul.github.io/post/iJ3Ze3gYo/">
        </link>
        <updated>2021-03-17T08:24:24.000Z</updated>
        <content type="html"><![CDATA[<p>使用步骤</p>
<ol>
<li>
<p>在idea中装Lombok插件</p>
</li>
<li>
<p>导入jar包</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.10&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>3.使用注解</p>
<hr>
<h2 id="有哪些注解">有哪些注解？</h2>
<ul>
<li>@Data</li>
<li>@Setter</li>
<li>@Getter</li>
<li>@Log4j</li>
<li>@AllArgsConstructor</li>
<li>@NoArgsConstructor</li>
<li>@EqualsAndHashCode</li>
<li>@NonNull</li>
<li>@Cleanup</li>
<li>@ToString</li>
<li>@RequiredArgsConstructor</li>
<li>@Value</li>
<li>@SneakyThrows</li>
<li>@Synchronized</li>
</ul>
<h2 id="注解详解">注解详解</h2>
<p><strong>@Data</strong></p>
<p>注解在 <strong>类</strong> 上；提供类所有属性的 get 和 set 方法，此外还提供了equals、canEqual、hashCode、toString 方法。</p>
<figure data-type="image" tabindex="1"><img src="https://pic4.zhimg.com/80/v2-9b36bb6fd37372cee213b118d7e26c7b_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Setter</strong></p>
<p>注解在 <strong>属性</strong> 上；为单个属性提供 set 方法; 注解在 <strong>类</strong> 上，为该类所有的属性提供 set 方法， 都提供默认构造方法。</p>
<figure data-type="image" tabindex="2"><img src="https://pic2.zhimg.com/80/v2-12139fea446022a1986ba2042f886a7d_720w.jpg" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://pic3.zhimg.com/80/v2-994e89f3c9c6976b05e345fcd0848692_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Getter</strong></p>
<p>注解在 <strong>属性</strong> 上；为单个属性提供 get 方法; 注解在 <strong>类</strong> 上，为该类所有的属性提供 get 方法，都提供默认构造方法。</p>
<figure data-type="image" tabindex="4"><img src="https://pic3.zhimg.com/80/v2-18149a8d23a4e3673b9441b198a1f976_720w.jpg" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://pic4.zhimg.com/80/v2-2cb156b6d93198d271f2ff4bca1c21ff_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Log4j</strong></p>
<p>注解在 <strong>类</strong> 上；为类提供一个 属性名为 log 的 log4j 日志对象，提供默认构造方法。</p>
<figure data-type="image" tabindex="6"><img src="https://pic1.zhimg.com/80/v2-ce28a344baae222aa0c4ea0b84461000_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@AllArgsConstructor</strong></p>
<p>注解在 <strong>类</strong> 上；为类提供一个全参的构造方法，加了这个注解后，类中不提供默认构造方法了。</p>
<figure data-type="image" tabindex="7"><img src="https://pic4.zhimg.com/80/v2-31bca5c4da7e9c475bade1eaa400802f_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@NoArgsConstructor</strong></p>
<p>注解在 <strong>类</strong> 上；为类提供一个无参的构造方法。</p>
<figure data-type="image" tabindex="8"><img src="https://pic2.zhimg.com/80/v2-518a849c9d5fffde690b2a801e951275_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@EqualsAndHashCode</strong></p>
<p>注解在 <strong>类</strong> 上, 可以生成 equals、canEqual、hashCode 方法。</p>
<figure data-type="image" tabindex="9"><img src="https://pic1.zhimg.com/80/v2-6bddfeaa77e8dd29b05bb8b499da65f4_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@NonNull</strong></p>
<p>注解在 <strong>属性</strong> 上，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，也会有一个默认的无参构造方法。</p>
<figure data-type="image" tabindex="10"><img src="https://pic2.zhimg.com/80/v2-268671034ed3141e117c99f055a3f2ad_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Cleanup</strong></p>
<p>这个注解用在 <strong>变量</strong> 前面，可以保证此变量代表的资源会被自动关闭，默认是调用资源的 close() 方法，如果该资源有其它关闭方法，可使用 @Cleanup(“methodName”) 来指定要调用的方法，也会生成默认的构造方法</p>
<figure data-type="image" tabindex="11"><img src="https://pic3.zhimg.com/80/v2-6408e68a5f77eba5add53abe3ee8abf2_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@ToString</strong></p>
<p>这个注解用在 <strong>类</strong> 上，可以生成所有参数的 toString 方法，还会生成默认的构造方法。</p>
<figure data-type="image" tabindex="12"><img src="https://pic1.zhimg.com/80/v2-28b29cc1b5940f31de246e719cfcd9e8_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@RequiredArgsConstructor</strong></p>
<p>这个注解用在 <strong>类</strong> 上，使用类中所有带有 @NonNull 注解的或者带有 final 修饰的成员变量生成对应的构造方法。</p>
<figure data-type="image" tabindex="13"><img src="https://pic3.zhimg.com/80/v2-866a42cd03707c5095b44721be5e17ba_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Value</strong></p>
<p>这个注解用在 <strong>类</strong> 上，会生成含所有参数的构造方法，get 方法，此外还提供了equals、hashCode、toString 方法。</p>
<figure data-type="image" tabindex="14"><img src="https://pic1.zhimg.com/80/v2-159c62a7a9f545505246939abe6cfcc0_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@SneakyThrows</strong></p>
<p>这个注解用在 <strong>方法</strong> 上，可以将方法中的代码用 try-catch 语句包裹起来，捕获异常并在 catch 中用 Lombok.sneakyThrow(e) 把异常抛出，可以使用 @SneakyThrows(Exception.class) 的形式指定抛出哪种异常，也会生成默认的构造方法。</p>
<figure data-type="image" tabindex="15"><img src="https://pic3.zhimg.com/80/v2-2cd23582188406e3301a318d37bfa426_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Synchronized</strong></p>
<p>这个注解用在 <strong>类方法</strong> 或者 <strong>实例方法</strong> 上，效果和 synchronized 关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized 关键字的锁对象分别是类的 class 对象和 this 对象，而 @Synchronized 的锁对象分别是 私有静态 final 对象 lock 和 私有 final 对象 lock，当然，也可以自己指定锁对象，此外也提供默认的构造方法。</p>
<figure data-type="image" tabindex="16"><img src="https://pic4.zhimg.com/80/v2-7f38c354c3ca8ba9205ecbcaae04d1d3_720w.jpg" alt="img" loading="lazy"></figure>
</li>
</ol>
]]></content>
    </entry>
</feed>