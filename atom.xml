<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aruul.github.io</id>
    <title>aRuul的无名小站</title>
    <updated>2021-04-11T03:04:32.624Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aruul.github.io"/>
    <link rel="self" href="https://aruul.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aruul.github.io/images/avatar.png</logo>
    <icon>https://aruul.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, aRuul的无名小站</rights>
    <entry>
        <title type="html"><![CDATA[新的开始]]></title>
        <id>https://aruul.github.io/post/newbegain/</id>
        <link href="https://aruul.github.io/post/newbegain/">
        </link>
        <updated>2021-04-11T01:41:56.000Z</updated>
        <content type="html"><![CDATA[<p>今天开始使用Gridea写博客辣！<br>
之前的博客会陆续补上来的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[安卓学习笔记(1)]]></title>
        <id>https://aruul.github.io/post/fo392kjus/</id>
        <link href="https://aruul.github.io/post/fo392kjus/">
        </link>
        <updated>2020-12-21T13:35:31.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="事件处理">事件处理</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="事件处理">事件处理</h1>
<!--more-->
<h2 id="1直接在xml文件里设置androidonclick">1.直接在xml文件里设置android:onClick</h2>
<pre><code class="language-java">&lt;Button
    android:id=&quot;@+id/btn_sure&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;sure&quot;
    android:onClick=&quot;onCheckBoxClicked&quot;&gt;&lt;/Button&gt;
</code></pre>
<pre><code class="language-java">public void onCheckBoxClicked(View view){
    //事件的响应代码
}
</code></pre>
<h2 id="2在java文件中实现viewonclicklistener接口">2.在java文件中实现View.OnClickListener接口</h2>
<pre><code class="language-java">btn=findViewById(R.id.ok);
//为btn添加事件监听，是下面自定义的实现View.OnClickListener的mClick内部类
btn.setOnClickListener(new mClick());

class mClick implements View.OnClickListener{

    @Override
    public void onClick(View v) {
        //事件的响应代码
    }
}
</code></pre>
<h2 id="3使用匿名类推荐">3.使用匿名类（推荐）</h2>
<pre><code class="language-java">Button button=findViewBuId(R.id.btn_sure)
button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        //事件的响应代码
    }
});
</code></pre>
<h1 id="fragment">Fragment</h1>
<h2 id="fragment动态添加">Fragment动态添加</h2>
<p>​     例如向<strong>activity_main.xml</strong>中动态添加、删除<code>Fragment</code></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;LinearLayout
        android:id=&quot;@+id/minPhoto&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:orientation=&quot;vertical&quot;&gt;
    &lt;/LinearLayout&gt;

    &lt;Button
        android:id=&quot;@+id/btn_remove&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;remove&quot;&gt;&lt;/Button&gt;

&lt;/LinearLayout&gt;
</code></pre>
<p>​     假设Fragment文件是PhotoFragment.java;那么在mainActivity.java文件中,</p>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity {

    Button button;
    Fragment minPhoto=new MinPhotoFragment();
    Fragment textFragment=new TextFragment();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
		//动态添加Fragment
        //获取当前Activity的FragmentManager对象
        FragmentManager fragmentManager=getSupportFragmentManager();
        //开启事务
        FragmentTransaction transaction=fragmentManager.beginTransaction();
        //添加Fragment，第一个参数是要被添加Fragment的视图布局的id，
        //             第二个参数是要添加进去的Fragment对应的java类名字
        transaction.add(R.id.minPhoto,minPhoto);
        transaction.add(R.id.minPhoto,textFragment);
        transaction.commit();
        
        
        //点击按钮去除Fragment
        button=findViewById(R.id.btn_remove);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //获取当前Activity的FragmentManager对象
                FragmentManager fragmentManager=getSupportFragmentManager();
                //开启事务
                FragmentTransaction transaction=fragmentManager.beginTransaction();
                //去除Fragment     参数为要去除的Fragment的java类名
                transaction.remove(textFragment);
                transaction.commit();
            }
        });
    }
}
</code></pre>
<h1 id="fragment间的通信">Fragment间的通信</h1>
<p><mark>1.Fragment中定义接口</mark></p>
<p><mark>2.Fragment中初始化接口，并设置这个接口的set方法</mark></p>
<p><mark>3.Activity中实现这个接口</mark></p>
<p><mark>4.Fragment的onActivityCreated回调方法中添加控件监听，事件处理环节调用接口，具体操作由Activity进行</mark></p>
<p><mark>5.Activity中的onAttach方法中，调用Fragment设置接口的方法，将自身引用传入</mark></p>
<p>下面举个作业中例子：点击小图显示对应的大图</p>
<img src="D:\孺\乱七八糟的笔记\photo\安卓fragment事件.png" alt="安卓fragment事件" style="zoom:75%;" />
<pre><code class="language-java">//Fragment类文件代码
public class MinPhotoFragment extends Fragment {
    
  // 1.Fragment中定义接口
    public interface ImgClick{
        public void onImgClickListener(ImageView imageView);
    }
  
  //2.Fragment中初始化接口，并设置这个接口的set方法
    ImgClick imgClick;
    public void setImgClick(ImgClick imgClick){
        this.imgClick=imgClick;
    }
    
    ....其他代码省略...

}
</code></pre>
<pre><code class="language-java">public class MainActivity extends AppCompatActivity implements MinPhotoFragment.ImgClick{

//3.Activity中实现这个接口
	public void onImgClickListener(ImageView imageView) {
        maxImg.setImageDrawable(imageView.getDrawable());
    }
}
</code></pre>
<pre><code class="language-java">//4.在Fragment的onActivityCreated回调方法中添加监听，事件处理环节调用接口，具体操作由Activity进行
@Override
public void onActivityCreated(@Nullable Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    for(int i=0;i&lt;img.length;i++) {
        ImageView image = (ImageView) this.getActivity().findViewById(img[i]);
        image.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                imgClick.onImgClickListener((ImageView)v);
            }
        });
    }
}
</code></pre>
<pre><code class="language-java">//5.Activity中的onAttachFragment方法中，调用Fragment设置接口的方法，将自身引用传入
@Override
public void onAttachFragment(@NonNull Fragment fragment) {
    super.onAttachFragment(fragment);
    if(fragment instanceof  MinPhotoFragment){  //判断fragment是否为目标Fragment
        MinPhotoFragment minPhotoFragment=(MinPhotoFragment)fragment;
        minPhotoFragment.setImgClick(this);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css学习笔记]]></title>
        <id>https://aruul.github.io/post/vYl9x4xMO/</id>
        <link href="https://aruul.github.io/post/vYl9x4xMO/">
        </link>
        <updated>2020-10-06T12:42:01.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<h3 id="css选择器">css选择器</h3>
<table>
<thead>
<tr>
<th>选择器名称</th>
<th>选择的内容</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素选择器（也称作标签或类型选择器）</td>
<td>所有指定(该)类型的 HTML 元素</td>
<td><code>p</code> 选择 <code>&lt;p&gt;</code></td>
</tr>
<tr>
<td>ID 选择器</td>
<td>具有特定 ID 的元素（单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID）</td>
<td><code>#my-id</code> 选择 <code>&lt;p id=&quot;my-id&quot;&gt;</code> 或 <code>&lt;a id=&quot;my-id&quot;&gt;</code></td>
</tr>
<tr>
<td>类选择器</td>
<td>具有特定类的元素（单一页面中，一个类可以有多个实例）</td>
<td><code>.my-class</code> 选择 <code>&lt;p class=&quot;my-class&quot;&gt;</code> 和 <code>&lt;a class=&quot;my-class&quot;&gt;</code></td>
</tr>
<tr>
<td>属性选择器</td>
<td>拥有特定属性的元素</td>
<td><code>img[src]</code> 选择 <code>&lt;img src=&quot;myimage.png&quot;&gt;</code> 而不是 <code>&lt;img&gt;</code></td>
</tr>
<tr>
<td>伪（Pseudo）类选择器</td>
<td>特定状态下的特定元素（比如鼠标指针悬停）</td>
<td><code>a:hover</code> 仅在鼠标指针悬停在链接上时选择 <code>&lt;a&gt;</code></td>
</tr>
</tbody>
</table>
<h3 id="常见的属性">常见的属性</h3>
<ul>
<li>font-family       你想要你的文本使用的字体</li>
<li>font-size           字体大小  （px）默认16px</li>
<li>background-color    背景演示</li>
<li>color                  字体颜色</li>
<li>width                  宽度   如：width: 80%</li>
<li>margin               外边距，围绕元素外部的空间,如margin: auto</li>
<li>text-decoration: underline;           为文字添加下划线</li>
<li>letter-spacing      字母间距   单位em</li>
<li>word-spacing        词间距      单位em</li>
<li>line-heigh              行高          单位em</li>
</ul>
<h4 id="盒子模型">盒子模型</h4>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/10/06/0U0Q1g.png" alt="0U0Q1g.png" loading="lazy"></figure>
<ul>
<li>
<p>margin          外边距</p>
<p>margin-top: 5px</p>
<p>margin-bottom: 5px</p>
<p>margin-right:  10px</p>
<p>margin-left: 10px</p>
<p>上述属性可以用margin: 5px 10px 5px 10px代替，按照顺时针方向</p>
<p>上述属性还可以用margin: 5px 10px 代替  第一个值为上下属性，第二个为左右</p>
<p><strong>内边距同理</strong></p>
</li>
<li>
<p>border           边框</p>
<p>border: 5px blue solid;     设置边框线大小为5px，颜色为蓝色</p>
<p>border-radius: 15px           设置边框圆角</p>
</li>
<li>
<p>padding         内边距</p>
</li>
<li>
<p>content          内容</p>
</li>
</ul>
<p>未完待续...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[idea中导入struts2包]]></title>
        <id>https://aruul.github.io/post/Al_mw5Fbu/</id>
        <link href="https://aruul.github.io/post/Al_mw5Fbu/">
        </link>
        <updated>2020-10-05T12:40:11.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>​       好长时间没有写博客了，趁着国企期间的假期，把之前学的做个总结，国庆期间尽量多写一些。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>​       好长时间没有写博客了，趁着国企期间的假期，把之前学的做个总结，国庆期间尽量多写一些。</p>
<h2 id="-more-"><!--more--></h2>
<h3 id="正文">正文</h3>
<h5 id="1所需材料">1.所需材料</h5>
<ul>
<li>idea版本 2020.1</li>
<li>struts2 版本  （我现在用的版本是拷贝我老师的，所以不知道具体是什么版本，反正最好不要用最新版本的，有很多坑）<a href="https://aru.lanzous.com/i0bgZh7ckab">点我下载</a></li>
</ul>
<p>2.直接开始上图</p>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/10/05/0tuUBR.png" alt="0tuUBR.png" loading="lazy"></figure>
<p>按照上图顺序，选择左侧的Java Enterprise--&gt;在右侧分别勾选Web Application、Struts2--&gt;选择下方的Use library--&gt;点击Create。</p>
<hr>
<p>之后弹出如下界面，选中所需要的struts2包，点击ok</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/10/05/0tuwAx.png" alt="0tuwAx.png" loading="lazy"></figure>
<hr>
<p>创建项目完成之后，一次选择File--&gt;Project Structure，或者直接Ctrl+Shift+Alt+S，弹出如下界面。</p>
<p>选择Artifacts--&gt;展开右侧的commonTest（可能名字不一样），然后双击Struts2</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/10/05/0tuNu9.png" alt="0tuNu9.png" loading="lazy"></figure>
<hr>
<p>双击Struts2之后的效果如下所示，点击ok即可。</p>
<figure data-type="image" tabindex="4"><img src="https://s1.ax1x.com/2020/10/05/0tuaH1.png" alt="0tuaH1.png" loading="lazy"></figure>
<hr>
<p>web.xml配置如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;struts2&lt;/filter-name&gt;
          &lt;filter-class&gt;
             org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter
          &lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;struts2&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<hr>
<p>在web目录下新建index.jsp文件</p>
<pre><code class="language-html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;form action=&quot;test.action&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;userInput&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;确定&quot;&gt;
  &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<p>新建success.jsp文件</p>
<pre><code class="language-html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
welcome!
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<p>新建fail.jsp文件</p>
<pre><code class="language-html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
fail!
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<p>src文件下新建一个java package，命名为testPackage，testPackage包下新建testAction.java，内容如下</p>
<pre><code class="language-java">package testPackage;

public class testAction {
    private String userInput;
    public String getUserInput(){
        return userInput;
    }
    public void setUserInput(String userInput){
        this.userInput=userInput;
    }
    public String Result(){
        if(userInput.equals(&quot;hello&quot;)){
            return &quot;success&quot;;
        }
        return &quot;fail&quot;;
    }
}

</code></pre>
<hr>
<p>struts.xml配置如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;!DOCTYPE struts PUBLIC
        &quot;-//Apache Software Foundation//DTD Struts Configuration 2.5//EN&quot;
        &quot;http://struts.apache.org/dtds/struts-2.5.dtd&quot;&gt;

&lt;struts&gt;
    &lt;package name=&quot;test&quot; extends=&quot;struts-default&quot;&gt;
        &lt;action name=&quot;test&quot; class=&quot;testPackage.testAction&quot; method=&quot;Result&quot;&gt;
            &lt;result name=&quot;success&quot;&gt;/welcome.jsp&lt;/result&gt;
            &lt;result name=&quot;fail&quot;&gt;/fail.jsp&lt;/result&gt;
        &lt;/action&gt;
    &lt;/package&gt;
&lt;/struts&gt;
</code></pre>
<p>package name可以随意起，但不要重复； extens默认为struts-default，不要更改；</p>
<p>action name可以随意起，但不要重复； class为要用的Action的路径，这里是testPackage包下的testAction.java文件的意思，method是要用的方法。</p>
<hr>
<h4 id="点击运行就可以啦">点击运行就可以啦</h4>
<h1 id="完">完</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[模拟登陆cdut教务处(上)]]></title>
        <id>https://aruul.github.io/post/XtpV5_2y6/</id>
        <link href="https://aruul.github.io/post/XtpV5_2y6/">
        </link>
        <updated>2020-08-24T12:00:41.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>
<h4 id="前言">前言</h4>
<p>感觉学校教务处比较简单，拿来练练手</p>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>
<h4 id="前言">前言</h4>
<p>感觉学校教务处比较简单，拿来练练手</p>
<!--more-->
</li>
<li>
<h4 id="分析网页">分析网页</h4>
<p>登陆界面如下：</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://s1.ax1x.com/2020/08/24/ds9pGQ.png" alt="教务处登陆界面" title="教务处登陆界面" loading="lazy"></figure>
<p>可以看到我们学校教务处的登陆界面还是比较简单的，没有验证码之类的东西，这就减少了很多工作量。</p>
<hr>
<p>浏览器抓包：<br>
<img src="https://s1.ax1x.com/2020/08/24/dskar9.png" alt="" loading="lazy"><br>
第一个Login.html就是登陆页面，下面是几个css文件，可以忽略。主要是 md5.js这个js文件，可以知道<code>教务处的加密方式八成是md5加密</code>。</p>
<p>【md5加密：MD5是一个安全的散列算法，输入两个不同的明文不会得到相同的输出值，根据输出值，不能得到原始的明文，即其过程不可逆】</p>
<hr>
<p>输入账号密码点击登陆之后，抓包登陆成功之后的界面</p>
<figure data-type="image" tabindex="2"><img src="https://s1.ax1x.com/2020/08/24/dsty7t.jpg" alt="" loading="lazy"></figure>
<p>可以看到，抓包到的第一个就是接收登陆界面账号密码表单的页面【http://202.115.133.173:805/Common/Handler/UserLogin.ashx】 ，因为他的方法为post。 虽然我们在浏览器里登陆时只填了用户名和密码，但表单里包含的数据可不只这些。可以看到在抓包到的表单数据如下（保护个人隐私，所以图片中一些信息打码了，下面列出来的数据是我虚构的，没有任何影响，只是作为演示）</p>
<pre><code> Action: Login
 userName: 123456789789
 pwd: 723d505516e0c197e42a6be3c0af910e
 sign: 1598267074584
</code></pre>
<p>这里的    <code>userName</code>是你的学号，<code>pwd</code>是加密过后一段32位的字符串。<br>
多登陆抓包几次可以看到<code>sign</code>、<code>pwd</code>是一直在变的。<br>
初步猜测<code>sign</code>可能是时间戳。然后再百度搜一下时间戳，可以获得当前的时间戳，看到当前的时间戳前几位是跟<code>sign</code>相吻合的，后几位不吻合，再观察分析一波可以看出来<code>sign</code>是毫秒级的时间戳。</p>
<p>下面就剩下<code>pwd</code>不知道了。</p>
<hr>
<p>这时再回到我们的登陆界面</p>
<figure data-type="image" tabindex="3"><img src="https://s1.ax1x.com/2020/08/24/dskar9.png" alt="" loading="lazy"></figure>
<p>找到 <strong>LogUserManage.js?xxx=20191107</strong>  双击打开，可以看到下面的代码</p>
<pre><code class="language-javascript">//for students
function UserLogin(userName, pwd) {

    var sign = new Date().getTime();
    var user = userName.trim();
    var signedpwd = hex_md5(user + sign + hex_md5(pwd.trim()));

    var data = { Action: &quot;Login&quot;, userName: user, pwd: signedpwd, sign: sign };
    var url = &quot;/Common/Handler/UserLogin.ashx&quot;;


    $.post(url, data, function (rs) {


        if (rs == &quot;0&quot;) {

            window.location.href = &quot;/Default.aspx&quot;;
        } else {
            $(&quot;.loading&quot;).hide();
            if (rs == &quot;4&quot; || rs == &quot;2&quot; || rs == &quot;1&quot;) {
                alert(&quot;密码或者用户名错误&quot;);
            }
            else if (rs == &quot;3&quot;) {
                alert(&quot; 账户已经被锁定， 请登陆学生缴费平台核对缴费信息，完成缴费后24小时候解锁系统, 已经办理缓交手续的同学，请联系学生资助管理中心核实，电话84078912\r\n&quot;);
				
				
				window.location.href=&quot;http://wsjf.cdut.edu.cn/&quot;;
            }

        }
    });
}

//用户退出登录
function UserLoginOut() {

    var data = { Action: &quot;LoginOut&quot; };
    var url = &quot;/Common/Handler/UserLogin.ashx&quot;;
    $(&quot;.loading&quot;).show();

    $.post(url, data, function (rs) {

        if (rs == &quot;0&quot;) {

            window.location.href = &quot;/login.html&quot;;
        } else {
            //mini.alert(&quot;退出登录失败，请再试&quot;);
            window.location.href = &quot;/login.html&quot;;
            //$(&quot;.loading&quot;).hide();
        }
    });
}


//菜单操作
$(document).ready(function () {
    /*
    setTimeout(
    function () {
    
        $('*[target = &quot;main&quot;]').click(function () {
            var name = $(this).html();
            var memo = $(this).attr(&quot;memo&quot;);

            $(&quot;#FnName&quot;).html(name);
            $(&quot;#FnNotice&quot;).html(memo);
        });
    }, 500);
    */
});
</code></pre>
<p>这里面对我们有用的代码也就是第1——9行的代码，代码里很清楚的写着。</p>
<pre><code class="language-javascript">var sign = new Date().getTime();
</code></pre>
<p>可以看到sign就是登陆时的时间戳；</p>
<pre><code class="language-javascript">var signedpwd = hex_md5(user + sign + hex_md5(pwd.trim()));
</code></pre>
<p>这里signedpwd就是pwd，而hex_md5()这个函数在我们前面看到的md5.js中有，也就是标准的md5加密，将输入的字符加密成32位字符串。<br>
可以看到pwd是由【user（学号）+sign（时间戳）+由md5加密之后的密码】再经过md5加密之后得到的。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ical文件代码结构说明]]></title>
        <id>https://aruul.github.io/post/ical-wen-jian-dai-ma-jie-gou-shuo-ming/</id>
        <link href="https://aruul.github.io/post/ical-wen-jian-dai-ma-jie-gou-shuo-ming/">
        </link>
        <updated>2020-08-11T09:59:39.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言"><strong>前言</strong></h2>
<p>最近在想着把课表导入到日历里，就研究了一下ical文件</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言"><strong>前言</strong></h2>
<p>最近在想着把课表导入到日历里，就研究了一下ical文件</p>
<!--more-->
<h2 id="什么是ical文件"><strong>什么是ical文件</strong></h2>
<p>iCal 又称 iCalendar，是一种标准的互联网日历格式，让用户能够在各种计算机和各种程序之间创建和共享电子日历。<br>
一言蔽之，可以理解成可以向日历导入事件的文件。</p>
<h3 id="具体格式"><strong>具体格式</strong></h3>
<ol>
<li>
<p>ical文件以.ics结尾</p>
</li>
<li>
<p>ical文件的编写格式</p>
</li>
</ol>
<pre><code>BEGIN:VCALENDAR
VERSION:2.0
X-WR-CALNAME:北京游玩安排
X-APPLE-CALENDAR-COLOR:#540EB9
X-WR-TIMEZONE:Asia/Shanghai
BEGIN:VEVENT
UID:2020-0124-0001
DTSTART;VALUE=DATE:20200807T165000
DTEND;VALUE=DATE:20200807T165500
SUMMARY:购物
DESCRIPTION:买特产
LOCATION:王府井     
SEQUENCE:0
BEGIN:VALARM
TRIGGER;VALUE=DATE-TIME:19760401T005545Z
ACTION:NONE
END:VALARM
END:VEVENT
END:VCALENDAR
</code></pre>
<p><em><strong>为了方便理解，我将代码写出下面的格式，但是实际上，上面的代码格式是正确的</strong></em></p>
<pre><code>BEGIN:VCALENDAR               #固定写法，ical文件以BEGIN:VCALENDAR开头        
|  VERSION:2.0                #固定写法
|  X-WR-CALNAME:北京游玩安排   #日历名称
|  X-APPLE-CALENDAR-COLOR:#540EB9  #该日历事件的颜色
|  X-WR-TIMEZONE:Asia/Shanghai     #时区，中国默认写Asia/Shanghai
|  
|  BEGIN:VEVENT                                  #固定写法，表示一个日历事件的开始
|  |  UID:2020-0124-0001                         #这个日历事件的id，是唯一的，可自定义
|  |  DTSTART;VALUE=DATE:20200807T165000         #事件开始时间:年-月-日-T-时-分-秒
|  |  DTEND;VALUE=DATE:20200807T165500           #事件结束时间:年-月-日-T-时-分-秒
|  |  SUMMARY:购物                               #事件名称
|  |  DESCRIPTION:买特产                         #事件描述(备注)
|  |  LOCATION:北京王府井                        #事件地点
|  |  SEQUENCE:0                                 #固定写法
|  |  BEGIN:VALARM                               #设置闹钟提醒，这里设置的是无需闹钟提醒
|  |  |  TRIGGER;VALUE=DATE-TIME:19760401T005545Z
|  |  |  ACTION:NONE
|  |  END:VALARM
|  END:VEVENT                                    #固定写法，表示一个日历事件的结束
|
END:VCALENDAR                #固定写法，ical文件以END:VCALENDAR结尾
</code></pre>
<p>当想在一个日历中添加多个时间时，只需要在<code>BEGIN:VCALENDAR----END:VCALENDAR</code>之间按照<code>BEGIN:VEVENT----END:VEVENT</code>代码的格式添加日历事件即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用python生成ical(.ics)文件]]></title>
        <id>https://aruul.github.io/post/shi-yong-python-sheng-cheng-icalicswen-jian/</id>
        <link href="https://aruul.github.io/post/shi-yong-python-sheng-cheng-icalicswen-jian/">
        </link>
        <updated>2020-08-08T10:07:30.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>在了解了ical文件的基本结构之后，理论上是可以自己写出ical文件了。但是，如果把课程表的所有课全部一个个写出来就很不程序员，毕竟能交给电脑自动干的从不手动干。 一开始我是想着自己写一个可以批量生成ical文件的函数。写完之后感觉自己写很繁琐，不够简洁，毕竟python之蝉是这样说的：</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="前言">前言</h4>
<p>在了解了ical文件的基本结构之后，理论上是可以自己写出ical文件了。但是，如果把课程表的所有课全部一个个写出来就很不程序员，毕竟能交给电脑自动干的从不手动干。 一开始我是想着自己写一个可以批量生成ical文件的函数。写完之后感觉自己写很繁琐，不够简洁，毕竟python之蝉是这样说的：</p>
<!--more-->
<blockquote>
<p>The Zen of Python, by Tim Peters</p>
<p>Beautiful is better than ugly.<br>
Explicit is better than implicit.<br>
Simple is better than complex.<br>
Complex is better than complicated.<br>
Flat is better than nested.<br>
Sparse is better than dense.<br>
Readability counts.<br>
Special cases aren't special enough to break the rules.<br>
Although practicality beats purity.<br>
Errors should never pass silently.<br>
Unless explicitly silenced.<br>
In the face of ambiguity, refuse the temptation to guess.<br>
There should be one-- and preferably only one --obvious way to do it.<br>
Although that way may not be obvious at first unless you're Dutch.<br>
Now is better than never.<br>
Although never is often better than <em>right</em> now.<br>
If the implementation is hard to explain, it's a bad idea.<br>
If the implementation is easy to explain, it may be a good idea.<br>
Namespaces are one honking great idea -- let's do more of those!</p>
</blockquote>
<p>所以，看了好多第三方库，找到了一个感觉还行的第三方库<code>icalendar</code></p>
<h4 id="icalendar库">icalendar库</h4>
<p>唯一美中不足的是这个库的<a href="https://icalendar.readthedocs.io/en/latest/usage.html#file-structure">官方文档</a>没有中文，不过也还好理解，比较简单。<br>
<strong>首先下载该库</strong></p>
<pre><code class="language-python">    pip install icalendar
</code></pre>
<p><strong>引入</strong></p>
<pre><code class="language-python">    from icalendar import Calendar, Event,Alarm
</code></pre>
<p><strong>常用的方法</strong><br>
1.建立一个日历-----Calendar()方法<br>
实例：</p>
<pre><code class="language-python">     cal = Calendar()
</code></pre>
<p>2.在日历中添加组件-----add(属性名，值)</p>
<pre><code class="language-python">    cal.add('VERSION','2.0')
    cal.add('X-WR-CALNAME','生成ics文件测试')
    cal.add('X-APPLE-CALENDAR-COLOR','#540EB9')
    cal.add('X-WR-TIMEZONE','Asia/Shanghai')
</code></pre>
<p>这些参数的意义在我的<a href="https://aruul.github.io/2020/08/07/ical%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E/">这篇文章</a>中讲到</p>
<p>3.在日历中添加子组件(事件)-----Event</p>
<pre><code>    event=Event()
</code></pre>
<p>4.为事件添加属性-----add(属性名，值)</p>
<pre><code class="language-python">    event.add('UID','2000')
    event.add('DTSTART;VALUE=DATE','20200808T170500')
    event.add('DTEND;VALUE=DATE','20200808T172000')
    event.add('SUMMARY','测试事件键')
    event.add('SEQUENCE','0')
    event.add('DESCRIPTION','这是描述')
    event.add('LOCATION','这是地点')
</code></pre>
<p>5.添加子组件(Event)的子组件(Alarm)</p>
<pre><code class="language-python">    alarm=Alarm()
    alarm.add('ACTION','NONE')
    alarm.add('TRIGGER;VALUE=DATE-TIME','19760401T005545Z')
    event.add_component(alarm)
</code></pre>
<p>6.将事件添加到日历-----add_component()</p>
<pre><code class="language-python">    cal.add_component(event)
</code></pre>
<p>一个日历可添加多个事件<br>
7.生成ical文件</p>
<pre><code class="language-python">    f = open('example.ics', 'wb')
    f.write(cal.to_ical())
    f.close()
</code></pre>
<p>其中to_ical()方法将之前写的代码生成字符串，方便我们写入文件</p>
<p>8.总结</p>
<p>总的代码，添加多个事件时格式如下</p>
<pre><code class="language-python">    cal = Calendar()
    cal.add('VERSION','2.0')
    cal.add('X-WR-CALNAME','生成ics文件测试')
    cal.add('X-APPLE-CALENDAR-COLOR','#540EB9')
    cal.add('X-WR-TIMEZONE','Asia/Shanghai')

    event = Event()
    event.add('UID','2000')
    event.add('DTSTART;VALUE=DATE','20200808T170500')
    event.add('DTEND;VALUE=DATE','20200808T172000')
    event.add('SUMMARY','测试事件键')
    event.add('SEQUENCE','0')
    event.add('DESCRIPTION','这是描述')
    event.add('LOCATION','这是地点')
    alarm=Alarm()
    alarm.add('ACTION','NONE')
    alarm.add('TRIGGER;VALUE=DATE-TIME','19760401T005545Z')
    event.add_component(alarm)

    eventt=Event()
    eventt.add('UID','2001')
    eventt.add('DTSTART;VALUE=DATE','20200808T180500')
    eventt.add('DTEND;VALUE=DATE','20200808T182000')
    eventt.add('SUMMARY','测试事件2')
    eventt.add('SEQUENCE','0')
    eventt.add('DESCRIPTION','这是描述2')
    eventt.add('LOCATION','这是地点2')
    alarmm=Alarm()
    alarmm.add('ACTION','NONE')
    alarmm.add('TRIGGER;VALUE=DATE-TIME','19760401T005545Z')
    eventt.add_component(alarmm)

    cal.add_component(event)
    cal.add_component(eventt)
    f = open('例子.ics', 'wb')
    f.write(cal.to_ical())
    f.close()
</code></pre>
<p>生成的文件内部代码如下：</p>
<pre><code>BEGIN:VCALENDAR
VERSION:2.0
X-APPLE-CALENDAR-COLOR:#540EB9
X-WR-CALNAME:生成ics文件测试
X-WR-TIMEZONE:Asia/Shanghai
BEGIN:VEVENT
SUMMARY:测试事件键
UID:2000
SEQUENCE:0
DESCRIPTION:这是描述
DTEND;VALUE=DATE:20200808T172000
DTSTART;VALUE=DATE:20200808T170500
LOCATION:这是地点
BEGIN:VALARM
ACTION:NONE
TRIGGER;VALUE=DATE-TIME:19760401T005545Z
END:VALARM
END:VEVENT
BEGIN:VEVENT
SUMMARY:测试事件键2
UID:2000
SEQUENCE:0
DESCRIPTION:这是描述2
DTEND;VALUE=DATE:20200808T182000
DTSTART;VALUE=DATE:20200808T182000
LOCATION:这是地点2
BEGIN:VALARM
ACTION:NONE
TRIGGER;VALUE=DATE-TIME:19760401T005545Z
END:VALARM
END:VEVENT
END:VCALENDAR
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[b站排行榜爬虫]]></title>
        <id>https://aruul.github.io/post/b-zhan-pai-xing-bang-pa-chong/</id>
        <link href="https://aruul.github.io/post/b-zhan-pai-xing-bang-pa-chong/">
        </link>
        <updated>2020-07-24T13:42:44.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<h2 id="一简单爬取标题-up-播放量等表面数据">（一）简单爬取标题 up 播放量等表面数据</h2>
<ol>
<li>前提准备</li>
</ol>
<ul>
<li>b站排行榜链接 https://www.bilibili.com/ranking</li>
<li>python编译器一个</li>
<li>所需要的库：urllib3  BeautifulSoup</li>
</ul>
<p>2 . 观察<br>
打开b站排行榜页面，按F12或者鼠标右键检查页面，可以查看b站排行榜页面源码。当你鼠标在源码出浏览时，对应网页部分会高亮提示，可以看到代码对应的网页内容。</p>
<p>3.伪装<br>
作为一个爬虫，要先把自己伪装成一个浏览器。在浏览器按F12后，点击 &lt;网络&gt; 选项<br>
<img src="https://s1.ax1x.com/2020/07/24/UvHCsx.png" alt="UvHCsx.png" loading="lazy"></p>
<p>找到请求标头<br>
<a href="https://imgchr.com/i/UvHAoD"><img src="https://s1.ax1x.com/2020/07/24/UvHAoD.png" alt="UvHAoD.png" loading="lazy"></a></p>
<p>这些就是你浏览器的信息<br>
这次我们只需要用到user-agent这个内容</p>
<pre><code class="language-python">import urllib3
import urllib.request
from bs4 import BeautifulSoup
def askURL(url):
    headersss={
    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 Edg/83.0.478.61&quot;,
    &quot;accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;
    }
    req=urllib.request.Request(url=url,headers=headersss)
    #html=&quot;null&quot;
    try:
        response=urllib.request.urlopen(req)
        html=response.read().decode('utf-8')
        #print(html)
    except urllib.error.URLError as e:
        if hasattr(e,&quot;code&quot;):
            print(e.code)
        if hasattr(e,&quot;reason&quot;):
            print(e.reason)
    return html
</code></pre>
<p>剩下的过几天续上。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gitalk ---- 勉强能用的博客评论]]></title>
        <id>https://aruul.github.io/post/gitalk/</id>
        <link href="https://aruul.github.io/post/gitalk/">
        </link>
        <updated>2020-06-21T03:34:49.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="基于yilia主题配置的评论区">基于yilia主题配置的评论区</h3>
<p>本打算用Gitment，但发现原作者的服务器好像不能用来<br>
由于自己懒得去注册别的网站的账号，所以就用了Gitalk。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="基于yilia主题配置的评论区">基于yilia主题配置的评论区</h3>
<p>本打算用Gitment，但发现原作者的服务器好像不能用来<br>
由于自己懒得去注册别的网站的账号，所以就用了Gitalk。</p>
<!--more-->
<h6 id="正式开始吧">正式开始吧</h6>
<p>首先<a href="https://github.com/settings/applications/new" title="点这里">点这里</a>进行注册<br>
你会看到下面四个选项</p>
<ol>
<li>Application name：填写你的应用名称（这个随意，最好是英文，建议跟仓库名一样）</li>
<li>Homepage URL：填写你的博客主页域名</li>
<li>Application description：应用描述，非必填项</li>
<li>Authorization callback URL：这个填写与Homepage URL一致<br>
点击注册，会获取到 Client ID/scerct 。</li>
</ol>
<h6 id="配置-_configyml-文件">配置 _config.yml 文件</h6>
<p>打开themes\yilia_config.yml ,增加如下代码：</p>
<pre><code class="language-html">#6、gitalk评论
gitalk:
  enable: true
  githubID: 填写你的 github 账户名即可  
  repo: 'repo 名字为可新建一个repo 或者使用博客托管的 repo 都行。'
  ClientID: '就是上步骤中注册的获取的信息'
  ClientSecret: '就是上步骤中注册的获取的信息'
  adminUser: 填写你的 github 账户名即可
  distractionFreeMode: true
</code></pre>
<p><strong>注意不要去掉引号！！！！</strong></p>
<h6 id="在themesyilialayout_partialpost目录下新增gitalkejs文件文件内写入如下代码">在themes/yilia/layout/_partial/post目录下新增gitalk.ejs文件,文件内写入如下代码：</h6>
<pre><code> &lt;div id=&quot;gitalk-container&quot; style=&quot;padding: 0px 30px 0px 30px;&quot;&gt;&lt;/div&gt; 

&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

if(&lt;%=theme.gitalk.enable%&gt;){
	var gitalk = new Gitalk({
  	clientID: '&lt;%=theme.gitalk.ClientID%&gt;',
  	clientSecret: '&lt;%=theme.gitalk.ClientSecret%&gt;',
  	repo: '&lt;%=theme.gitalk.repo%&gt;',
  	owner: '&lt;%=theme.gitalk.githubID%&gt;',
  	admin: ['&lt;%=theme.gitalk.adminUser%&gt;'],
  	id: '&lt;%= page.date %&gt;',
  	distractionFreeMode: '&lt;%=theme.gitalk.distractionFreeMode%&gt;'
})
gitalk.render('gitalk-container') 
}
&lt;/script&gt;
</code></pre>
<h6 id="修改themesyiliasource-srccss目录下commentscss文件">修改themes/yilia/source-src/css/目录下comment.scss文件</h6>
<pre><code class="language-html">#disqus_thread, .duoshuo, .cloud-tie-wrapper, #SOHUCS, #gitment-ctn, #gitalk-container {
	padding: 0 30px !important;
	min-height: 20px;
}

#SOHUCS {
	#SOHU_MAIN .module-cmt-list .block-cont-gw {
		border-bottom: 1px dashed #c8c8c8 !important;
	}
}
</code></pre>
<h6 id="在themesyilialayout_partial目录下的articleejs文件内新增gitalk相关的配置代码">在themes/yilia/layout/_partial目录下的article.ejs文件内新增gitalk相关的配置代码：</h6>
<p>先找到</p>
<pre><code class="language-html">&lt;% if (!index &amp;&amp; post.comments){ %&gt;
//添加到这里
&lt;% } %&gt;
</code></pre>
<p>然后将：</p>
<pre><code class="language-html">&lt;% if(theme.gitalk.enable){ %&gt;
  &lt;%- partial('post/gitalk', {
      key: post.slug,
      title: post.title,
      url: config.url+url_for(post.path)
    }) %&gt;
  &lt;% } %&gt;
</code></pre>
<p>添加到上述位置处</p>
<p>否则添加到别处主页中间会出现评论区</p>
<p><strong>完</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[hexo+github搭建个人博客]]></title>
        <id>https://aruul.github.io/post/hexogithub-da-jian-ge-ren-bo-ke/</id>
        <link href="https://aruul.github.io/post/hexogithub-da-jian-ge-ren-bo-ke/">
        </link>
        <updated>2020-06-20T02:19:49.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="周周转转终于把博客搭建的差不多了">周周转转终于把博客搭建的差不多了</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="周周转转终于把博客搭建的差不多了">周周转转终于把博客搭建的差不多了</h1>
<h2 id="-more-本篇博客由aru原创转载请标明出处附上本文链接"><!--more--><br>
<strong>本篇博客由aRu原创，转载请标明出处，附上本文链接。</strong></h2>
<p><strong>下面是我的过程</strong>：<br>
<s>由于还是没找到合适的md编辑器，所以直接用的md在线编辑，<br>
而在线编辑又不能插入图片，所以这篇文章看起来有点枯燥</s></p>
<p><strong>1. 准备工作</strong></p>
<ul>
<li>
<p>安装Node.js</p>
</li>
<li>
<p>安装Git</p>
</li>
<li>
<p>注册Github账号 生成静态网页</p>
</li>
<li>
<p>安装Hexo</p>
</li>
<li>
<p>连接Github与本地</p>
</li>
<li>
<p><strong>安装软件大家都会，直接去官网下载就行</strong><br>
<em><strong>需要注意的是Node.js安装时有一步要选Add To Path，其他默认就行。</strong></em></p>
</li>
<li>
<p><strong>注册GitHub相信聪明的你也会</strong></p>
</li>
<li>
<p><strong>生成静态网页</strong><br>
1.在 Github 中创建一个名称为 <strong>你的Github名字.github.io</strong>  的Repository。<br>
<em>这里实在不懂得话可以搜一下怎么创建Github Pages</em><br>
2.勾选 Initialize this repository with a README<br>
3.选择Create repository</p>
</li>
<li>
<p><strong>安装Hexo</strong><br>
以上软件装完之后在你本地磁盘建一个文件夹命名为Blog（名字可以随便取，但要是英文）<br>
进入Blog文件<br>
鼠标右键---选择Git Bash Here（之后的步骤会频繁使用它，建议不要教程结束之后在关闭该窗口，每输入一行命令都要回车执行）<br>
输入</p>
<pre><code>npm install -g hexo-cli
</code></pre>
</li>
</ul>
<pre><code>然后回车等待安装，安装完成后输入
</code></pre>
<p>hexo -v</p>
<pre><code>出现一堆数据就证明你安装成功了

**连接Github与本地**- 
还是在刚才打开的Git Bash那里依次输入下面的命令
</code></pre>
<p>git config --global user.name &quot;username&quot;<br>
git config --global user.email &quot;Email&quot;</p>
<pre><code>其中username是你的GitHub名字
Email是你注册时的邮箱   （两个参数都不用去引号）  

然后生成密钥SSH key：
</code></pre>
<p>ssh-keygen -t rsa -C &quot;Email&quot;</p>
<pre><code>Email是你注册时的邮箱，引号不用去

然后打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。

然后git bash中输入
</code></pre>
<p>cat ~/.ssh/id_rsa.pub</p>
<pre><code>这时候会出现一堆字符，复制下来，粘贴到GitHub刚才的页面框中，点击确定保存。

然后再Git Bash输入
</code></pre>
<p>ssh -T git@github.com</p>
<pre><code>如果看到出现 **You successfly**就证明链接成功。

**2.创建本地博客**

还是在刚才打开的Git Bush中输入：```
hexo init
​```将 blog 文件夹初始化成一个博客文件夹。

输入 ```
npm install
​``` 安装依赖包。

输入```hexo g``` 生成（generate）网页。 

由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。

输入```hexo s``` 将生成的网页放在了本地服务器（server）。

浏览器里输入 http://localhost:4000/  就可以看到刚才的成果了。

回到 Git Bash，按 Ctrl+C 结束，此时再看 http://localhost:4000/ 就是无法访问了。

**3.将本地 Hexo 博客部署在 Github 上**

 - 获取 Github 对应的 Repository 的链接
登陆 Github，进入到 你之前创建的仓库页面下，点击 Clone or download复制 URL 

- 修改博客的配置文件打开配置文件 /blog/_config.yml 
找到 #Deployment，
填入以下内容：
deploy:   
 type: git  
 repository: 填刚才复制的url  
 branch: master 
保存退出
- 部署
回到 Git Bash
输入 ```npm install hexo-deployer-git --save
​``` 安装 hexo-deployer-git 
此步骤只需要做一次。
输入 ```hexo d
​```得到  INFO Deploy done: git  即为部署成功
前往你的仓库页面即可查看成果。

**4.选择你的博客主题**
打开[Hexo 主题](https://hexo.io/themes/ &quot;Hexo 主题&quot;)
或者[Easy Hexo](https://easyhexo.com/2-Theme-use-and-config/ &quot;Easy Hexo&quot;)
第一个网页有很多主题可以选，选择你心仪的主题，找到对应的github仓库，仓库里一般会有操作说明
这里我更推荐第二个网页，都是现成的教程和主题，我的博客主题（名字是yilia）就是安照这个教程来设置的

**5.重新上传**

*我们采用的是静态网页，所以每次改动之后都要重新上传*

- **重新上传前你要知道的**
~~似乎聪明的你会发现前面啰里啰唆一大堆，怎么没有教你怎么写博客和上传博客。~~
**以发布一篇博客为例子：**

***第一种方式：***
继续在 Git Bash 里，所在路径还是 /d/blog
输入 ``hexo new &quot;My First Post&quot;``
在 \blog\source\_posts 路径下，会有一个 My-First-Post.md 的文件。 
编辑这个文件，随便写一些什么，然后保存。
回到 Git Bash，输入 ``hexo g``
输入 ``hexo s``
前往 http://localhost:4000/ 查看成果。
回到 Git Bash，按 Ctrl+C 结束。

**第二种方式：**
直接打开\blog\source\_posts（或者\blog\source下其他的文件夹）
然后新建一个以 .md结尾的文件
打开并输入内容即可
这里是[md语法规则](https://blog.csdn.net/qq_27870421/article/details/86541868 &quot;md语法规则&quot;)的教程，还是很简单的。你也可以选择用md编辑器来操作。

**6.更新博客**

每次配置本地博客或者更新博客内容后都需要重新上传部署

回到 Git Bash，输入 ``hexo g -d``就可以了。

**7.后记**
可以在评论区跟我互动哦，github互关也可以（逃


-----------
**本篇博客由aRu原创，转载请标明出处。**
</code></pre>
]]></content>
    </entry>
</feed>