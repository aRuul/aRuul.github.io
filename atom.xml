<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aruul.github.io</id>
    <title>aRuul的无名小站</title>
    <updated>2021-07-15T08:26:39.320Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aruul.github.io"/>
    <link rel="self" href="https://aruul.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aruul.github.io/images/avatar.png</logo>
    <icon>https://aruul.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, aRuul的无名小站</rights>
    <entry>
        <title type="html"><![CDATA[java多线程]]></title>
        <id>https://aruul.github.io/post/h25epdEh9/</id>
        <link href="https://aruul.github.io/post/h25epdEh9/">
        </link>
        <updated>2021-07-15T08:25:56.000Z</updated>
        <content type="html"><![CDATA[<p><strong>最近准备秋招，就开始之前java内容的复习，把复习过程中一些基本知识记录了下来，预祝自己秋招顺利吧。</strong></p>
<h2 id="基础篇">基础篇</h2>
<h3 id="1进程和线程">1.进程和线程</h3>
<blockquote>
<p>进程就是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。</p>
<p><strong>一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p>
</blockquote>
<p>进程和线程的提出极大的提高了操作系统的性能。<strong>进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。</strong></p>
<h4 id="11进程和线程的区别">1.1进程和线程的区别</h4>
<p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是<strong>是否单独占有内存地址空间及其它系统资源（比如I/O）</strong>：</p>
<ul>
<li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</li>
<li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li>
<li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li>
</ul>
<p>另外一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即CPU分配时间的单位 。</p>
<hr>
<h3 id="2java多线程入门类和接口">2.Java多线程入门类和接口</h3>
<p>JDK提供了<code>Thread</code>类和<code>Runnable</code>接口来让我们实现自己的“线程”类。</p>
<ul>
<li>继承<code>Thread</code>类，并重写<code>run</code>方法；</li>
<li>实现<code>Runnable</code>接口的<code>run</code>方法；</li>
</ul>
<h4 id="21-继承thread类">2..1 继承<code>Thread</code>类</h4>
<pre><code class="language-java">public class MyThread_01 extends Thread{
    @Override
    public void run() {
        System.out.println(&quot;MyThread_01 run&quot;);
    }

    public static void main(String[] args) {
        MyThread_01 myThread_01 = new MyThread_01();
        myThread_01.start();
    }
}
</code></pre>
<p>注意要调用<code>start()</code>方法后，该线程才算启动！</p>
<blockquote>
<p>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。</p>
<p>注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出illegalThreadStateException异常。</p>
</blockquote>
<h3 id="212实现runnable接口">2.12实现Runnable接口</h3>
<p>略</p>
<hr>
<h2 id="小细节">小细节</h2>
<p>当main线程启动一个线程的时候，main线程并不会阻塞，会和新开的线程交替执行</p>
<pre><code class="language-java">public class Demo1 extends Thread{
    @Override
    public void run() {
        for (int i=0; i&lt;5;i++){
            try {
                Thread.sleep(500);
                System.out.println(&quot;线程启动了...【&quot;+ Thread.currentThread().getName()+&quot;】&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo1 demo1 = new Demo1();
        demo1.start();

        for (int i = 0; i &lt; 5; i++) {
            System.out.println(&quot;main 线程启动&quot;);
            Thread.sleep(1000);
        }
    }

}
</code></pre>
<p>运行结果：</p>
<blockquote>
<p>main 线程启动<br>
线程启动了...【Thread-0】<br>
main 线程启动<br>
线程启动了...【Thread-0】<br>
线程启动了...【Thread-0】<br>
main 线程启动<br>
线程启动了...【Thread-0】<br>
线程启动了...【Thread-0】<br>
main 线程启动<br>
main 线程启动</p>
<p>Process finished with exit code 0</p>
</blockquote>
<p>实现Runnable接口的方式更加适合多个线程共享一个资源的情况</p>
<hr>
<h2 id="jdk18新特性lamda表达式">jdk1.8新特性Lamda表达式</h2>
<p>属于函数式编程</p>
<p>lambda 表达式的语法格式如下：</p>
<pre><code class="language-java">(parameters) -&gt; expression 
</code></pre>
<p>或</p>
<pre><code class="language-java"> (parameters) -&gt;{ statements; }
</code></pre>
<pre><code class="language-java">public class MyLamda {
    public static void main(String[] args) {
        Like like = ()-&gt;{
            System.out.println(&quot;i like java lamda&quot;);
        };
        like.say();
    }
}

interface Like{
    void say();
}
</code></pre>
<h2 id="线程的状态">线程的状态</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210714161606.png" alt="image-20210714161604425" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210714190304.png" alt="image-20210714190303037" loading="lazy"></figure>
<hr>
<p><mark>优先级范围为1-10，一般是越大越高，越先执行，默认为5</mark></p>
<p>线程分为用户线程和守护线程</p>
<h2 id="守护线程">守护线程</h2>
<p>在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)</p>
<p>如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<p><mark>当主线程结束之后，守护线程也就结束</mark></p>
<pre><code class="language-java">public class ShouHu {
    public static void main(String[] args) {

        Runnable runnable=()-&gt;{
            for( ; ; ){
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;我是守护线程&quot;);
            }
        };

        Thread thread = new Thread(runnable);
        thread.setDaemon(true);
        thread.start();

        for (int i = 0; i &lt; 5; i++) {
            System.out.println(&quot;main线程&quot;);
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<h2 id="线程同步">线程同步</h2>
<blockquote>
<p>在多线程编程，一些敏感数据不允许被多个线程同时访向，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访向，以保证数据的完整性</p>
</blockquote>
<h3 id="synchronized">synchronized</h3>
<p><strong>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</strong></p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<h2 id="死锁">死锁</h2>
<p><strong>产生死锁的四个必要条件：</strong><br>
1.互斥条件：一个资源每次只能被一个进程使用。<br>
2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放<br>
3.不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>
4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210715145533.png" alt="image-20210715145531281" loading="lazy"></figure>
<h2 id="释放锁">释放锁</h2>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210715145649.png" alt="image-20210715145648921" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210715150000.png" alt="image-20210715145957974" loading="lazy"></figure>
<h2 id="lock锁">Lock锁</h2>
<blockquote>
<p>1、从Java5开始，Java提供了一种功能更强大的线程同步机制——通过显式定义同步锁对象来实现同步，在这种机制下，同步锁由Lock对象充当。</p>
<p>2、Lock 提供了比synchronized方法和synchronized代码块更广泛的锁定操作，Lock允许实现更灵活的结构，可以具有差别很大的属性，并且支持多个相关的Condition对象。</p>
<p>3、Lock是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p>
<p>4、某些锁可能允许对共享资源并发访问，如ReadWriteLock（读写锁），Lock、ReadWriteLock是Java5提供的两个根接口，并为Lock 提供了ReentrantLock（可重入锁）实现类，为ReadWriteLock提供了ReentrantReadWriteLock 实现类。</p>
<p>5、Java8新增了新型的StampedLock类，在大多数场景中它可以替代传统的ReentrantReadWriteLock。ReentrantReadWriteLock 为读写操作提供了三种锁模式：Writing、ReadingOptimistic、Reading。</p>
</blockquote>
<pre><code class="language-java">public class MyLock {
    public static void main(String[] args) {
        TestLock testLock = new TestLock();
        new Thread(testLock).start();
        new Thread(testLock).start();
        new Thread(testLock).start();
    }
}

class TestLock implements Runnable{
    private int tickets = 100;
    //定义锁
    private final ReentrantLock reentrantLock = new ReentrantLock();

    @Override
    public void run() {
        while (true){
            //加锁
            reentrantLock.lock();
            if(tickets&lt;=0){
                break;
            }
            System.out.println(Thread.currentThread().getName()+&quot;, &quot;+(tickets--));
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                //解锁
                reentrantLock.unlock();
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代理模式]]></title>
        <id>https://aruul.github.io/post/YYF012ILo/</id>
        <link href="https://aruul.github.io/post/YYF012ILo/">
        </link>
        <updated>2021-07-04T07:51:46.000Z</updated>
        <content type="html"><![CDATA[<p>代理模式简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>代理模式有静态代理和动态代理两种实现方式。</p>
<h2 id="静态代理">静态代理</h2>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>例如：小明想要打官司，则他需要找到代理律师来帮他</p>
<p>​			代理律师负责将小明想说的话说出去，并在小明说话前面引用法律条文，在小明说话后发动道德谴责。</p>
<p>代码：</p>
<pre><code class="language-java">//说话的行为接口
interface Say{
    void sayMessage(String m);
}
//小明
class XiaoMing implements Say{
    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;小明说出案情--by&quot;+m);
    }
}

//静态代理 王律师
class LawyerWang implements Say{
    private final Say say;

    public LawyerWang(Say say) {
        this.say = say;
    }

    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;引用法律条文&quot;);
        say.sayMessage(m);
        System.out.println(&quot;使用道德谴责&quot;);
    }
}
</code></pre>
<p>但是当又有一人来找王律师的时候，就需要重写代理的代码，非常不实用。</p>
<hr>
<h2 id="动态代理">动态代理</h2>
<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<h3 id="jdk动态代理">JDK动态代理</h3>
<h3 id="介绍">介绍</h3>
<p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<ol>
<li><strong>InvocationHandler接口</strong></li>
</ol>
<blockquote>
<p>在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</p>
<pre><code>/**
 * 调用处理程序
 */
public interface InvocationHandler { 
    Object invoke(Object proxy, Method method, Object[] args); 
} 
复制代码
</code></pre>
<p>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。</p>
<p>当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中。</p>
<p>代理类对象作为proxy参数传入，</p>
<p>参数method标识了我们具体调用的是代理类的哪个方法，</p>
<p>args为这个方法的参数。</p>
<p>这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。<br>
作者：Chaexsy<br>
链接：https://juejin.cn/post/6844903591501627405<br>
来源：掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<ol start="2">
<li><strong><code>Proxy</code> 类</strong></li>
</ol>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<pre><code class="language-java">    public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        ......
    }Copy to clipboardErrorCopied
</code></pre>
<p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<hr>
<h3 id="接口和被代理委托方">接口和被代理(委托方)</h3>
<pre><code class="language-java">//说话的行为接口
interface Say{
    void sayMessage(String m);
}
//小明
class XiaoMing implements Say{
    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;小明说出案情--by&quot;+m);
    }
}
</code></pre>
<h3 id="中介类">中介类</h3>
<p>对于<strong>XiaoMing</strong>这个类来说<strong>LawyerProxy</strong>类是他的代理，构成了静态代理</p>
<pre><code class="language-java">class LawyerProxy implements InvocationHandler{
    final private Object object;

    public LawyerProxy(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;引用法律条文&quot;);
        method.invoke(object,args);
        System.out.println(&quot;使用道德谴责&quot;);
        return null;
    }
}
</code></pre>
<h3 id="实际调用">实际调用</h3>
<p>而对于<strong>LawyerProxy</strong>类来说，<strong>Proxy 类</strong>是它的代理，构成了静态代理</p>
<pre><code class="language-java">	//动态代理
  System.out.println(&quot;===动态代理===&quot;);
  LawyerProxy lawyerProxy = new LawyerProxy(new XiaoMing());
  Say s = (Say)Proxy.newProxyInstance(Say.class.getClassLoader(), new Class[]{Say.class}, lawyerProxy);
  s.sayMessage(&quot;动态代理类&quot;);
</code></pre>
<p>也就是说，<strong>动态代理关系由两组静态代理关系组成，这就是动态代理的原理</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反射（3）]]></title>
        <id>https://aruul.github.io/post/9RSSdqr6G/</id>
        <link href="https://aruul.github.io/post/9RSSdqr6G/">
        </link>
        <updated>2021-07-01T07:33:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="反射-得到对象的六种方式">反射-得到对象的六种方式</h3>
<pre><code class="language-java">  
        /*  1.Clss.forName
            已经知道一个类的全类名，
            应用场景：多用于配置文件，读取类全路径，加载类
        */
        final String classAllPath = &quot;org.example.Car&quot;;
        Class&lt;?&gt; cls1 = Class.forName(classAllPath);
        System.out.println(&quot;cls1 &quot;+cls1);

        /*  2.类名.class
            已经知道一个具体的类，
            应用场景：多用于参数传递，如通过反射得到对应的构造器对象
        */
        Class cls2 = Car.class;
        System.out.println(&quot;cls2 &quot;+cls2);

        /*  3.getClass()
            已经知道一个类的实例，调用该实例的getClass()方法获取Class对象，
            应用场景：通过创建好的对象，获取Class对象
        */
        Car car = new Car();
        Class cls3 = car.getClass();
        System.out.println(&quot;cls3 &quot;+cls3);

        /*  4.ClassLoader
            通过类加载器
            应用场景：
        */
        //(1)得到car类的加载器 
        ClassLoader classLoader = car.getClass().getClassLoader();
        //(2)通过类加载器，得到Class对象
        Class&lt;?&gt; cls4 = classLoader.loadClass(&quot;org.example.Car&quot;);
        System.out.println(&quot;cls4 &quot;+cls4);


        //cls1 cls2 cls3 cls4其实是同一个对象
        System.out.println(cls1.hashCode());
        System.out.println(cls2.hashCode());
        System.out.println(cls3.hashCode());
        System.out.println(cls4.hashCode());

        //5.基本数据类型获取Class对象
        Class&lt;?&gt; integerClass = int.class;
        System.out.println(integerClass);

        //6.基本数据类型对应的包装类，通过Type获取Class对象
        Class&lt;?&gt; type = Integer.TYPE;
        System.out.println(type);
</code></pre>
<hr>
<h3 id="反射-获取类相关的信息">反射-获取类相关的信息</h3>
<pre><code class="language-java">		Class&lt;?&gt; personClass = Class.forName(&quot;org.example.Person&quot;); //父类
        Class&lt;?&gt; studentClass = Class.forName(&quot;org.example.Student&quot;); //子类

        //获取全类名
        System.out.println(&quot;获取全类名&quot;+personClass.getName());

        //获取简单类名
        System.out.println(&quot;获取简单类名&quot;+personClass.getSimpleName());

        //获取所有public修饰的属性， 包括本类及父类
        Field[] fields = studentClass.getFields();
        System.out.println(&quot;获取所有public修饰的属性， 包括本类及父类&quot;);
        for (int i = 0; i &lt; fields.length; i++) {
            System.out.println(fields[i].getName());
        }

        //获取本类的所有属性
        Field[] fields2 = personClass.getDeclaredFields();
        System.out.println(&quot;获取本类的所有属性&quot;);
        for (int i = 0; i &lt; fields2.length; i++) {
            System.out.println(fields2[i].getName());
        }

        //获取本类和父类和超类所有public修饰的方法
        Method[] methods = studentClass.getMethods();
        System.out.println(&quot;获取本类和父类和超类所有public修饰的方法&quot;);
        for (int i = 0; i &lt; methods.length; i++) {
            System.out.println(methods[i].getName());
        }

        //获取本类中所有的方法
        Method[] methods2 = studentClass.getDeclaredMethods();
        System.out.println(&quot;获取本类中所有的方法&quot;);
        for (int i = 0; i &lt; methods2.length; i++) {
            System.out.println(methods2[i].getName());
        } 

        //获取本类所有public修饰的构造器，`
        Constructor[] constructors = studentClass.getConstructors();
        System.out.println(&quot;获取本类所有public修饰的构造器&quot;);
        for (int i = 0; i &lt; constructors.length; i++) {
            System.out.println(constructors[i].getName());
        }

        //获取本类所有构造器
        Constructor[] constructors2 = studentClass.getDeclaredConstructors();
        System.out.println(&quot;获取本类所有构造器&quot;);
        for (int i = 0; i &lt; constructors2.length; i++) {
            System.out.println(constructors2[i]);
        }

        //获取包名
        System.out.println(&quot;获取包名&quot;);
        System.out.println(studentClass.getPackage());

        //以Class的形式返回父类信息
        Class&lt;?&gt; superclass = studentClass.getSuperclass();
        System.out.println(&quot;以Class的形式返回父类信息&quot;);
        System.out.println(superclass);

        //以Class[]的形式返回接口信息
        Class[] interfaces = studentClass.getInterfaces();
        System.out.println(&quot;以Class[]的形式返回接口信息&quot;);
        for (int i = 0; i &lt; interfaces.length; i++) {
            System.out.println(interfaces[i]);
        }

        //以Annotation[]的形式得到注解信息
        Annotation[] annotations = studentClass.getAnnotations();
        System.out.println(&quot;以Annotation[]的形式得到注解信息&quot;);
        for (int i = 0; i &lt; annotations.length; i++) {
            System.out.println(annotations[i]);
        }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java中final变量的初始化]]></title>
        <id>https://aruul.github.io/post/Z708mjxH2/</id>
        <link href="https://aruul.github.io/post/Z708mjxH2/">
        </link>
        <updated>2021-06-15T04:18:56.000Z</updated>
        <content type="html"><![CDATA[<p>今天在看java中String的源码，发现了自己对final变量初始化的了解不够好，有遗漏的地方，之前只知道第一种初始化方法。</p>
<pre><code class="language-java">public class FinalStudy {
    //第一种 在定义后直接初始化
    private final int a = 1;
    //第二种 声明变量后在构造方法中为其赋值
    //如果采用用这种方式，那么每个构造方法中都要有j赋值的语句
    private final int b;
    public FinalStudy(int b) {
        this.b = b;
    }
    // 初始化方式三，声明变量后在构造代码块中为其赋值
    // 如果采用此方式，就不能在构造方法中再次为其赋值
    // 构造代码块中的代码会在构造函数之前执行，如果在构造函数中再次赋值，
    // 就会造成final变量的重复赋值
    private final int c;
    {
        c = 3;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iPad变成真正的生产力----编程]]></title>
        <id>https://aruul.github.io/post/EJmNDhozo/</id>
        <link href="https://aruul.github.io/post/EJmNDhozo/">
        </link>
        <updated>2021-05-16T11:54:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>iPad被知乎、b站很多人标榜为生产力，其实很早之前我一直觉得surface go才算生产力，毕竟可以编程。自己很偏激的把iPad看作电子垃圾。</p>
<p>但是，由于预算有限，我还是买了ipad2020 128G🤡，毕竟同等价位买surface go2的话，只能买个乞丐版的，而且还是裸机。</p>
<p>ipad买了之后我就有点小后悔，因为我发现我平时用ipad干的最多的就是读pdf，看视频。这完全可以被一个更便宜的安卓平板代替。</p>
<p>后来在想ipad上可不可以像surface go2那样配个键盘编程，于是就花买了一个罗技的蓝牙键盘，手感还不错，ipad、笔记本都可以用。一开始，我发现可以在leetcode网页上在线编程，但是这种在线编程有些难受；我便开始寻找新的解决方案。在ipad搜到了几个编程软件，但是都要付费，还挺贵，我就犹豫了。</p>
<p>就在今天，我刷知乎的时候，看到了github上的一个开源项目【<a href="https://github.com/cdr/code-server">code-server</a>】</p>
<h2 id="code-server">code-server</h2>
<blockquote>
<p><code>code-server</code> 实际上就是专门为浏览器设计优化的 VS Code，可以直接通过浏览器访问。</p>
<p>在远程 Linux 服务器上面部署 <code>code-server</code> 之后，<code>code-server</code> 实际上就相当于一个「中转站」，为我们提供一个直接在 Linux 服务器上面修改文件、访问数据库、执行指令等等操作的「窗口」，而由于这一「窗口」同样在 Linux 服务器上面运行，使用任何一个浏览器都可以打开，所以 iPad 也不例外。</p>
<p>这样，我们就能够借助在远程服务器上运行的 <code>code-server</code>，直接使用远程服务器上面的各种资源（包括服务器上强大的原生 Linux 环境、CPU / GPU 等计算资源、「无尽」的电量等等）进行开发工作。（当然，这也要求我们 iPad 端全程拥有网络连接。）</p>
</blockquote>
<p>所以说需要你有个服务器，非常巧的是我服务器基本上算是吃灰的状态，上面就跑了两个网址的服务。</p>
<h3 id="准备">准备</h3>
<p>我的服务器系统是ubuntu，在github【<a href="https://github.com/cdr/code-server/releases">code-server release</a>】中下载最新版的压缩包，并上传到服务器。</p>
<p>我选的是<a href="https://github.com/cdr/code-server/releases/download/v3.10.0/code-server-3.10.0-linux-amd64.tar.gz">code-server-3.10.0-linux-amd64.tar.gz</a></p>
<p>然后，你要在服务器上下载好screen，如果没下的话，执行一下快速安装命令就好</p>
<pre><code class="language-java">sudo apt-get install screen
</code></pre>
<h3 id="安装">安装</h3>
<p>进入code-server压缩包的目录，然后执行解压命令</p>
<pre><code class="language-java">tar -xvzf code-server-3.10.0-linux-amd64.tar.gz
</code></pre>
<p>再进入解压后的目录</p>
<pre><code class="language-java">cd code-server-3.10.0-linux-amd64
</code></pre>
<p>然后使用screen后台运行</p>
<pre><code>screen -S vscode
</code></pre>
<p>然后运行code-server</p>
<pre><code class="language-java">export PASSWORD=&quot;yourpassword&quot; &amp;&amp; ./code-server --port 888 --host 0.0.0.0 
</code></pre>
<ul>
<li>
<p><code>export PASSWORD=&quot;yourpassword&quot;</code>可以指定密码，将yourpassword替换为你的密码，<mark>引号不要去掉</mark></p>
<p>不加的话会默认生成一个，可以在运行后看到<code>yourpassword</code>为你的密码</p>
</li>
<li>
<p>--port 888为 指定端口运行，我这里是运行在888端口</p>
</li>
<li>
<p>--host 0.0.0.0 默认是127.0.0.1，只能本地访问，无法外网访问，所以得改成0.0.0.0，才能各个浏览器都能访问</p>
</li>
</ul>
<hr>
<p>之后访问你的服务器<code>公网ip:端口号</code>就可以访问了，当然也可以用nginx 代理到自己的域名上。</p>
<p>其他的操作和vscode没什么区别。</p>
<p>我自己配置了编写java用到的插件和配置。</p>
<p>下面是用到的插件</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210517200929.png" alt="image-20210517200928040" loading="lazy"></figure>
<hr>
<p>下面是配置文件,主要是<code>&quot;java.home&quot;:</code>  <code>&quot;java.requirements.JDK11Warning&quot;</code>    <code>&quot;java.semanticHighlighting.enabled&quot;</code>这几个。</p>
<pre><code class="language-java">{
    &quot;java.home&quot;: &quot;/usr/java/jdk1.8.0_121&quot;,
    &quot;java.requirements.JDK11Warning&quot;: false,
    &quot;java.semanticHighlighting.enabled&quot;: true,
    &quot;files.exclude&quot;: {
        &quot;**/.classpath&quot;: true,
        &quot;**/.project&quot;: true,
        &quot;**/.settings&quot;: true,
        &quot;**/.factorypath&quot;: true
    },
    &quot;java.completion.importOrder&quot;: [
        &quot;java&quot;,
        &quot;javax&quot;,
        &quot;com&quot;,
        &quot;org&quot;
    ],
    &quot;java.completion.favoriteStaticMembers&quot;: [
        &quot;org.junit.Assert.*&quot;,
        &quot;org.junit.Assume.*&quot;,
        &quot;org.junit.jupiter.api.Assertions.*&quot;,
        &quot;org.junit.jupiter.api.Assumptions.*&quot;,
        &quot;org.junit.jupiter.api.DynamicContainer.*&quot;,
        &quot;org.junit.jupiter.api.DynamicTest.*&quot;,
        &quot;org.mockito.Mockito.*&quot;,
        &quot;org.mockito.ArgumentMatchers.*&quot;,
        &quot;org.mockito.Answers.*&quot;
    ]
}
</code></pre>
<h2 id="在ipad上编程">在ipad上编程</h2>
<p>那么，怎么在ipad上运行呢。有两种方法：</p>
<ol>
<li>直接在浏览器访问你服务器code-server的网址。</li>
<li>在ipad App Store上搜索 Servediter</li>
</ol>
<p>我推荐第二种，Servediter是一款专门为 iPad 优化的用来连接 <code>code-server</code> 的 iOS 原生应用。我们使用 VSApp 可以直接连接我们自己的 <code>code-server</code> 实例，自动登录，打造畅快的在线 VS Code 体验。</p>
<p>Servediter原本是仅支持连接至它的开发者所部署的 <code>code-server</code> 上面的，因此也包含了 App 内购，最近才更新支持自部署服务器的连接。既然我们都已经自己部署了自己的 <code>code-server</code>，那么我们直接在菜单中选择「Self Hosted Server」，并依次填写：</p>
<ul>
<li>
<p>我们刚刚部署 <code>code-server</code> 的：</p>
</li>
<li>
<ul>
<li><code>code-server URL</code> 刚刚在 Safari 中打开的 URL：<code>{服务器 IP 地址}:{code-server 端口}</code></li>
<li><code>Instance password</code> 刚刚开启 <code>code-server</code> 时设置的密码</li>
</ul>
</li>
<li>
<p>以及，我们服务器自己的：</p>
</li>
<li>
<ul>
<li><code>Host</code>：服务器 IP 地址</li>
<li><code>Username</code>：默认登录用户名</li>
<li><code>Port</code>：登录 SSH 端口（默认 22 端口）</li>
<li><code>Authentication</code>：登录服务器时使用的密码或公钥私钥对</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210516204422.png" alt="image-20210516204421041" loading="lazy"></figure>
<p>这样，就可以愉快的在ipad上写代码了。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210516204906.jpg" alt="QQ图片20210516204848" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树]]></title>
        <id>https://aruul.github.io/post/t70ZdhScS/</id>
        <link href="https://aruul.github.io/post/t70ZdhScS/">
        </link>
        <updated>2021-05-13T11:52:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近一直在刷算法题，感觉还是需要把基础打牢一点，就暂停了刷题，从基本的算法书开始看。</p>
<p>《小灰的算法之旅》一个很基础的书</p>
<h2 id="二叉树">二叉树</h2>
<blockquote>
<p>什么是二叉树？官方是这样定义的：<strong>在计算机科学中，二叉树是每个结点最多有两个子树的树结构</strong>。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。</p>
</blockquote>
<p>其实这些都是很基础的东西，之前数据结构也都学过了。所以一些东西就省去不表。。。</p>
<p>二叉树的数据结构</p>
<pre><code class="language-java">public class TreeNode {
    public int data;
    public TreeNode leftChild;
    public TreeNode rightChild;

    public TreeNode(int data){
        this.data = data;
    }
}
</code></pre>
<h2 id="前序遍历生成二叉树">前序遍历生成二叉树</h2>
<p>我采用的是递归的方式，这样最容易明白</p>
<pre><code class="language-java">    //创建二叉树
	//inputList  存放前序遍历的二叉树的list
    public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inputList){
        TreeNode treeNode = null;
        if(inputList==null||inputList.isEmpty()){
            return null;
        }
        Integer data = inputList.removeFirst();
        if(data!=null){
            treeNode = new TreeNode(data);
            treeNode.leftChild = createBinaryTree(inputList);
            treeNode.rightChild = createBinaryTree(inputList);
        }
        return treeNode;

    }
</code></pre>
<p>测试代码：</p>
<pre><code class="language-java"> public static void main(String[] args) {
        LinkedList&lt;Integer&gt; inputList = new LinkedList&lt;Integer&gt;();
        inputList.add(3); 
        inputList.add(2);
        inputList.add(9);
        inputList.add(null);
        inputList.add(null);
        inputList.add(10);
        inputList.add(null);
        inputList.add(null);
        inputList.add(8);
        inputList.add(null);
        inputList.add(4);
        TreeNode head = createBinaryTree(inputList);

    }
</code></pre>
<h2 id="前序遍历二叉树">前序遍历二叉树</h2>
<h3 id="递归的写法">递归的写法</h3>
<pre><code class="language-java">    //前序遍历--递归的方式
    public static void qian(TreeNode head){
        if(head==null){
            return;
        }
        System.out.println(head.data);
        qian(head.leftChild);
        qian(head.rightChild);
    }
</code></pre>
<h3 id="非递归的写法">非递归的写法</h3>
<pre><code class="language-java">	//前序遍历--非递归的方式
    public static void qian2(TreeNode head){
        // 用栈来存放
        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
 
        while(head!=null||!stack.isEmpty()){
            //迭代访问节点的左节点，并入栈
            while(head!=null){
                System.out.println(head.data);
                stack.push(head);
                head = head.leftChild;
            }

            //若节点没有左孩子，栈中弹出栈顶结点，访问节点右节点
            if(!stack.isEmpty()){
                head = stack.pop();
                head = head.rightChild;
            }
        }
    }
</code></pre>
<h2 id="层次遍历">层次遍历</h2>
<p>大致思路：</p>
<p><img src="https://aruul.github.io/post-images/1620906969722.jpg" alt="" loading="lazy"><br>
<img src="https://aruul.github.io/post-images/1620906979070.jpg" alt="" loading="lazy"></p>
<pre><code class="language-java">//广度优先遍历--层次遍历
    public static void level(TreeNode head){
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(head);
        while (!queue.isEmpty()){
            TreeNode treeNode =queue.poll();
            System.out.println(treeNode.data);
            if(treeNode.leftChild!=null){
                queue.offer(treeNode.leftChild);
            }
            if(treeNode.rightChild!=null){
                queue.offer(treeNode.rightChild);
            }

        }

    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工厂模式]]></title>
        <id>https://aruul.github.io/post/PdwpIn0xO/</id>
        <link href="https://aruul.github.io/post/PdwpIn0xO/">
        </link>
        <updated>2021-05-10T13:24:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="工厂模式">工厂模式</h2>
<h3 id="1前言">1.前言</h3>
<p>设计模式大二的时候就学了，但是现在有些也忘得差不多了，现在决定重新学一遍。</p>
<p>立个flag，一周至少学三种设计模式。</p>
<blockquote>
<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<h3 id="2简单工厂模式">2.简单工厂模式</h3>
<p><strong>应用实例：</strong> 你需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</p>
<hr>
<pre><code class="language-java">/** 简单(静态)工厂模式
 * @author aRu
 * @date 2021/5/8 15:31
 */
public class CarFactory {
    public static Car getCar(String name){
        if(name.equals(&quot;大众&quot;)){
            return new DaZhong();
        }else if (name.equals(&quot;五菱&quot;)){
            return new WuLing();
        }
        return null;
    }
}
</code></pre>
<pre><code class="language-java">/**抽象汽车类
 * @author aRu
 * @date 2021/5/8 15:28
 */
public interface Car {
    void Name();
}
</code></pre>
<pre><code class="language-java">/** 大众
 * @author aRu
 * @date 2021/5/8 15:29
 */
public class DaZhong implements Car{
    @Override
    public void Name() {
        System.out.println(&quot;大众&quot;);
    }
}

----------------------------------------------------------------------------------------
    
/**五菱
 * @author aRu
 * @date 2021/5/8 15:30
 */
public class WuLing implements Car{
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}

</code></pre>
<p>测试</p>
<pre><code class="language-java">/** 测试类
 * @author aRu
 * @date 2021/5/8 15:34
 */

//测试 简单(静态)工厂模式
public class Test {
    public static void main(String[] args) {
        Car car1 = CarFactory.getCar(&quot;大众&quot;);
        Car car2 = CarFactory.getCar(&quot;五菱&quot;);

        car1.Name();
        car2.Name();
    }
}
</code></pre>
<hr>
<p><strong>缺点</strong>：试想当老板提出新需求要加一辆本田汽车的时候，你会发现，你此时不得不去修改<strong>CarFactory</strong>这个类，这就违反了开闭原则.</p>
<h3 id="3方法工厂模式">3.方法工厂模式</h3>
<p>针对上面简单工厂的缺点，我们引出方法工厂模式。</p>
<p>在方法工厂模式中，我们将<strong>工厂抽象起来</strong>，使得每个品牌的汽车都有自己的工厂，而不是像简单工厂模式里，一个大工厂建造不同品牌的车。</p>
<p>当我们需要新添加汽车时，只需要添加新的汽车类和对应的工厂就好。</p>
<hr>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508161257.png" alt="image-20210508161255712" loading="lazy"></figure>
<pre><code class="language-java">//抽象汽车工厂
public interface CarFactory {
    Car getCar();
}
</code></pre>
<pre><code class="language-java">//具体的汽车工厂  
public class WuLingFactory implements CarFactory{
    //五菱工厂
    @Override
    public Car getCar() {
        return new WuLing();
    }
}

----------------------------------------------
 public class DaZhongFactory implements CarFactory{
     //大众工厂
    @Override
    public Car getCar() {
        return new DaZhong();
    }
}
</code></pre>
<pre><code class="language-java">//抽象汽车类
public interface Car {
    void Name();
}
</code></pre>
<pre><code class="language-java">//具体汽车类
public class WuLing implements Car {
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}
----------------------------------------
public class WuLing implements Car {
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//方法工厂模式测试public class Test {    public static void main(String[] args) {        Car car = new WuLingFactory().getCar();        Car car2 = new DaZhongFactory().getCar();        car.Name();        car2.Name();    }}
</code></pre>
<h4 id="4抽象工厂模式">4.抽象工厂模式</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC25. K个一组翻转链表.]]></title>
        <id>https://aruul.github.io/post/ofb0ZIr8t/</id>
        <link href="https://aruul.github.io/post/ofb0ZIr8t/">
        </link>
        <updated>2021-05-09T13:15:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509195221.png" alt="image-20210509195220283" loading="lazy"></figure>
<pre><code class="language-java">输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
</code></pre>
</blockquote>
<h3 id="补充">补充</h3>
<p>ListNode定义如下</p>
<pre><code class="language-java">public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
</code></pre>
<h3 id="解法">解法</h3>
<pre><code class="language-java">    public static ListNode reverseKGroup(ListNode head, int k) {

        if(head == null) return head;
        ListNode a = head;
        ListNode b = head;
        for (int i = 0; i &lt; k; i++) {
            if(b == null) return head;
            b = b.next;
        }
        ListNode newNode = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newNode;
    }

    // 反转[a,b)个节点
    public static ListNode reverse(ListNode a, ListNode b) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=b){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<h3 id="思路">思路</h3>
<p>首先，由一道和他类似的题<a href="https://leetcode-cn.com/problems/reverse-linked-list/">【<strong>LC206. 反转链表</strong>】</a>引出我的解法。</p>
<p>在我之前的博客中这道题采用了递归解法。</p>
<p>其实，还有还可以用while循环来解。</p>
<pre><code class="language-java">    public static ListNode reverse(ListNode a) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<p>上面的代码完成了 给定一个链表头a，将这个链表反转。</p>
<p>具体步骤如下：</p>
<p>这是链表的初始状态：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509200639.png" alt="image-20210509200638636" loading="lazy"></figure>
<hr>
<hr>
<p>然后开始执行该函数, 将【前置节点pre】指为null，将【当前节点cur】指向a</p>
<pre><code class="language-java"> ListNode pre,cur,next;
 pre = null;
 cur = a;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509201429.png" alt="image-20210509201427829" loading="lazy"></figure>
<hr>
<hr>
<p>当【当前节点cur】不为空的时候，将【next节点】指向【当前节点cur的下一个】</p>
<pre><code class="language-java">while(cur!=null){
            next = cur.next;
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509201824.png" alt="image-20210509201823579" loading="lazy"></figure>
<hr>
<hr>
<p>之后将【当前节点cur】指向【前置节点pre】</p>
<pre><code class="language-java">cur.next = pre;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204604.png" alt="image-20210509204603462" loading="lazy"></figure>
<hr>
<hr>
<p>然后【pre、cur】开始向后移动一个节点，即：</p>
<ul>
<li>将【前置节点pre】移动到【当前节点cur】的位置</li>
<li>将【当前节点cur】移动到【后置节点next】的位置</li>
</ul>
<p><mark>注意：这时候没有移动next是因为不确定移动后【cur】是否为null。</mark></p>
<p><mark>当【cur】为null的时候再移动【后置节点next】会抛出空指针异常。这也是为什么循环的条件是【cur】不为null</mark></p>
<pre><code class="language-java">pre = cur;
cur = next;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204700.png" alt="image-20210509204659403" loading="lazy"></figure>
<hr>
<p>之后在while的循环条件中判断【cur】是否为空， 不为空则进入循环</p>
<p>进入循环中，重复之前的操作。将【next节点】指向【当前节点cur的下一个】</p>
<pre><code class="language-java">next = cur.next;
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204748.png" alt="image-20210509204747387" loading="lazy"></figure>
<hr>
<hr>
<p>之后将【当前节点cur】指向【前置节点pre】</p>
<pre><code class="language-java">cur.next = pre;
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204827.png" alt="image-20210509204825846" loading="lazy"></figure>
<hr>
<p>然后【pre、cur】开始向后移动一个节点，即：</p>
<ul>
<li>将【前置节点pre】移动到【当前节点cur】的位置</li>
<li>将【当前节点cur】移动到【后置节点next】的位置</li>
</ul>
<pre><code class="language-java">pre = cur;
cur = next;
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204904.png" alt="image-20210509204902250" loading="lazy"></figure>
<hr>
<p>以此类推，直到【当前节点cur】为null，停止循环，返回【前置节点pre】</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205131.png" alt="image-20210509205128892" loading="lazy"></figure>
<hr>
<p>那反转链表的一部分呢，比如反转【a，b）之间的节点 （左闭右开）</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205450.png" alt="image-20210509205449221" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205552.png" alt="image-20210509205551013" loading="lazy"></figure>
<p>你会发现，它其实和我们反转整个链表差不多，反转整个链表的时候，</p>
<p>是相当于反转【a，null）之间的节点，</p>
<p>和反转【a，b）之间的节点有异曲同工之妙啊~</p>
<p>所以说，反转【a，b）之间的节点的代码就应该在他的基础改一改，把</p>
<pre><code class="language-java">while(cur!=null)
</code></pre>
<p>改为</p>
<pre><code class="language-java">while(cur!=b)
</code></pre>
<p>代码如下：</p>
<pre><code class="language-java">    // 反转[a,b)个节点
    public static ListNode reverse(ListNode a, ListNode b) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=b){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<hr>
<p>这和 K个一组翻转链表反转 有啥子关系呢？</p>
<p>每K个一组就是相当于区间【a，b）之间的节点有K个，然后一一反转。</p>
<p>这就用到了递归</p>
<pre><code class="language-java">    public static ListNode reverseKGroup(ListNode head, int k) {

        if(head == null) return head;
        // 区间 [a, b) 包含 k 个待反转元素
        ListNode a = head;
        ListNode b = head;
        for (int i = 0; i &lt; k; i++) {
             // 不足 k 个，不需要反转
            if(b == null) return head;
            b = b.next;
        }
        // 反转前 k 个元素,并获得反转后的头节点
        ListNode newNode = reverse(a, b);
        // 递归反转后续链表并连接起来，这里a反转后由子节点中由头变为尾，所以和a.next拼接
        a.next = reverseKGroup(b, k);
        return newNode;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC206链表反转]]></title>
        <id>https://aruul.github.io/post/hM2JnmBVE/</id>
        <link href="https://aruul.github.io/post/hM2JnmBVE/">
        </link>
        <updated>2021-05-08T10:41:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508164053.png" alt="image-20210508164052248" loading="lazy"></figure>
<p>输入：head = [1,2,3,4,5]<br>
输出：[5,4,3,2,1]</p>
</blockquote>
<h3 id="补充">补充</h3>
<p>ListNode定义如下</p>
<pre><code class="language-java">public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
</code></pre>
<h3 id="解法">解法</h3>
<p>我之前刚好看过这个题的解析教程，所以就用递归小小的装个逼</p>
<pre><code class="language-java"> public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }

        ListNode last = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return last;
    }
</code></pre>
<p><strong>大概思路如下：</strong></p>
<p>这个递归其实做的是：</p>
<p>​	如果这和链表是个空的或者只有一个节点，则反转之后还是本身。</p>
<pre><code class="language-java">if(head==null||head.next==null){
            return head;
 }
</code></pre>
<hr>
<p>​	如果不是，则一直查找下一个节点，</p>
<pre><code class="language-java">ListNode last = reverseList(head.next);
</code></pre>
<hr>
<p>​	直到某个节点的next的next为null【其实就是找倒数第二个节点】</p>
<pre><code class="language-java">if(head==null||head.next==null){
     return head;
 }
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508165935.png" alt="image-20210508165933723" loading="lazy"></figure>
<hr>
<p>并将last=最后一个节点</p>
<pre><code class="language-java">ListNode last = reverseList(head.next);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170116.png" alt="image-20210508170111643" loading="lazy"></figure>
<hr>
<p>此时head=倒数第二个节点</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170608.png" alt="image-20210508170602536" loading="lazy"></figure>
<hr>
<p>在将此时head的next的next指向head，【其实就是把最后一个节点指向倒数第二个，做的就是反转链表】</p>
<pre><code class="language-java">head.next.next = head;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170950.png" alt="image-20210508170948257" loading="lazy"></figure>
<hr>
<p>这时候 将head.next=null 【把head指向空】</p>
<pre><code class="language-jav">head.next = null;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508171248.png" alt="image-20210508171244794" loading="lazy"></figure>
<hr>
<p>这时候，其实已经反转了一部分了。</p>
<p>然后再将last返回给上一级【也就是3】，此时last=最后一个节点【也就是5】。</p>
<p><strong>其他的节点 以此类推，直到结束</strong></p>
<p><strong>最后的时候，再返回一个last，也就是5</strong></p>
<h2 id=""><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508183828.png" alt="image-20210508183826788" loading="lazy"></h2>
<p>结束</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java反射(2)  反射调用的性能和优化方案]]></title>
        <id>https://aruul.github.io/post/L4U-TAPK3/</id>
        <link href="https://aruul.github.io/post/L4U-TAPK3/">
        </link>
        <updated>2021-05-04T08:51:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="反射调用的性能和优化方案">反射调用的性能和优化方案</h2>
<h3 id="对比">对比</h3>
<p>普通方法</p>
<pre><code class="language-java">    //普通方法
    public static void m1(){
        Cat cat = new Cat();

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            cat.say();
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;普通方法执行时间：&quot;+(end-start));
    }
</code></pre>
<p>通过反射</p>
<pre><code class="language-java">//反射
    public static void m2() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class aClass = Class.forName(&quot;org.example.Cat&quot;);
        Object o = aClass.newInstance();
        Method say = aClass.getMethod(&quot;say&quot;);

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            say.invoke(o);
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;反射机制执行时间：&quot;+(end-start));


    }
</code></pre>
<p>两者运行时间对比</p>
<pre><code>普通方法执行时间：3 ms
反射机制执行时间：175 ms
</code></pre>
<h3 id="优化">优化</h3>
<blockquote>
<p>反射调用优化-关闭访问检查</p>
<ol>
<li>Method和 Field、 Constructor象都有 setAccessible()方法</li>
<li>setAccessible()作用是启动和禁用访问安全检查的开关<br>
3.参数值为true表示反射的对象在使用时取消访向检查，提高反射的效率。<br>
参数值为 false则表示反射的对象执行访向检查</li>
</ol>
</blockquote>
<p>所以可以通过setAccessible()来优化反射。</p>
<p>其实呢，优化之后效率也没有高出很多。</p>
<pre><code class="language-java">    //反射优化
    public static void m3() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class aClass = Class.forName(&quot;org.example.Cat&quot;);
        Object o = aClass.newInstance();
        Method say = aClass.getMethod(&quot;say&quot;);

        //取消在反射调用方法时 取消访问检测
        say.setAccessible(true);


        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            say.invoke(o);
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;反射优化机制执行时间：&quot;+(end-start));

    }
</code></pre>
<hr>
<p>执行结果对比</p>
<pre><code>普通方法执行时间：3 ms
反射机制执行时间：176 ms
反射优化机制执行时间：129 ms
</code></pre>
]]></content>
    </entry>
</feed>