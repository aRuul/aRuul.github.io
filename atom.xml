<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aruul.github.io</id>
    <title>aRuul的无名小站</title>
    <updated>2021-07-19T09:41:16.555Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aruul.github.io"/>
    <link rel="self" href="https://aruul.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aruul.github.io/images/avatar.png</logo>
    <icon>https://aruul.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, aRuul的无名小站</rights>
    <entry>
        <title type="html"><![CDATA[JVM-02 类加载子系统]]></title>
        <id>https://aruul.github.io/post/HnC917QY2/</id>
        <link href="https://aruul.github.io/post/HnC917QY2/">
        </link>
        <updated>2021-07-18T09:32:19.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210717153813.png" alt="image-20210717153811503" loading="lazy"><br>
<strong>加载--&gt; 链接--&gt; 初始化</strong></p>
<p><strong>如果自己手写一个java虚拟机的话，主要考虑哪些结构？  类加载器和执行引擎</strong></p>
<h2 id="类的加载过程">类的加载过程</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210717154605.png" alt="image-20210717154600485" loading="lazy"></figure>
<ul>
<li>类加载子系统负责从文件系统或者网络系统中加载Class文件，class文件在文件开头有特定的文件标识</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则是由Execution Engine来jued</li>
<li>加载的<strong>类信息存放在一块成为方法区</strong>的内存空间。</li>
<li>除了类的信息之外，<strong>方法区还会存放运行时的常量池信息</strong>，可能还包括<strong>字符串常量和数字常量</strong>（这部分常量信息是Class文件中常量池部分的内存映射）</li>
</ul>
<hr>
<p>具体的类加载过程图</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210717160036.png" alt="image-20210717160035120" loading="lazy"></figure>
<h3 id="第一步-加载-生成-javalangclass对象">第一步 加载 --生成 java.lang.Class对象</h3>
<ol>
<li>通过一个类的全限定名获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态数据结构转化为方法区的运行时数据结构</li>
<li>在内存中<strong>生成</strong>一个代码这个类的  <strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h3 id="第二步-链接">第二步 链接</h3>
<h4 id="1验证-verify">1.<strong>验证( Verify):</strong></h4>
<ul>
<li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证</li>
</ul>
<blockquote>
<p>java .class文件开头是COFFBABE</p>
</blockquote>
<h4 id="2准备-prepare">2.<strong>准备( Prepare):</strong></h4>
<ul>
<li>
<p>为<strong>类变量</strong>分配内存并且设置该类变量的<strong>默认初始值</strong>，即零值。</p>
<pre><code class="language-java">class Demo{
    //这时a会被赋值为0，在初始化时才会被初始化为1
    private static int a = 1;
}
</code></pre>
</li>
<li>
<p>这里<strong>不包含用final修饰的 static</strong>,因为<strong>final在编译的时候就会分配了</strong>，准备阶段会显式初始化</p>
</li>
<li>
<p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而<strong>实例变量</strong>是会随着对象一起分<br>
配到<strong>java堆</strong>中。</p>
</li>
</ul>
<h4 id="3解析-resolve">3.<strong>解析( Resolve)</strong></h4>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>事实上，解析操作住住会伴随着JVM在执行完初始化之后再执行。</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的<br>
CONSTANT Class info CONSTANT Fieldref info, CONSTANT Methodref info</li>
</ul>
<h3 id="第三步-初始化">第三步 初始化</h3>
<ul>
<li>
<p>初始化阶段就是执行<strong>类的构造器方法 <clinit>()</strong> 的过程（cl可以理解为 class  ，init为 inital）</p>
</li>
<li>
<p>此方法不需要定义，是javac编译器自动收集类中的所有变量的赋值动作和静态代码块中的语句合并而来的。</p>
</li>
<li>
<p>构造器方法按语句顺序执行所有<strong>类变量</strong>（static修饰的成员变量）显式初始化和<strong>静态代码块中语句</strong></p>
<pre><code class="language-java">/*这里的话，a最终的值为1
* 首先在第二步链接的准备阶段，会将a初始化为0
* 在第三步初始化时，类的构造器方法按照顺序执行，先将a赋值为10，再将a赋值为1，所以最后a=1
*/
class Demo{
    static{
        a = 10;
    }
    private static int a = 1;
}
</code></pre>
</li>
<li>
<p><strong>类的构造器方法 <clinit>()</strong> 不同于类的构造函数，<mark>当一个类中不存在类变量的时候，则.class文件中没有<clinit>()</mark></p>
</li>
<li>
<p>若该类有父类，JVM会保证父类的 <clinit>()执行完毕之后再执行子类的<clinit>()</p>
<pre><code class="language-java">class Father{
    public static int a = 1;
    static{
        a = 2;
    }
}

class Son extends Father{
    public static int b = a;
    
    public static void main(String []args){
        //最终的结果为2
        Sysytem.out.println(Son.b);
    }
}
</code></pre>
</li>
<li>
<p>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁，即<mark>一个类只会被加载一次</mark>、</p>
</li>
</ul>
<h2 id="类的加载器">类的加载器</h2>
<h3 id="类加载器分类">类加载器分类</h3>
<p>JVM支持<strong>两种</strong>类型的<strong>类加载器</strong>，分别为</p>
<ol>
<li><strong>引导加载器</strong>(Bootstrap ClassLoader)</li>
<li>**自定义加载器(**User-Defined ClassLoader)，<strong>是指继承自ClassLoader的加载器</strong></li>
</ol>
<hr>
<h3 id="虚拟机自带的加载器">虚拟机自带的加载器</h3>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210718143804.png" alt="image-20210718143802701" loading="lazy"></figure>
<h4 id="启动类加载器引导类加载器-bootstrap-classloader">启动类加载器(引导类加载器 Bootstrap ClassLoader)</h4>
<ul>
<li>
<p>我们不能直接获取到</p>
</li>
<li>
<p>java的<strong>核心类库</strong>都是使用<strong>引导类加载器</strong>来进行加载的。</p>
</li>
<li>
<p>这个类加载使用C++/C来实现的，嵌套在JVM内部</p>
</li>
<li>
<p>并不继承于java.lang.ClassLoader</p>
</li>
<li>
<p><strong>加载扩展类和程序类加载器，并指定为它们的父加载器</strong></p>
</li>
<li>
<p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
</ul>
<h4 id="拓展类加载器extension-classloader">拓展类加载器(Extension ClassLoader)</h4>
<ul>
<li>java语言编写</li>
<li>派生于ClassLoader类</li>
<li>父加载器为启动类加载器</li>
<li>从java。ext.dirs系统属性所指定的目录中加载类库，或者从JDK安装目录的jre/lib/ext子目录下加载类库。<strong>如果用户创建的jar在此目录下，也会自动由扩展类加载器加载</strong></li>
</ul>
<h4 id="应用程序类加载器系统类加载器appclassloader">应用程序类加载器(系统类加载器AppClassLoader)</h4>
<ul>
<li>java语言编写</li>
<li>派生于ClassLoader类</li>
<li><strong>父加载器为拓展类加载器</strong></li>
<li>负责加载<strong>环境变量classpath</strong>或<strong>系统属性java.class.path</strong>指定路径下的类库</li>
<li><strong>我们自己写的类中默认加载器就是应用程序类加载器</strong></li>
</ul>
<h3 id="用户自定义加载类">用户自定义加载类</h3>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210718151628.png" alt="image-20210718151625921" loading="lazy"></figure>
<h2 id="classloader">ClassLoader</h2>
<p><strong>ClassLoader类是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动加载类)</strong></p>
<p>这里暂且了解就够了（嗯，大概</p>
<h2 id="双亲委派机制">双亲委派机制</h2>
<blockquote>
<p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是需要的时候才会将它的class文件加载到内存，生成class对象。</p>
<p>而在加载某个类的class文件时，JVM采用<strong>双亲委派模式</strong>，即把请求交给父类处理，是一种任务委派模式。</p>
</blockquote>
<p><strong>双亲委派机制</strong>：</p>
<ol>
<li>
<p>当一个类加载器收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，</p>
</li>
<li>
<p>如果父类还有父类加载器，则进一步向上委托，以此类推，直到顶层的启动类加载器</p>
</li>
<li>
<p>如果父类加载器可以完成加载任务，则成功返回；否则，子类加载器尝试去加载</p>
</li>
</ol>
<p><mark>可以理解为 类加载器这个家族很重亲情，能爸爸做的就爸爸做，爸爸实在做不了就儿子做</mark></p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210718154732.png" alt="image-20210718154731162" loading="lazy"></figure>
<p>优势：</p>
<ul>
<li>
<p>避免类的重复加载</p>
</li>
<li>
<p>保护程序的安全，防止核心api被随意的篡改</p>
<p>比如你自定义一个包 java.lang,包下面有一个类Demo</p>
<pre><code class="language-java">package java.lang
class Demo{
    public static void main(String[] args){
        System.out.println(&quot;test&quot;);
    }
}
</code></pre>
<p>当你运行的时候，由于双亲委派机制，这和Demo类是java开头的，所以最终的加载器是引导类加载器。(引导类加载器只加载包名为java、javax、sun等开头的类)，而java核心类包中并没有Demo这个类，所以就会报错。</p>
</li>
</ul>
<h2 id="其他小的点">其他小的点</h2>
<h3 id="在jvm中表示两个class对象相同的两个必要条件">在JVM中表示两个class对象相同的两个必要条件：</h3>
<ol>
<li>类的完整类名要一致，包括包名</li>
<li>加载 这个类的ClassLoader(指ClassLoader实例对象)必须相同。</li>
</ol>
<h3 id="对类加载器的引用">对类加载器的引用</h3>
<ol>
<li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。</li>
<li>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。</li>
<li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM-01 概述]]></title>
        <id>https://aruul.github.io/post/0D3cevlgX/</id>
        <link href="https://aruul.github.io/post/0D3cevlgX/">
        </link>
        <updated>2021-07-16T08:47:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java虚拟机jvm">java虚拟机JVM</h2>
<p>java虚拟机是一台执行java字节码的虚拟计算机，它拥有独立的运行机制，其运行的java字节码也未必由java语言编译而成。</p>
<p>JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收机制以及可靠的即时编译器。java技术的核心就是java虚拟机（jvm，java virtual machine）</p>
<h2 id="jvm的位置">JVM的位置</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200358.png" alt="image-20210716200357558" loading="lazy"></figure>
<p>jvm是运行在操作系统之上的，没有和硬件直接交互</p>
<h2 id="jvm的整体结构">JVM的整体结构</h2>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200827.png" alt="image-20210716200826280" loading="lazy"></figure>
<p>​															<mark>要求会自己画出这张图</mark></p>
<ul>
<li>HotSport VM是目前市面上最高性能的虚拟机的代表作之一。</li>
<li>它采用解释器与即时编译器并存的架构</li>
</ul>
<h2 id="java代码执行流程">java代码执行流程</h2>
<p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p>
<p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong></p>
<p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进JVM里面来。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200206.png" alt="image-20210716200204379" loading="lazy"></figure>
<p>==由于跨平台的设计，java的指令都是根据栈来设计的。==跨平台性，指令集小，指令多。</p>
<p>相对于基于寄存器的架构，基于栈的架构的执行性能相比寄存器来说要差一些</p>
<h2 id="jvm的生命周期">JVM的生命周期</h2>
<p><strong>java虚拟机的启动</strong>是通过引导类类(bootstrap class loader)创建一个初始化类(initial class)来完成，这个类是有虚拟机的具体实现指定的。</p>
<p><strong>虚拟机的执行:</strong> 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序<br>
程序开始执行时他才运行，程序结束时他就停止<br>
执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</p>
<p><strong>虚拟机的退出</strong><br>
有如下的几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而异致Java虚拟机进程终止</li>
<li>某线程调用 Runtime类或 system类的exit方法，或 Runtime类的halt<br>
方法，并且Java安全管理器也允许这次exit或halt操作</li>
<li>除此之外，JNI( Java Native Interface)规范描述了用JNI Invocation APｴ来加载或卸载Java虚拟机时，Java虚拟机的退出情况</li>
</ul>
<h2 id="hotspot虚拟机">HotSpot虚拟机</h2>
<p>不管是JDK6还是最常用的JDK8，默认虚拟机都是HotSpot</p>
<blockquote>
<p>名称中的 Hotspot指的就是它的热点代码探测技术。<br>
通过计数器找到最具编译价值代码，触发即时编译或上替拧<br>
通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</p>
</blockquote>
<hr>
<p>Graal VM  ---&quot;Run Programs Faster Anywhere&quot;  最有可能替代HotSpot。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java多线程]]></title>
        <id>https://aruul.github.io/post/h25epdEh9/</id>
        <link href="https://aruul.github.io/post/h25epdEh9/">
        </link>
        <updated>2021-07-15T08:25:56.000Z</updated>
        <content type="html"><![CDATA[<p><strong>最近准备秋招，就开始之前java内容的复习，把复习过程中一些基本知识记录了下来，预祝自己秋招顺利吧。</strong></p>
<h2 id="基础篇">基础篇</h2>
<h3 id="1进程和线程">1.进程和线程</h3>
<blockquote>
<p>进程就是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。</p>
<p><strong>一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p>
</blockquote>
<p>进程和线程的提出极大的提高了操作系统的性能。<strong>进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。</strong></p>
<h4 id="11进程和线程的区别">1.1进程和线程的区别</h4>
<p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是<strong>是否单独占有内存地址空间及其它系统资源（比如I/O）</strong>：</p>
<ul>
<li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</li>
<li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li>
<li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li>
</ul>
<p>另外一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即CPU分配时间的单位 。</p>
<h4 id="12上下文切换">1.2上下文切换</h4>
<p>上下文切换有时也叫做线程切换或者任务切换，是指cpu从一个进程（或线程）切换到另一个进程或（者线程）。上下文是指某一个时间点cpu寄存器和程序计数器的内容。</p>
<p>举例说明 线程A ---&gt; B</p>
<p>1.先挂起线程A，将其在cpu中的状态保存在内存中。</p>
<p>2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。</p>
<p>3.当B执行完，根据程序计数器中指向的位置恢复线程A。</p>
<hr>
<h3 id="2java多线程入门类和接口">2.Java多线程入门类和接口</h3>
<p>JDK提供了<code>Thread</code>类和<code>Runnable</code>接口来让我们实现自己的“线程”类。</p>
<ul>
<li>继承<code>Thread</code>类，并重写<code>run</code>方法；</li>
<li>实现<code>Runnable</code>接口的<code>run</code>方法；</li>
</ul>
<h4 id="21-继承thread类">2..1 继承<code>Thread</code>类</h4>
<pre><code class="language-java">public class MyThread_01 extends Thread{
    @Override
    public void run() {
        System.out.println(&quot;MyThread_01 run&quot;);
    }

    public static void main(String[] args) {
        MyThread_01 myThread_01 = new MyThread_01();
        myThread_01.start();
    }
}
</code></pre>
<p>注意要调用<code>start()</code>方法后，该线程才算启动！</p>
<blockquote>
<p>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。</p>
<p>注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出illegalThreadStateException异常。</p>
</blockquote>
<h4 id="22实现runnable接口">2.2实现Runnable接口</h4>
<p>略</p>
<hr>
<h2 id="小细节">小细节</h2>
<p>当main线程启动一个线程的时候，main线程并不会阻塞，会和新开的线程交替执行</p>
<pre><code class="language-java">public class Demo1 extends Thread{
    @Override
    public void run() {
        for (int i=0; i&lt;5;i++){
            try {
                Thread.sleep(500);
                System.out.println(&quot;线程启动了...【&quot;+ Thread.currentThread().getName()+&quot;】&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo1 demo1 = new Demo1();
        demo1.start();

        for (int i = 0; i &lt; 5; i++) {
            System.out.println(&quot;main 线程启动&quot;);
            Thread.sleep(1000);
        }
    }

}
</code></pre>
<p>运行结果：</p>
<blockquote>
<p>main 线程启动<br>
线程启动了...【Thread-0】<br>
main 线程启动<br>
线程启动了...【Thread-0】<br>
线程启动了...【Thread-0】<br>
main 线程启动<br>
线程启动了...【Thread-0】<br>
线程启动了...【Thread-0】<br>
main 线程启动<br>
main 线程启动</p>
<p>Process finished with exit code 0</p>
</blockquote>
<p>实现Runnable接口的方式更加适合多个线程共享一个资源的情况</p>
<hr>
<h2 id="jdk18新特性lamda表达式">jdk1.8新特性Lamda表达式</h2>
<p>属于函数式编程</p>
<p>lambda 表达式的语法格式如下：</p>
<pre><code class="language-java">(parameters) -&gt; expression 
</code></pre>
<p>或</p>
<pre><code class="language-java"> (parameters) -&gt;{ statements; }
</code></pre>
<pre><code class="language-java">public class MyLamda {
    public static void main(String[] args) {
        Like like = ()-&gt;{
            System.out.println(&quot;i like java lamda&quot;);
        };
        like.say();
    }
}

interface Like{
    void say();
}
</code></pre>
<h2 id="线程的状态">线程的状态</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210714161606.png" alt="image-20210714161604425" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210714190304.png" alt="image-20210714190303037" loading="lazy"></figure>
<hr>
<h2 id="线程的优先级">线程的优先级</h2>
<p>java中优先级可以指定，范围是1——10（从低到高），<strong>默认优先级为5</strong></p>
<p><strong>但是，并不一定是优先级越高越先执行</strong>，要取决于操作系统，java只是给操作系统一个优先级的参考值，线程最终在操作系统的优先级还是由操作系统决定的。</p>
<p>我们使用方法<code>Thread</code>类的<code>setPriority()</code>实例方法来设定线程的优先级。</p>
<h2 id="守护线程">守护线程</h2>
<p>在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)</p>
<p>如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<p><mark>当主线程结束之后，守护线程也就结束</mark></p>
<pre><code class="language-java">public class ShouHu {
    public static void main(String[] args) {

        Runnable runnable=()-&gt;{
            for( ; ; ){
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;我是守护线程&quot;);
            }
        };

        Thread thread = new Thread(runnable);
        thread.setDaemon(true);
        thread.start();

        for (int i = 0; i &lt; 5; i++) {
            System.out.println(&quot;main线程&quot;);
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<h2 id="线程同步">线程同步</h2>
<blockquote>
<p>在多线程编程，一些敏感数据不允许被多个线程同时访向，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访向，以保证数据的完整性</p>
</blockquote>
<h3 id="synchronized">synchronized</h3>
<p><strong>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</strong></p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<h2 id="死锁">死锁</h2>
<p><strong>产生死锁的四个必要条件：</strong><br>
1.互斥条件：一个资源每次只能被一个进程使用。<br>
2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放<br>
3.不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>
4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210715145533.png" alt="image-20210715145531281" loading="lazy"></figure>
<h2 id="释放锁">释放锁</h2>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210715145649.png" alt="image-20210715145648921" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210715150000.png" alt="image-20210715145957974" loading="lazy"></figure>
<h2 id="lock锁">Lock锁</h2>
<blockquote>
<p>1、从Java5开始，Java提供了一种功能更强大的线程同步机制——通过显式定义同步锁对象来实现同步，在这种机制下，同步锁由Lock对象充当。</p>
<p>2、Lock 提供了比synchronized方法和synchronized代码块更广泛的锁定操作，Lock允许实现更灵活的结构，可以具有差别很大的属性，并且支持多个相关的Condition对象。</p>
<p>3、Lock是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p>
<p>4、某些锁可能允许对共享资源并发访问，如ReadWriteLock（读写锁），Lock、ReadWriteLock是Java5提供的两个根接口，并为Lock 提供了ReentrantLock（可重入锁）实现类，为ReadWriteLock提供了ReentrantReadWriteLock 实现类。</p>
<p>5、Java8新增了新型的StampedLock类，在大多数场景中它可以替代传统的ReentrantReadWriteLock。ReentrantReadWriteLock 为读写操作提供了三种锁模式：Writing、ReadingOptimistic、Reading。</p>
</blockquote>
<pre><code class="language-java">public class MyLock {
    public static void main(String[] args) {
        TestLock testLock = new TestLock();
        new Thread(testLock).start();
        new Thread(testLock).start();
        new Thread(testLock).start();
    }
}

class TestLock implements Runnable{
    private int tickets = 100;
    //定义锁
    private final ReentrantLock reentrantLock = new ReentrantLock();

    @Override
    public void run() {
        while (true){
            //加锁
            reentrantLock.lock();
            if(tickets&lt;=0){
                break;
            }
            System.out.println(Thread.currentThread().getName()+&quot;, &quot;+(tickets--));
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                //解锁
                reentrantLock.unlock();
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代理模式]]></title>
        <id>https://aruul.github.io/post/YYF012ILo/</id>
        <link href="https://aruul.github.io/post/YYF012ILo/">
        </link>
        <updated>2021-07-04T07:51:46.000Z</updated>
        <content type="html"><![CDATA[<p>代理模式简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>代理模式有静态代理和动态代理两种实现方式。</p>
<h2 id="静态代理">静态代理</h2>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>例如：小明想要打官司，则他需要找到代理律师来帮他</p>
<p>​			代理律师负责将小明想说的话说出去，并在小明说话前面引用法律条文，在小明说话后发动道德谴责。</p>
<p>代码：</p>
<pre><code class="language-java">//说话的行为接口
interface Say{
    void sayMessage(String m);
}
//小明
class XiaoMing implements Say{
    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;小明说出案情--by&quot;+m);
    }
}

//静态代理 王律师
class LawyerWang implements Say{
    private final Say say;

    public LawyerWang(Say say) {
        this.say = say;
    }

    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;引用法律条文&quot;);
        say.sayMessage(m);
        System.out.println(&quot;使用道德谴责&quot;);
    }
}
</code></pre>
<p>但是当又有一人来找王律师的时候，就需要重写代理的代码，非常不实用。</p>
<hr>
<h2 id="动态代理">动态代理</h2>
<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<h3 id="jdk动态代理">JDK动态代理</h3>
<h3 id="介绍">介绍</h3>
<p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<ol>
<li><strong>InvocationHandler接口</strong></li>
</ol>
<blockquote>
<p>在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</p>
<pre><code>/**
 * 调用处理程序
 */
public interface InvocationHandler { 
    Object invoke(Object proxy, Method method, Object[] args); 
} 
复制代码
</code></pre>
<p>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。</p>
<p>当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中。</p>
<p>代理类对象作为proxy参数传入，</p>
<p>参数method标识了我们具体调用的是代理类的哪个方法，</p>
<p>args为这个方法的参数。</p>
<p>这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。<br>
作者：Chaexsy<br>
链接：https://juejin.cn/post/6844903591501627405<br>
来源：掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<ol start="2">
<li><strong><code>Proxy</code> 类</strong></li>
</ol>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<pre><code class="language-java">    public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        ......
    }Copy to clipboardErrorCopied
</code></pre>
<p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<hr>
<h3 id="接口和被代理委托方">接口和被代理(委托方)</h3>
<pre><code class="language-java">//说话的行为接口
interface Say{
    void sayMessage(String m);
}
//小明
class XiaoMing implements Say{
    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;小明说出案情--by&quot;+m);
    }
}
</code></pre>
<h3 id="中介类">中介类</h3>
<p>对于<strong>XiaoMing</strong>这个类来说<strong>LawyerProxy</strong>类是他的代理，构成了静态代理</p>
<pre><code class="language-java">class LawyerProxy implements InvocationHandler{
    final private Object object;

    public LawyerProxy(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;引用法律条文&quot;);
        method.invoke(object,args);
        System.out.println(&quot;使用道德谴责&quot;);
        return null;
    }
}
</code></pre>
<h3 id="实际调用">实际调用</h3>
<p>而对于<strong>LawyerProxy</strong>类来说，<strong>Proxy 类</strong>是它的代理，构成了静态代理</p>
<pre><code class="language-java">	//动态代理
  System.out.println(&quot;===动态代理===&quot;);
  LawyerProxy lawyerProxy = new LawyerProxy(new XiaoMing());
  Say s = (Say)Proxy.newProxyInstance(Say.class.getClassLoader(), new Class[]{Say.class}, lawyerProxy);
  s.sayMessage(&quot;动态代理类&quot;);
</code></pre>
<p>也就是说，<strong>动态代理关系由两组静态代理关系组成，这就是动态代理的原理</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反射（3）]]></title>
        <id>https://aruul.github.io/post/9RSSdqr6G/</id>
        <link href="https://aruul.github.io/post/9RSSdqr6G/">
        </link>
        <updated>2021-07-01T07:33:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="反射-得到对象的六种方式">反射-得到对象的六种方式</h3>
<pre><code class="language-java">  
        /*  1.Clss.forName
            已经知道一个类的全类名，
            应用场景：多用于配置文件，读取类全路径，加载类
        */
        final String classAllPath = &quot;org.example.Car&quot;;
        Class&lt;?&gt; cls1 = Class.forName(classAllPath);
        System.out.println(&quot;cls1 &quot;+cls1);

        /*  2.类名.class
            已经知道一个具体的类，
            应用场景：多用于参数传递，如通过反射得到对应的构造器对象
        */
        Class cls2 = Car.class;
        System.out.println(&quot;cls2 &quot;+cls2);

        /*  3.getClass()
            已经知道一个类的实例，调用该实例的getClass()方法获取Class对象，
            应用场景：通过创建好的对象，获取Class对象
        */
        Car car = new Car();
        Class cls3 = car.getClass();
        System.out.println(&quot;cls3 &quot;+cls3);

        /*  4.ClassLoader
            通过类加载器
            应用场景：
        */
        //(1)得到car类的加载器 
        ClassLoader classLoader = car.getClass().getClassLoader();
        //(2)通过类加载器，得到Class对象
        Class&lt;?&gt; cls4 = classLoader.loadClass(&quot;org.example.Car&quot;);
        System.out.println(&quot;cls4 &quot;+cls4);


        //cls1 cls2 cls3 cls4其实是同一个对象
        System.out.println(cls1.hashCode());
        System.out.println(cls2.hashCode());
        System.out.println(cls3.hashCode());
        System.out.println(cls4.hashCode());

        //5.基本数据类型获取Class对象
        Class&lt;?&gt; integerClass = int.class;
        System.out.println(integerClass);

        //6.基本数据类型对应的包装类，通过Type获取Class对象
        Class&lt;?&gt; type = Integer.TYPE;
        System.out.println(type);
</code></pre>
<hr>
<h3 id="反射-获取类相关的信息">反射-获取类相关的信息</h3>
<pre><code class="language-java">		Class&lt;?&gt; personClass = Class.forName(&quot;org.example.Person&quot;); //父类
        Class&lt;?&gt; studentClass = Class.forName(&quot;org.example.Student&quot;); //子类

        //获取全类名
        System.out.println(&quot;获取全类名&quot;+personClass.getName());

        //获取简单类名
        System.out.println(&quot;获取简单类名&quot;+personClass.getSimpleName());

        //获取所有public修饰的属性， 包括本类及父类
        Field[] fields = studentClass.getFields();
        System.out.println(&quot;获取所有public修饰的属性， 包括本类及父类&quot;);
        for (int i = 0; i &lt; fields.length; i++) {
            System.out.println(fields[i].getName());
        }

        //获取本类的所有属性
        Field[] fields2 = personClass.getDeclaredFields();
        System.out.println(&quot;获取本类的所有属性&quot;);
        for (int i = 0; i &lt; fields2.length; i++) {
            System.out.println(fields2[i].getName());
        }

        //获取本类和父类和超类所有public修饰的方法
        Method[] methods = studentClass.getMethods();
        System.out.println(&quot;获取本类和父类和超类所有public修饰的方法&quot;);
        for (int i = 0; i &lt; methods.length; i++) {
            System.out.println(methods[i].getName());
        }

        //获取本类中所有的方法
        Method[] methods2 = studentClass.getDeclaredMethods();
        System.out.println(&quot;获取本类中所有的方法&quot;);
        for (int i = 0; i &lt; methods2.length; i++) {
            System.out.println(methods2[i].getName());
        } 

        //获取本类所有public修饰的构造器，`
        Constructor[] constructors = studentClass.getConstructors();
        System.out.println(&quot;获取本类所有public修饰的构造器&quot;);
        for (int i = 0; i &lt; constructors.length; i++) {
            System.out.println(constructors[i].getName());
        }

        //获取本类所有构造器
        Constructor[] constructors2 = studentClass.getDeclaredConstructors();
        System.out.println(&quot;获取本类所有构造器&quot;);
        for (int i = 0; i &lt; constructors2.length; i++) {
            System.out.println(constructors2[i]);
        }

        //获取包名
        System.out.println(&quot;获取包名&quot;);
        System.out.println(studentClass.getPackage());

        //以Class的形式返回父类信息
        Class&lt;?&gt; superclass = studentClass.getSuperclass();
        System.out.println(&quot;以Class的形式返回父类信息&quot;);
        System.out.println(superclass);

        //以Class[]的形式返回接口信息
        Class[] interfaces = studentClass.getInterfaces();
        System.out.println(&quot;以Class[]的形式返回接口信息&quot;);
        for (int i = 0; i &lt; interfaces.length; i++) {
            System.out.println(interfaces[i]);
        }

        //以Annotation[]的形式得到注解信息
        Annotation[] annotations = studentClass.getAnnotations();
        System.out.println(&quot;以Annotation[]的形式得到注解信息&quot;);
        for (int i = 0; i &lt; annotations.length; i++) {
            System.out.println(annotations[i]);
        }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java中final变量的初始化]]></title>
        <id>https://aruul.github.io/post/Z708mjxH2/</id>
        <link href="https://aruul.github.io/post/Z708mjxH2/">
        </link>
        <updated>2021-06-15T04:18:56.000Z</updated>
        <content type="html"><![CDATA[<p>今天在看java中String的源码，发现了自己对final变量初始化的了解不够好，有遗漏的地方，之前只知道第一种初始化方法。</p>
<pre><code class="language-java">public class FinalStudy {
    //第一种 在定义后直接初始化
    private final int a = 1;
    //第二种 声明变量后在构造方法中为其赋值
    //如果采用用这种方式，那么每个构造方法中都要有j赋值的语句
    private final int b;
    public FinalStudy(int b) {
        this.b = b;
    }
    // 初始化方式三，声明变量后在构造代码块中为其赋值
    // 如果采用此方式，就不能在构造方法中再次为其赋值
    // 构造代码块中的代码会在构造函数之前执行，如果在构造函数中再次赋值，
    // 就会造成final变量的重复赋值
    private final int c;
    {
        c = 3;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iPad变成真正的生产力----编程]]></title>
        <id>https://aruul.github.io/post/EJmNDhozo/</id>
        <link href="https://aruul.github.io/post/EJmNDhozo/">
        </link>
        <updated>2021-05-16T11:54:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>iPad被知乎、b站很多人标榜为生产力，其实很早之前我一直觉得surface go才算生产力，毕竟可以编程。自己很偏激的把iPad看作电子垃圾。</p>
<p>但是，由于预算有限，我还是买了ipad2020 128G🤡，毕竟同等价位买surface go2的话，只能买个乞丐版的，而且还是裸机。</p>
<p>ipad买了之后我就有点小后悔，因为我发现我平时用ipad干的最多的就是读pdf，看视频。这完全可以被一个更便宜的安卓平板代替。</p>
<p>后来在想ipad上可不可以像surface go2那样配个键盘编程，于是就花买了一个罗技的蓝牙键盘，手感还不错，ipad、笔记本都可以用。一开始，我发现可以在leetcode网页上在线编程，但是这种在线编程有些难受；我便开始寻找新的解决方案。在ipad搜到了几个编程软件，但是都要付费，还挺贵，我就犹豫了。</p>
<p>就在今天，我刷知乎的时候，看到了github上的一个开源项目【<a href="https://github.com/cdr/code-server">code-server</a>】</p>
<h2 id="code-server">code-server</h2>
<blockquote>
<p><code>code-server</code> 实际上就是专门为浏览器设计优化的 VS Code，可以直接通过浏览器访问。</p>
<p>在远程 Linux 服务器上面部署 <code>code-server</code> 之后，<code>code-server</code> 实际上就相当于一个「中转站」，为我们提供一个直接在 Linux 服务器上面修改文件、访问数据库、执行指令等等操作的「窗口」，而由于这一「窗口」同样在 Linux 服务器上面运行，使用任何一个浏览器都可以打开，所以 iPad 也不例外。</p>
<p>这样，我们就能够借助在远程服务器上运行的 <code>code-server</code>，直接使用远程服务器上面的各种资源（包括服务器上强大的原生 Linux 环境、CPU / GPU 等计算资源、「无尽」的电量等等）进行开发工作。（当然，这也要求我们 iPad 端全程拥有网络连接。）</p>
</blockquote>
<p>所以说需要你有个服务器，非常巧的是我服务器基本上算是吃灰的状态，上面就跑了两个网址的服务。</p>
<h3 id="准备">准备</h3>
<p>我的服务器系统是ubuntu，在github【<a href="https://github.com/cdr/code-server/releases">code-server release</a>】中下载最新版的压缩包，并上传到服务器。</p>
<p>我选的是<a href="https://github.com/cdr/code-server/releases/download/v3.10.0/code-server-3.10.0-linux-amd64.tar.gz">code-server-3.10.0-linux-amd64.tar.gz</a></p>
<p>然后，你要在服务器上下载好screen，如果没下的话，执行一下快速安装命令就好</p>
<pre><code class="language-java">sudo apt-get install screen
</code></pre>
<h3 id="安装">安装</h3>
<p>进入code-server压缩包的目录，然后执行解压命令</p>
<pre><code class="language-java">tar -xvzf code-server-3.10.0-linux-amd64.tar.gz
</code></pre>
<p>再进入解压后的目录</p>
<pre><code class="language-java">cd code-server-3.10.0-linux-amd64
</code></pre>
<p>然后使用screen后台运行</p>
<pre><code>screen -S vscode
</code></pre>
<p>然后运行code-server</p>
<pre><code class="language-java">export PASSWORD=&quot;yourpassword&quot; &amp;&amp; ./code-server --port 888 --host 0.0.0.0 
</code></pre>
<ul>
<li>
<p><code>export PASSWORD=&quot;yourpassword&quot;</code>可以指定密码，将yourpassword替换为你的密码，<mark>引号不要去掉</mark></p>
<p>不加的话会默认生成一个，可以在运行后看到<code>yourpassword</code>为你的密码</p>
</li>
<li>
<p>--port 888为 指定端口运行，我这里是运行在888端口</p>
</li>
<li>
<p>--host 0.0.0.0 默认是127.0.0.1，只能本地访问，无法外网访问，所以得改成0.0.0.0，才能各个浏览器都能访问</p>
</li>
</ul>
<hr>
<p>之后访问你的服务器<code>公网ip:端口号</code>就可以访问了，当然也可以用nginx 代理到自己的域名上。</p>
<p>其他的操作和vscode没什么区别。</p>
<p>我自己配置了编写java用到的插件和配置。</p>
<p>下面是用到的插件</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210517200929.png" alt="image-20210517200928040" loading="lazy"></figure>
<hr>
<p>下面是配置文件,主要是<code>&quot;java.home&quot;:</code>  <code>&quot;java.requirements.JDK11Warning&quot;</code>    <code>&quot;java.semanticHighlighting.enabled&quot;</code>这几个。</p>
<pre><code class="language-java">{
    &quot;java.home&quot;: &quot;/usr/java/jdk1.8.0_121&quot;,
    &quot;java.requirements.JDK11Warning&quot;: false,
    &quot;java.semanticHighlighting.enabled&quot;: true,
    &quot;files.exclude&quot;: {
        &quot;**/.classpath&quot;: true,
        &quot;**/.project&quot;: true,
        &quot;**/.settings&quot;: true,
        &quot;**/.factorypath&quot;: true
    },
    &quot;java.completion.importOrder&quot;: [
        &quot;java&quot;,
        &quot;javax&quot;,
        &quot;com&quot;,
        &quot;org&quot;
    ],
    &quot;java.completion.favoriteStaticMembers&quot;: [
        &quot;org.junit.Assert.*&quot;,
        &quot;org.junit.Assume.*&quot;,
        &quot;org.junit.jupiter.api.Assertions.*&quot;,
        &quot;org.junit.jupiter.api.Assumptions.*&quot;,
        &quot;org.junit.jupiter.api.DynamicContainer.*&quot;,
        &quot;org.junit.jupiter.api.DynamicTest.*&quot;,
        &quot;org.mockito.Mockito.*&quot;,
        &quot;org.mockito.ArgumentMatchers.*&quot;,
        &quot;org.mockito.Answers.*&quot;
    ]
}
</code></pre>
<h2 id="在ipad上编程">在ipad上编程</h2>
<p>那么，怎么在ipad上运行呢。有两种方法：</p>
<ol>
<li>直接在浏览器访问你服务器code-server的网址。</li>
<li>在ipad App Store上搜索 Servediter</li>
</ol>
<p>我推荐第二种，Servediter是一款专门为 iPad 优化的用来连接 <code>code-server</code> 的 iOS 原生应用。我们使用 VSApp 可以直接连接我们自己的 <code>code-server</code> 实例，自动登录，打造畅快的在线 VS Code 体验。</p>
<p>Servediter原本是仅支持连接至它的开发者所部署的 <code>code-server</code> 上面的，因此也包含了 App 内购，最近才更新支持自部署服务器的连接。既然我们都已经自己部署了自己的 <code>code-server</code>，那么我们直接在菜单中选择「Self Hosted Server」，并依次填写：</p>
<ul>
<li>
<p>我们刚刚部署 <code>code-server</code> 的：</p>
</li>
<li>
<ul>
<li><code>code-server URL</code> 刚刚在 Safari 中打开的 URL：<code>{服务器 IP 地址}:{code-server 端口}</code></li>
<li><code>Instance password</code> 刚刚开启 <code>code-server</code> 时设置的密码</li>
</ul>
</li>
<li>
<p>以及，我们服务器自己的：</p>
</li>
<li>
<ul>
<li><code>Host</code>：服务器 IP 地址</li>
<li><code>Username</code>：默认登录用户名</li>
<li><code>Port</code>：登录 SSH 端口（默认 22 端口）</li>
<li><code>Authentication</code>：登录服务器时使用的密码或公钥私钥对</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210516204422.png" alt="image-20210516204421041" loading="lazy"></figure>
<p>这样，就可以愉快的在ipad上写代码了。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210516204906.jpg" alt="QQ图片20210516204848" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树]]></title>
        <id>https://aruul.github.io/post/t70ZdhScS/</id>
        <link href="https://aruul.github.io/post/t70ZdhScS/">
        </link>
        <updated>2021-05-13T11:52:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近一直在刷算法题，感觉还是需要把基础打牢一点，就暂停了刷题，从基本的算法书开始看。</p>
<p>《小灰的算法之旅》一个很基础的书</p>
<h2 id="二叉树">二叉树</h2>
<blockquote>
<p>什么是二叉树？官方是这样定义的：<strong>在计算机科学中，二叉树是每个结点最多有两个子树的树结构</strong>。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。</p>
</blockquote>
<p>其实这些都是很基础的东西，之前数据结构也都学过了。所以一些东西就省去不表。。。</p>
<p>二叉树的数据结构</p>
<pre><code class="language-java">public class TreeNode {
    public int data;
    public TreeNode leftChild;
    public TreeNode rightChild;

    public TreeNode(int data){
        this.data = data;
    }
}
</code></pre>
<h2 id="前序遍历生成二叉树">前序遍历生成二叉树</h2>
<p>我采用的是递归的方式，这样最容易明白</p>
<pre><code class="language-java">    //创建二叉树
	//inputList  存放前序遍历的二叉树的list
    public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inputList){
        TreeNode treeNode = null;
        if(inputList==null||inputList.isEmpty()){
            return null;
        }
        Integer data = inputList.removeFirst();
        if(data!=null){
            treeNode = new TreeNode(data);
            treeNode.leftChild = createBinaryTree(inputList);
            treeNode.rightChild = createBinaryTree(inputList);
        }
        return treeNode;

    }
</code></pre>
<p>测试代码：</p>
<pre><code class="language-java"> public static void main(String[] args) {
        LinkedList&lt;Integer&gt; inputList = new LinkedList&lt;Integer&gt;();
        inputList.add(3); 
        inputList.add(2);
        inputList.add(9);
        inputList.add(null);
        inputList.add(null);
        inputList.add(10);
        inputList.add(null);
        inputList.add(null);
        inputList.add(8);
        inputList.add(null);
        inputList.add(4);
        TreeNode head = createBinaryTree(inputList);

    }
</code></pre>
<h2 id="前序遍历二叉树">前序遍历二叉树</h2>
<h3 id="递归的写法">递归的写法</h3>
<pre><code class="language-java">    //前序遍历--递归的方式
    public static void qian(TreeNode head){
        if(head==null){
            return;
        }
        System.out.println(head.data);
        qian(head.leftChild);
        qian(head.rightChild);
    }
</code></pre>
<h3 id="非递归的写法">非递归的写法</h3>
<pre><code class="language-java">	//前序遍历--非递归的方式
    public static void qian2(TreeNode head){
        // 用栈来存放
        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
 
        while(head!=null||!stack.isEmpty()){
            //迭代访问节点的左节点，并入栈
            while(head!=null){
                System.out.println(head.data);
                stack.push(head);
                head = head.leftChild;
            }

            //若节点没有左孩子，栈中弹出栈顶结点，访问节点右节点
            if(!stack.isEmpty()){
                head = stack.pop();
                head = head.rightChild;
            }
        }
    }
</code></pre>
<h2 id="层次遍历">层次遍历</h2>
<p>大致思路：</p>
<p><img src="https://aruul.github.io/post-images/1620906969722.jpg" alt="" loading="lazy"><br>
<img src="https://aruul.github.io/post-images/1620906979070.jpg" alt="" loading="lazy"></p>
<pre><code class="language-java">//广度优先遍历--层次遍历
    public static void level(TreeNode head){
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(head);
        while (!queue.isEmpty()){
            TreeNode treeNode =queue.poll();
            System.out.println(treeNode.data);
            if(treeNode.leftChild!=null){
                queue.offer(treeNode.leftChild);
            }
            if(treeNode.rightChild!=null){
                queue.offer(treeNode.rightChild);
            }

        }

    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工厂模式]]></title>
        <id>https://aruul.github.io/post/PdwpIn0xO/</id>
        <link href="https://aruul.github.io/post/PdwpIn0xO/">
        </link>
        <updated>2021-05-10T13:24:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="工厂模式">工厂模式</h2>
<h3 id="1前言">1.前言</h3>
<p>设计模式大二的时候就学了，但是现在有些也忘得差不多了，现在决定重新学一遍。</p>
<p>立个flag，一周至少学三种设计模式。</p>
<blockquote>
<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<h3 id="2简单工厂模式">2.简单工厂模式</h3>
<p><strong>应用实例：</strong> 你需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</p>
<hr>
<pre><code class="language-java">/** 简单(静态)工厂模式
 * @author aRu
 * @date 2021/5/8 15:31
 */
public class CarFactory {
    public static Car getCar(String name){
        if(name.equals(&quot;大众&quot;)){
            return new DaZhong();
        }else if (name.equals(&quot;五菱&quot;)){
            return new WuLing();
        }
        return null;
    }
}
</code></pre>
<pre><code class="language-java">/**抽象汽车类
 * @author aRu
 * @date 2021/5/8 15:28
 */
public interface Car {
    void Name();
}
</code></pre>
<pre><code class="language-java">/** 大众
 * @author aRu
 * @date 2021/5/8 15:29
 */
public class DaZhong implements Car{
    @Override
    public void Name() {
        System.out.println(&quot;大众&quot;);
    }
}

----------------------------------------------------------------------------------------
    
/**五菱
 * @author aRu
 * @date 2021/5/8 15:30
 */
public class WuLing implements Car{
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}

</code></pre>
<p>测试</p>
<pre><code class="language-java">/** 测试类
 * @author aRu
 * @date 2021/5/8 15:34
 */

//测试 简单(静态)工厂模式
public class Test {
    public static void main(String[] args) {
        Car car1 = CarFactory.getCar(&quot;大众&quot;);
        Car car2 = CarFactory.getCar(&quot;五菱&quot;);

        car1.Name();
        car2.Name();
    }
}
</code></pre>
<hr>
<p><strong>缺点</strong>：试想当老板提出新需求要加一辆本田汽车的时候，你会发现，你此时不得不去修改<strong>CarFactory</strong>这个类，这就违反了开闭原则.</p>
<h3 id="3方法工厂模式">3.方法工厂模式</h3>
<p>针对上面简单工厂的缺点，我们引出方法工厂模式。</p>
<p>在方法工厂模式中，我们将<strong>工厂抽象起来</strong>，使得每个品牌的汽车都有自己的工厂，而不是像简单工厂模式里，一个大工厂建造不同品牌的车。</p>
<p>当我们需要新添加汽车时，只需要添加新的汽车类和对应的工厂就好。</p>
<hr>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508161257.png" alt="image-20210508161255712" loading="lazy"></figure>
<pre><code class="language-java">//抽象汽车工厂
public interface CarFactory {
    Car getCar();
}
</code></pre>
<pre><code class="language-java">//具体的汽车工厂  
public class WuLingFactory implements CarFactory{
    //五菱工厂
    @Override
    public Car getCar() {
        return new WuLing();
    }
}

----------------------------------------------
 public class DaZhongFactory implements CarFactory{
     //大众工厂
    @Override
    public Car getCar() {
        return new DaZhong();
    }
}
</code></pre>
<pre><code class="language-java">//抽象汽车类
public interface Car {
    void Name();
}
</code></pre>
<pre><code class="language-java">//具体汽车类
public class WuLing implements Car {
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}
----------------------------------------
public class WuLing implements Car {
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//方法工厂模式测试public class Test {    public static void main(String[] args) {        Car car = new WuLingFactory().getCar();        Car car2 = new DaZhongFactory().getCar();        car.Name();        car2.Name();    }}
</code></pre>
<h4 id="4抽象工厂模式">4.抽象工厂模式</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC25. K个一组翻转链表.]]></title>
        <id>https://aruul.github.io/post/ofb0ZIr8t/</id>
        <link href="https://aruul.github.io/post/ofb0ZIr8t/">
        </link>
        <updated>2021-05-09T13:15:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509195221.png" alt="image-20210509195220283" loading="lazy"></figure>
<pre><code class="language-java">输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
</code></pre>
</blockquote>
<h3 id="补充">补充</h3>
<p>ListNode定义如下</p>
<pre><code class="language-java">public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
</code></pre>
<h3 id="解法">解法</h3>
<pre><code class="language-java">    public static ListNode reverseKGroup(ListNode head, int k) {

        if(head == null) return head;
        ListNode a = head;
        ListNode b = head;
        for (int i = 0; i &lt; k; i++) {
            if(b == null) return head;
            b = b.next;
        }
        ListNode newNode = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newNode;
    }

    // 反转[a,b)个节点
    public static ListNode reverse(ListNode a, ListNode b) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=b){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<h3 id="思路">思路</h3>
<p>首先，由一道和他类似的题<a href="https://leetcode-cn.com/problems/reverse-linked-list/">【<strong>LC206. 反转链表</strong>】</a>引出我的解法。</p>
<p>在我之前的博客中这道题采用了递归解法。</p>
<p>其实，还有还可以用while循环来解。</p>
<pre><code class="language-java">    public static ListNode reverse(ListNode a) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<p>上面的代码完成了 给定一个链表头a，将这个链表反转。</p>
<p>具体步骤如下：</p>
<p>这是链表的初始状态：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509200639.png" alt="image-20210509200638636" loading="lazy"></figure>
<hr>
<hr>
<p>然后开始执行该函数, 将【前置节点pre】指为null，将【当前节点cur】指向a</p>
<pre><code class="language-java"> ListNode pre,cur,next;
 pre = null;
 cur = a;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509201429.png" alt="image-20210509201427829" loading="lazy"></figure>
<hr>
<hr>
<p>当【当前节点cur】不为空的时候，将【next节点】指向【当前节点cur的下一个】</p>
<pre><code class="language-java">while(cur!=null){
            next = cur.next;
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509201824.png" alt="image-20210509201823579" loading="lazy"></figure>
<hr>
<hr>
<p>之后将【当前节点cur】指向【前置节点pre】</p>
<pre><code class="language-java">cur.next = pre;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204604.png" alt="image-20210509204603462" loading="lazy"></figure>
<hr>
<hr>
<p>然后【pre、cur】开始向后移动一个节点，即：</p>
<ul>
<li>将【前置节点pre】移动到【当前节点cur】的位置</li>
<li>将【当前节点cur】移动到【后置节点next】的位置</li>
</ul>
<p><mark>注意：这时候没有移动next是因为不确定移动后【cur】是否为null。</mark></p>
<p><mark>当【cur】为null的时候再移动【后置节点next】会抛出空指针异常。这也是为什么循环的条件是【cur】不为null</mark></p>
<pre><code class="language-java">pre = cur;
cur = next;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204700.png" alt="image-20210509204659403" loading="lazy"></figure>
<hr>
<p>之后在while的循环条件中判断【cur】是否为空， 不为空则进入循环</p>
<p>进入循环中，重复之前的操作。将【next节点】指向【当前节点cur的下一个】</p>
<pre><code class="language-java">next = cur.next;
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204748.png" alt="image-20210509204747387" loading="lazy"></figure>
<hr>
<hr>
<p>之后将【当前节点cur】指向【前置节点pre】</p>
<pre><code class="language-java">cur.next = pre;
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204827.png" alt="image-20210509204825846" loading="lazy"></figure>
<hr>
<p>然后【pre、cur】开始向后移动一个节点，即：</p>
<ul>
<li>将【前置节点pre】移动到【当前节点cur】的位置</li>
<li>将【当前节点cur】移动到【后置节点next】的位置</li>
</ul>
<pre><code class="language-java">pre = cur;
cur = next;
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204904.png" alt="image-20210509204902250" loading="lazy"></figure>
<hr>
<p>以此类推，直到【当前节点cur】为null，停止循环，返回【前置节点pre】</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205131.png" alt="image-20210509205128892" loading="lazy"></figure>
<hr>
<p>那反转链表的一部分呢，比如反转【a，b）之间的节点 （左闭右开）</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205450.png" alt="image-20210509205449221" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205552.png" alt="image-20210509205551013" loading="lazy"></figure>
<p>你会发现，它其实和我们反转整个链表差不多，反转整个链表的时候，</p>
<p>是相当于反转【a，null）之间的节点，</p>
<p>和反转【a，b）之间的节点有异曲同工之妙啊~</p>
<p>所以说，反转【a，b）之间的节点的代码就应该在他的基础改一改，把</p>
<pre><code class="language-java">while(cur!=null)
</code></pre>
<p>改为</p>
<pre><code class="language-java">while(cur!=b)
</code></pre>
<p>代码如下：</p>
<pre><code class="language-java">    // 反转[a,b)个节点
    public static ListNode reverse(ListNode a, ListNode b) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=b){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<hr>
<p>这和 K个一组翻转链表反转 有啥子关系呢？</p>
<p>每K个一组就是相当于区间【a，b）之间的节点有K个，然后一一反转。</p>
<p>这就用到了递归</p>
<pre><code class="language-java">    public static ListNode reverseKGroup(ListNode head, int k) {

        if(head == null) return head;
        // 区间 [a, b) 包含 k 个待反转元素
        ListNode a = head;
        ListNode b = head;
        for (int i = 0; i &lt; k; i++) {
             // 不足 k 个，不需要反转
            if(b == null) return head;
            b = b.next;
        }
        // 反转前 k 个元素,并获得反转后的头节点
        ListNode newNode = reverse(a, b);
        // 递归反转后续链表并连接起来，这里a反转后由子节点中由头变为尾，所以和a.next拼接
        a.next = reverseKGroup(b, k);
        return newNode;
    }
</code></pre>
]]></content>
    </entry>
</feed>