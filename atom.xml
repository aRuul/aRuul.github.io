<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aruul.github.io</id>
    <title>aRuul的无名小站</title>
    <updated>2021-07-28T11:55:06.065Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aruul.github.io"/>
    <link rel="self" href="https://aruul.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aruul.github.io/images/avatar.png</logo>
    <icon>https://aruul.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, aRuul的无名小站</rights>
    <entry>
        <title type="html"><![CDATA[java中父类子类中各个代码块的执行顺序]]></title>
        <id>https://aruul.github.io/post/GJEKowxCw/</id>
        <link href="https://aruul.github.io/post/GJEKowxCw/">
        </link>
        <updated>2021-07-28T11:54:14.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">/**
 * @author aRu
 * @date 2021/7/27 9:26
 */
class DemoFather{
    public DemoFather(){
        System.out.println(&quot;father构造函数&quot;);
    }

    static{
        System.out.println(&quot;father静态代码块&quot;);
    }

    {
        System.out.println(&quot;father构造代码块&quot;);
    }

    public void fatherMethord(){
        System.out.println(&quot;father方法&quot;);
    }

}

public class Demo4 extends DemoFather{
    public Demo4(){
        System.out.println(&quot;son构造函数&quot;);
    }

    static{
        System.out.println(&quot;son静态代码块&quot;);
    }

    {
        System.out.println(&quot;son构造代码块&quot;);
    }

    public void fatherMethord(){
        System.out.println(&quot;son重写方法&quot;);

    }

    public void sonOnlyMethord(){
        System.out.println(&quot;son独有方法&quot;);
    }

    public static void main(String[] args) {
        Demo4 demo4 = new Demo4();
        demo4.fatherMethord();

    }
}

</code></pre>
<p>执行结果</p>
<pre><code class="language-java">father静态代码块
son静态代码块
father构造代码块
father构造函数
son构造代码块
son构造函数
son重写方法

Process finished with exit code 0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM-05 String Table]]></title>
        <id>https://aruul.github.io/post/3_MAdpKrX/</id>
        <link href="https://aruul.github.io/post/3_MAdpKrX/">
        </link>
        <updated>2021-07-26T12:21:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="string-table">String Table</h1>
<h2 id="基本特性">基本特性</h2>
<ul>
<li>
<p>String 字符串，使用一对&quot;&quot;</p>
</li>
<li>
<p>String声明是final的，不可被继承</p>
</li>
<li>
<p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</p>
</li>
<li>
<p>string在jdk8及以前内部定义了final <strong>char[] value</strong>用于存储字符串数据。JDK9时改为<strong>byte[] value</strong></p>
</li>
<li>
<p>String 代表不可变的字串序列</p>
<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li>
</ul>
<pre><code class="language-java">class Demo{
    public static void test1() {
        // 字面量定义的方式，“abc”存储在字符串常量池中
        String s1 = &quot;abc&quot;;
        String s2 = &quot;abc&quot;;
        System.out.println(s1 == s2);  //true
        s1 = &quot;hello&quot;;
        System.out.println(s1 == s2);  //false
        System.out.println(s1);		//hello
        System.out.println(s2);		//abc
        System.out.println(&quot;----------------&quot;);
    }

    public static void test2() {
        String s1 = &quot;abc&quot;;
        String s2 = &quot;abc&quot;;
        // 只要进行了修改，就会重新创建一个对象，这就是不可变性
        s2 += &quot;def&quot;;
        System.out.println(s1);  //abc
        System.out.println(s2);  //abcdef
        System.out.println(&quot;----------------&quot;);
    }

    public static void test3() {
        String s1 = &quot;abc&quot;;
        String s2 = s1.replace('a', 'm');
        System.out.println(s1);  //abc
        System.out.println(s2);  //mbc
    }
}
</code></pre>
</li>
<li>
<p>字符串常量池中是不会存储相同内容的字符串的。</p>
<blockquote>
<p>String的string Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。</p>
<p>使用-XX:StringTablesize可设置stringTable的长度</p>
<p>在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设置没有要求</p>
<p>在jdk7中，stringTable的长度默认值是60013，</p>
<p>在JDK8中，StringTable可以设置的最小值为1009</p>
</blockquote>
</li>
</ul>
<h2 id="string的内存分配">String的内存分配</h2>
<p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种<strong>常量池</strong>的概念。</p>
<p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，string类型的常量池比较特殊。它的主要使用方法有两种。</p>
<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：string info=&quot;aRuul&quot;；</li>
<li>如果不是用双引号声明的string对象，可以使用String提供的intern()方法。</li>
</ul>
<blockquote>
<p>Java 6及以前，字符串常量池存放在永久代</p>
<p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即<strong>将字符串常量池的位置调整到Java堆内</strong></p>
<p>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</p>
<p>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</p>
<p>Java8元空间，字符串常量在堆</p>
<p>详情请看 上面<strong>方法区-------方法区的演进</strong>这一小节</p>
</blockquote>
<h3 id="为什么stringtable从永久代调整到堆中">为什么StringTable从永久代调整到堆中</h3>
<ul>
<li>永久代的默认比较小</li>
<li>永久代垃圾回收频率低</li>
</ul>
<h2 id="字符串拼接">字符串拼接</h2>
<ol>
<li>常量与常量的拼接结果在常量池，原理是编译器优化</li>
<li>常量池中不会存在相同内容的常量</li>
<li>只要其中有一个是变量，结果就在堆中(指的是堆中非字符串常量池的区域)。</li>
<li>变量拼接的原理是StringBuilder</li>
<li>如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象的地址。</li>
</ol>
<pre><code class="language-java">public static void test1() {
    String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;  // 得到 abc的常量池
    String s2 = &quot;abc&quot;; // abc存放在常量池，直接将常量池的地址返回
    /**
     * 最终java编译成.class，再执行.class
     */
    System.out.println(s1 == s2); // true，因为存放在字符串常量池
    System.out.println(s1.equals(s2)); // true
}

public static void test2() {
    String s1 = &quot;javaEE&quot;;
    String s2 = &quot;hadoop&quot;;
    String s3 = &quot;javaEEhadoop&quot;;
    String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;    
    String s5 = s1 + &quot;hadoop&quot;;
    String s6 = &quot;javaEE&quot; + s2;
    String s7 = s1 + s2;
	//只要其中有一个是变量，结果就在堆中(指的是堆中非字符串常量池的区域),就是在堆中new一个。
    System.out.println(s3 == s4); // true
    System.out.println(s3 == s5); // false
    System.out.println(s3 == s6); // false
    System.out.println(s3 == s7); // false
    System.out.println(s5 == s6); // false
    System.out.println(s5 == s7); // false
    System.out.println(s6 == s7); // false
	//如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象的地址。
    String s8 = s6.intern();
    System.out.println(s3 == s8); // true
}

public static void test4(){
    final String s1 = &quot;a&quot;;  //注意！这里的话就算常量
    final String s2 = &quot;b&quot;;  //注意！这里的话就算常量
    String s3 = &quot;ab&quot;;
    String s4 = s1 + s2;
    System.out,println(s3==s4); //true
}
</code></pre>
<h3 id="字符串拼接底层细节">字符串拼接底层细节</h3>
<pre><code class="language-java">public void test3(){
	String s1 = &quot;a&quot;;
    String s2 = &quot;b&quot;;
    String s3 = &quot;ab&quot;;
    String s4 = s1 + s2;
    System.out,println(s3==s4); //false
}
</code></pre>
<p>当执行<code>String s4 = s1 + s2;</code>时，</p>
<p><strong>底层实际上是新建了一个StringBuilder,然后将两个值进行拼接，细节如下：</strong></p>
<ol>
<li><strong>StringBuilder temp = new StringBuilder();</strong>   【补充：在jdk5.0之前用的是StringBuffer】</li>
<li><strong>temp.append(&quot;a&quot;);</strong></li>
<li><strong>temp.append(&quot;b&quot;);</strong></li>
<li><strong>temp.toString();     //toString()方法约等于 new String(&quot;ab&quot;)</strong></li>
</ol>
<blockquote>
<p>String字符串拼接效率</p>
<ul>
<li>
<p>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</p>
<p>StringBuilder好处如下</p>
</li>
<li>
<p>StringBuilder的append的方式，自始至终只创建一个StringBuilder的对象</p>
</li>
<li>
<p>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</p>
</li>
<li>
<p>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，如果进行GC那么将会耗费更多的时间</p>
</li>
</ul>
</blockquote>
<h2 id="intern的使用">intern()的使用</h2>
<p><strong>如果不是用双引号声明的string对象，可以使用string提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</strong></p>
<p>比如：</p>
<pre><code class="language-java">String myInfo = new string(&quot;abc&quot;).intern();
</code></pre>
<p>也就是说，如果在任意字符串上调用string.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p>
<pre><code class="language-java">（&quot;a&quot;+&quot;b&quot;+&quot;c&quot;）.intern（）==&quot;abc&quot;
</code></pre>
<p>通俗点讲，Interned string就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
<h3 id="new-stringab会创建几个对象">new String(&quot;ab&quot;)会创建几个对象</h3>
<p>两个</p>
<ul>
<li>一个是new String()，会在堆空间创建</li>
<li>一个是&quot;ab&quot;，存放在字符串常量池中的对象</li>
</ul>
<h3 id="new-stringa-new-stringb-会创建几个对象">new String(&quot;a&quot;) + new String(&quot;b&quot;) 会创建几个对象</h3>
<pre><code class="language-java">public class StringNewTest {
    public static void main(String[] args) {
        String str = new String(&quot;a&quot;) + new String(&quot;b&quot;);
    }
}
---------------------字节码文件如下----------------------------------
 0 new #2 &lt;java/lang/StringBuilder&gt;
 3 dup
 4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;
 7 new #4 &lt;java/lang/String&gt;
10 dup
11 ldc #5 &lt;a&gt;
13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;
16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;
19 new #4 &lt;java/lang/String&gt;
22 dup
23 ldc #8 &lt;b&gt;
25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;
28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;
31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;
34 astore_1
35 return
</code></pre>
<p>​	六个</p>
<ul>
<li>
<p>对象1：new StringBuilder()</p>
</li>
<li>
<p>对象2：new String(&quot;a&quot;)</p>
</li>
<li>
<p>对象3：常量池的 a</p>
</li>
<li>
<p>对象4：new String(&quot;b&quot;)</p>
</li>
<li>
<p>对象5：常量池的 b</p>
</li>
<li>
<p>对象6：StringBuilder调用toString()方法，</p>
<p>toString中会创建一个 new String(&quot;ab&quot;)</p>
<p>【注意】<strong>调用toString方法，不会在常量池中生成&quot;ab&quot;</strong></p>
<pre><code class="language-java">	//StringBuilder中的toString()方法
	@Override
    public String toString() {
        return new String(value, 0, count);     //这个方法并不会在常量池中生成字符串
    }
</code></pre>
</li>
</ul>
<h3 id="面试题难">面试题【难】</h3>
<pre><code class="language-java">package top.aruul;

/**
 * @author aRu
 * @date 2021/7/17 17:56
 */
public class Demo {
    public static void main(String[] args) {
        String s= new String(&quot;1&quot;);
        s.intern();        //这里并没有赋值给其他字符串
        String ss = s.intern();
        String s2 = &quot;1&quot;;
        System.out.println(s==s2);  //false
        System.out.println(ss==s);  //false
        System.out.println(ss==s2); //true

        /* s3记录的变量地址为 new String(&quot;11&quot;)
         *执行完下面这行代码后，常量池中并没有 &quot;11&quot; */
        String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);

        //【注意】这里的话常量池中并没有 &quot;11&quot;,
        // 所以执行下面的intern方法的时候，会在字符串常量池中生成&quot;11&quot;
        //对于jdk6来说，会直接创建一个 &quot;11&quot; 在字符串常量池中
        //对于jdk7/jdk8 来说，把字符串常量池移到了堆中，而上一行代码在堆中创建了一个对象：【new String(&quot;11&quot;)】
        //为了节省空间，此时，字符串常量池中会创建一个指向【堆中 new String(&quot;11&quot;)】的地址
        s3.intern();

        //所以这里创建的 s4指向了字符串常量池中的 {一个指向【堆中 new String(&quot;11&quot;)】的地址}
        String s4 = &quot;11&quot;;

        //所以这里对于jdk6：false
        //对于jdk7/jdk8: true
        System.out.println(s3==s4);
    }
}
</code></pre>
<h3 id="面试题的拓展">面试题的拓展</h3>
<pre><code class="language-java">/* s3记录的变量地址为 new String(&quot;11&quot;)
         *执行完下面这行代码后，常量池中并没有 &quot;11&quot; */
String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);
String s4 = &quot;11&quot;;  //在字符串常量池中生成对象 &quot;11&quot;
s3.intern();     //这个操作没啥用，因为字符串常量池中已经有 &quot;11&quot;了，而且并没把结果返回给任何对象
System.out.println(s3==s4);  //jdk8: false
</code></pre>
<hr>
<pre><code class="language-java">String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);  //相当于在堆中new String(&quot;ab&quot;)
String s2 = s.intern(); //在字符串常量池中生成一个指向堆中new String(&quot;ab&quot;)的地址，并返回给s2
//以下结果均在jdk8中
//&quot;ab&quot;在字符串常量池中是一个指向new String(&quot;ab&quot;)的地址，所以和s、s2是同一个东西
System.out.println(s==&quot;ab&quot;);    //true
System.out.println(s2==&quot;ab&quot;);	//true
</code></pre>
<hr>
<pre><code class="language-java">String x = &quot;ab&quot;;
String s = new String(&quot;a&quot;) + new String(&quot;b&quot;);
String s2 = s.intern();
//以下结果均在jdk8中
System.out.println(s2==x);  //true
System.out.println(s==x);   //false
</code></pre>
<h3 id="小总结">小总结</h3>
<p>总结String的intern()的使用：</p>
<p>JDK1.6中，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，会把此<strong>对象复制一份</strong>，放入串池，并返回串池中的对象地址</li>
</ul>
<p>JDK1.7起，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，则会把<strong>对象的引用地址</strong>复制一份，放入串池，并返回串池中的引用地址</li>
</ul>
<h2 id="g1中的string去重操作">G1中的String去重操作</h2>
<p><strong>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</strong></p>
<blockquote>
<p>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是string对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说： stringl.equals（string2）= true。堆上存在重复的string对象必然是一种内存的浪费。</p>
</blockquote>
<p><strong>G1中的String去重操作:</strong></p>
<ul>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。<strong>对每一个访问的对象都会检查是否是候选的要去重的String对象</strong>。</li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。</li>
<li>使用一个hashtable来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM-04 对象常见知识点]]></title>
        <id>https://aruul.github.io/post/V5_N42aiw/</id>
        <link href="https://aruul.github.io/post/V5_N42aiw/">
        </link>
        <updated>2021-07-25T11:08:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="对象常见知识点">对象常见知识点</h1>
<p><strong>首先，要明白对象是在堆中的。</strong></p>
<h2 id="对象创建方式">对象创建方式</h2>
<ul>
<li>new :最常见的方式</li>
<li>Class的newInstance方法</li>
<li>Constructor的newInstance(XXX)，反射的方式，可以调用空参/带参的构造器</li>
<li>使用clone():不调用任何构造器，要求当前的类要实现Cloneable接口中的clone()</li>
<li>使用反序列化：从网络、文件中获取对象的二进制流</li>
<li>第三方库Objenesis</li>
</ul>
<h2 id="创建对象的步骤">创建对象的步骤</h2>
<h3 id="1判断对象对应的类是否加载-链接-初始化">1.判断对象对应的类是否加载、链接、初始化</h3>
<ul>
<li>虚拟机遇到一条new指令，首先检查这个指令的参数是否在Metaspace(元空间)的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。
<ul>
<li>如果没有，那么在双亲委派模式下，使用当前类加载器一ClassLoader+包名+类名为key进行查找对应的.class文件。
<ul>
<li>如果没有找到文件，则抛出ClassNotFoundException异常，</li>
<li>如果找到，则进行类的加载，并生成对应的Class类对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>符号引用</strong><br>
符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义地定位目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p>
</blockquote>
<h3 id="2为对象分配内存">2.为对象分配内存</h3>
<p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。</p>
<p>在分配的内存空间的时候：</p>
<ul>
<li>如果内存规整，使用的是<strong>指针碰撞法</strong>来分配内存</li>
<li>如果内存不规整，已使用的内存和未使用的内存相互交错，那么虚拟机使用<strong>空闲列表</strong>来分配。<strong>意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</strong></li>
</ul>
<p>【补充】</p>
<p><strong>指针碰撞法</strong>：意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。</p>
<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210724154035.png" alt="image-20210724154034553" style="zoom:80%;" />
<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210724154221.png" alt="image-20210724154220080" style="zoom:80%;" />
<h3 id="3处理并发安全问题">3.处理并发安全问题</h3>
<ul>
<li>采用CAS配上失败重试保证更新的原子性</li>
<li>每个线程预先分配TLAB -----通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）
<ul>
<li>在Eden区给每个线程分配一块区域</li>
</ul>
</li>
</ul>
<h3 id="4初始化分配到的空间">4.初始化分配到的空间</h3>
<p>给所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p>
<ul>
<li>属性的默认</li>
</ul>
<h3 id="5设置对象的对象头">5.设置对象的对象头</h3>
<p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
<h3 id="6执行init方法进行初始化">6.执行init方法进行初始化</h3>
<p>在java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造器方法，并把堆内对象的首地址赋值给引用变量。</p>
<p>主要执行下面几个操作：</p>
<ul>
<li>显示初始化</li>
<li>代码块中的初始化</li>
<li>构造器初始化</li>
</ul>
<h2 id="对象的内存布局">对象的内存布局</h2>
<p>对象的布局包括：</p>
<ul>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充</li>
</ul>
<h4 id="对象头">对象头</h4>
<p>对象头包含两个部分，分别是<strong>运行时元数据</strong>和<strong>类型指针</strong>（如果是数组还要记录数组的长度）</p>
<p><strong>运行时元数据</strong>包括 <strong>哈希值、GC分代年龄、锁状态标志、线程持有的锁、偏向线程id、偏向时间戳</strong></p>
<p><strong>类型指针</strong>指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息</p>
<h4 id="实例数据">实例数据</h4>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210724163159.png" alt="image-20210724163157790" loading="lazy"></figure>
<h4 id="对齐填充">对齐填充</h4>
<p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p>
<h4 id="小结">小结</h4>
<pre><code class="language-java">public class Customer{
    int id = 1001;
    String name;
    Account account;
    
    {
        name = &quot;aRuul&quot;
    }
    
    public Customer(){
        account = new Account();
	}
    
}
----------------------------------------------

public Account{
    
}

----------------------------------------------
public MyTest{
    public static void main(String[] args){
        Customer customer = new Customer();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210724164203.png" alt="image-20210724164202328" loading="lazy"></figure>
<p>​																										【纠错】方法区里的Klass改成Class</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM-03 运行时数据区]]></title>
        <id>https://aruul.github.io/post/VwpHLfwt4/</id>
        <link href="https://aruul.github.io/post/VwpHLfwt4/">
        </link>
        <updated>2021-07-24T07:13:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="运行时数据区">运行时数据区</h1>
<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210718163557.png" alt="image-20210718163554539" style="zoom:80%;" />
<p>红色的为<strong>线程共享区域</strong>，<strong>一个虚拟机实例对应一份</strong></p>
<p>​	<strong>蓝色的是一个线程对应一份</strong></p>
<h2 id="程序计数器pc计数器">程序计数器(PC计数器)</h2>
<blockquote>
<p><strong>实际上，JVM中的程序计数器(PC计数器)是对物理pc寄存器的一种抽象模拟</strong>，并非是广义上的物理寄存器。</p>
<p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p>
<p>如果执行的是native方法，那这个指针就不工作了。</p>
</blockquote>
<p><strong>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令</strong></p>
<p><strong>每个线程都有自己的程序计数器</strong>，生命周期与线程一致。</p>
<p><strong>作用</strong>： PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p>下面是一个java代码的字节码文件main方法的一部分：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210719150124.png" alt="image-20210719150122811" loading="lazy"></figure>
<h3 id="使用pc寄存器存储字节码指令地址有什么用呢">使用PC寄存器存储字节码指令地址有什么用呢？</h3>
<p>(为什么使用PC寄存器记录当前线程的执行地址呢？)</p>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。<br>
JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<h3 id="pc寄存器为什么会被设定为线程私有">PC寄存器为什么会被设定为线程私有？</h3>
<p>cpu在执行多线程的时候，实际上会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<h3 id="并行-并发">并行 并发</h3>
<ul>
<li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li>
<li><strong>并行：</strong> 单位时间内，多个任务同时执行（可以与串行相理解）</li>
</ul>
<h2 id="虚拟机栈">虚拟机栈</h2>
<p><strong>栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</strong></p>
<blockquote>
<p>Java虚拟机栈( Java virtua1 Machine Stack),早期也叫Java栈。<br>
每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧( Stack Frame),对应着一次次的Java方法调用。</p>
<p><strong>是线程私有的</strong></p>
</blockquote>
<ul>
<li>
<p><strong>作用</strong>：主管java程序的运行，它保存方法的局部变量(8中基本数据类型/对象的引用)、部分结果，并参与方法的调用和返回。</p>
</li>
<li>
<p>**优点：**1. 栈是一种快速有效的分配存储方式，访问速度仪次于程序计数器。</p>
<p>​			2.JVM直接对Java栈的操作只有两个：每个方法执行，伴随着进（入栈、压栈）、执行结束后的出栈工作</p>
<p>​			3.对于栈来说不存在垃圾回收问题</p>
</li>
</ul>
<h4 id="异常">异常</h4>
<p>如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。</p>
<p>Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>(OOM)。</p>
<h4 id="设置栈内存大小">设置栈内存大小</h4>
<p>我们可以使用参数-Xss选项来设置线程的最大栈空间，栈大小直接决定了函数调用的最大可达深度。</p>
<h4 id="栈的存储单元-栈帧">栈的存储单元-栈帧</h4>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以**栈帧( Stack Frame)**格式存在。</li>
<li>在这个线程上正在执行的<strong>每个方法</strong>都各自<strong>对应一个栈帧( Stack Frame)</strong></li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。
<ul>
<li>即只有当前正在执行的方法的栈帧（<strong>栈顶栈帧</strong>）是有效的，这个栈帧被称为<strong>当前栈帧( Current Frame)</strong>,</li>
<li>与<strong>当前栈帧相对应的方法就是当前方法</strong>（ CurrentMethod),</li>
<li>定义这个方法的类就是<strong>当前类</strong>( Current Class).</li>
</ul>
</li>
<li><strong>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</strong><br>
如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li>
</ul>
<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210719160147.png" alt="QQ图片20210719160131" style="zoom:80%;" />
<ul>
<li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用 return指令；另外一种是抛出异常。<strong>不管使用哪种方式，都会导致栈帧被弹出。</strong></li>
<li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
</ul>
<h4 id="栈帧的内部结构todo">栈帧的内部结构【ToDo】</h4>
<p>(这里我并没有仔细看，所以只粗略了写了一小点内容)</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210719161847.png" alt="image-20210719161844500" loading="lazy"></figure>
<ul>
<li>
<p>局部变量表( Local Variables)</p>
<p>​     <strong>定义为数字数组</strong></p>
<p>​	<strong>局部变量表，最基本的存储单元是Slot（变量槽）</strong></p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210719162353.png" alt="image-20210719162352247" loading="lazy"></figure>
</li>
<li>
<p>操作数栈( operand stack)（或表达式）</p>
<blockquote>
<p>操作数栈，在方法执行过程中，根据字节码指令，在栈中写入数据或者提取数据，即入栈、出栈</p>
</blockquote>
</li>
<li>
<p>动态链接( Dynamic Linking)（或指向运行时常量池的方法引用）</p>
<blockquote>
<p>每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现<strong>动态链接</strong></p>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为<strong>符号引用</strong>( Symbolic Reference)保存在class文件的常量池里。<br>
比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p>
</blockquote>
</li>
<li>
<p>方法返回地址( Return Address)（或方法正常退出或者异常退出的定义）</p>
<blockquote>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。</p>
<p>方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</p>
<p>而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
</blockquote>
</li>
<li>
<p>一些附加信息</p>
<blockquote>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>
</blockquote>
</li>
</ul>
<h4 id="静态变量和局部变量">静态变量和局部变量</h4>
<p><strong>局部变量在使用前一定要显式赋值，否则编译不通过</strong></p>
<blockquote>
<p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，</p>
<p>另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。<br>
和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
</blockquote>
<p><strong>补充：</strong></p>
<ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</li>
</ul>
<h4 id="java中方法重写的本质">java中方法重写的本质？</h4>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210720135308.png" alt="image-20210720135306618" loading="lazy"></figure>
<h4 id="举例栈溢出的情况">举例栈溢出的情况？</h4>
<p>如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。</p>
<h4 id="调整栈大小就能保证不出现溢出吗">调整栈大小，就能保证不出现溢出吗？</h4>
<p>使用参数-Xss选项来设置线程的最大栈空间，但不一定保证不出现溢出，如果碰到递归，可能会出现溢出。</p>
<h4 id="分配的栈内存越大越好吗">分配的栈内存越大越好吗？</h4>
<p>并不是，栈是私有的，如果设置的每一个栈的空间太大了，就会导致最后可分配的线程数量变少，甚至出OOM</p>
<h4 id="垃圾回收是否会涉及到虚拟机栈">垃圾回收是否会涉及到虚拟机栈？</h4>
<p>不会，他直接操作的就是出栈、入栈，不存在GC(垃圾回收)，存在Error</p>
<h4 id="方法中定义的局部变量是否线程安全todo">方法中定义的局部变量是否线程安全？【ToDo】</h4>
<p>视情况而定</p>
<h2 id="本地方法接口的理解">本地方法接口的理解</h2>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210720135756.png" alt=" " loading="lazy"></figure>
<blockquote>
<p><strong>本地方法(Native Method)</strong>：一个 Native Method就是一个Java调用非Java代码的接口。</p>
<p>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C，这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中你可以用 extern&quot;C&quot;告知C++编译器去调用一个C的函数。</p>
</blockquote>
<h2 id="本地方法栈">本地方法栈</h2>
<p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</p>
<blockquote>
<p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。</p>
<p>如果JVM产品不打算支持 native方法，也可以无需实现本地方法栈。<br>
在 Hotspot JVM中，直接将本地方法栈和虚拟机合二为一。</p>
</blockquote>
<h2 id="堆heap">堆(heap)</h2>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210720144023.png" alt="image-20210720144022441" loading="lazy"></figure>
<p><strong>堆是线程共享区域</strong></p>
<h3 id="核心概念">核心概念</h3>
<ul>
<li>
<p><strong>一个JVM实例只存在一个堆内存</strong>，堆也是Java内存管理的核心区域。</p>
<p><em><strong>即，每个Java应用程序都使用一个独立的 JVM。</strong></em></p>
</li>
<li>
<p><strong>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了</strong>，是JVM管理的最大一块内存空间。<br>
堆内存的大小是可以调节的。</p>
</li>
<li>
<p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续的内存空间</strong>中，但在<strong>逻辑上它应该被视为连续</strong>的。</p>
</li>
<li>
<p>所有的<strong>线程共享java堆</strong>，在这里还可以划分线程<strong>私有的缓冲区</strong>（ Thread Local Allocation Buffer, TLAB)</p>
</li>
<li>
<p><strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。( The heap is the run- time data area from<br>
which memory for all class instances and arrays is allocated<br>
<em>周老师说的是：“几乎”所有的对象实例都在这里分配内存。---------从实际使用角度看的。</em></p>
</li>
<li>
<p><strong>数组和对象可能永远不会存储在栈上</strong>，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
</li>
<li>
<p><strong>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</strong></p>
</li>
<li>
<p>堆，是GC( Garbage Collection,垃圾收集器)执行垃圾回收的重点区域</p>
</li>
</ul>
<hr>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210720145812.png" alt="image-20210720145811206" loading="lazy"></figure>
<p>​														栈 、堆、方法区之间的关系</p>
<hr>
<h3 id="堆的细分内存结构">堆的细分内存结构</h3>
<p>在JDK7以及之前的版本，堆通常被分为下面三个部分：</p>
<ol>
<li><strong>新生区(Yong Generation)</strong></li>
<li><strong>养生区(Old Generation)</strong></li>
<li>永久区/永久代(Permanent Generation)</li>
</ol>
<p>Java8及之后堆内存逻辑上分为三部分：</p>
<ol>
<li>
<p><strong>新生区</strong></p>
<p><strong>年轻代</strong>又可以划分为<strong>Eden空间、 Survivor0空间和 Survivor1空间</strong>（有时也叫做from区、to区）。</p>
</li>
<li>
<p><strong>养老区</strong></p>
</li>
<li>
<p>元空间</p>
</li>
</ol>
<blockquote>
<p>由于翻译不同 叫法也不尽相同，下面是常见的叫法：</p>
<p>新生区=新生代= 年轻代<br>
养老区 =老年区 =老年代<br>
永久区 =永久代</p>
</blockquote>
<h3 id="设置堆空间大小">设置堆空间大小</h3>
<p>Java堆区用于存储Java对象实例，堆的大小在JVM启动时就已经设定好了，</p>
<p>可以通过选项&quot;-Xmx&quot;和&quot;Xms&quot;来进行设置。</p>
<blockquote>
<p>“-Xms&quot;用于表示堆区的起始内存，等价于ーXX: Initialheapsize<br>
“-Xmx&quot;则用于表示堆区的最大内存，等价于-XX: Maxheaps1ze</p>
</blockquote>
<h3 id="年轻代与老年代">年轻代与老年代</h3>
<p>存储在JVM中的Java对象可以被划分为<strong>两类</strong>：</p>
<ul>
<li><strong>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</strong></li>
<li><strong>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</strong></li>
</ul>
<p>Java<strong>堆区</strong>进一步细分的话，可以划分为<strong>年轻代</strong>和<strong>老年代</strong><br>
其中<strong>年轻代</strong>又可以划分为<strong>Eden空间、 Survivor0空间和 Survivor1空间</strong>（有时也叫做from区、to区）。</p>
<p><mark>几乎所有的java对象都是在Eden区被new出来的。</mark></p>
<p><mark>绝大部分的java对象的销毁都在新生代进行</mark></p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210720154018.png" alt="image-20210720154016863" loading="lazy"></figure>
<h4 id="调参与占比">调参与占比</h4>
<p>新生代：老年代=1：2</p>
<p>新生代：Eden:s0:s1=8:1:1</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210720154339.png" alt="image-20210720154338541" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210720154607.png" alt="image-20210720154605960" loading="lazy"></figure>
<h3 id="对象分配的一般过程">对象分配的一般过程</h3>
<blockquote>
<p>1.new的对象先放伊甸园区。此区有大小限制。</p>
<p><strong>【注意】大对象直接进入老年代，大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</strong></p>
<p>2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收( Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p>
<p><strong>【注意】只有伊甸园区的空间满的时候才会触发垃圾回收( Minor GC又叫YGC【Young GC】),幸存区满了并不会触发</strong></p>
<p>3.然后将伊甸园中的剩余对象移动到幸存者0区。</p>
<p>4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p>
<p>5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p>
<p>6,啥时候能去养老区呢？可以设置次数。默认是15次。<br>
可以设置参数：-XX: Maxtenuringthreshold=<N>进行设置</p>
</blockquote>
<p><strong>针对幸存者s0,s1区的总结</strong>：复制之后有交换，谁空谁是to</p>
<p><strong>关于垃圾回收</strong>：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</p>
<h3 id="对象分配的特殊情况">对象分配的特殊情况</h3>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210721151059.png" alt="image-20210721151057588" loading="lazy"></figure>
<p>​																			配合P73来理解</p>
<h3 id="minor-gc-major-gc-full-gc">Minor GC、Major GC、Full GC</h3>
<p>JVM在进行GC时，并非每次都对上面三个内存(新生代、老年代；方法区)区域一起回收的，<strong>大部分时候回收的都是指新生代。</strong></p>
<p>针对 Hotspot JVM的实现，它里面的GC按照回收区域又分为两大种类型：</p>
<p>一种是<strong>部分收集(Partial GC)</strong><br>
一种是<strong>整堆收集(Full GC)</strong></p>
<ul>
<li>部分收集：不是完整收集整个java堆的垃圾收集。其中又分为：
<ul>
<li>新生代收集( Minor GC/ Young GC):  只是新生代的垃圾收集</li>
<li>老年代收集( Major GC/Old GC):  只是老年代的垃圾收集。<br>
<em>目前，只有 CMS GC会有单独收集老年代的行为。</em><br>
<em><strong>注意，很多时候 Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</strong></em></li>
<li>混合收集( Mixed GC):收集整个新生代以及部分老年代的垃圾收集。<br>
<em>目前，只有G1 GC会有这种行为</em></li>
</ul>
</li>
<li>整堆收集(Full GC): 收集整个java堆和方法区的垃圾收集。</li>
</ul>
<h4 id="年轻代gc-minor-gc触发机制">年轻代GC( Minor GC)触发机制</h4>
<ul>
<li>当年轻代空间不足时，就会触发 Minor GC,这里的年轻代满指的是Eden代满， Survivor满不会引发GC。(每次 Minor GC会清理年轻代的内存）</li>
<li>因为java对象大多都具备<strong>朝生夕灭</strong>的特性，所以 <strong>Minor GC非常频繁</strong>，一般<strong>回收速度也比较快</strong>。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW,暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
</ul>
<h4 id="老年代gcmajor-gc触发机制">老年代GC(Major GC)触发机制</h4>
<ul>
<li>指发生在老年代的GC,对象从老年代消失时，我们说“ Major GC”或“Full GC”发生了</li>
<li>出现了 Major GC，经常会伴随至少一次的 Minor GC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行 Major GC的策略选择过程）。也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还不足，则触发 Major Gc</li>
<li>Major GC的速度一般会比 Minor GC慢10倍以上，STW的时间更长。</li>
<li>如果 Major GC后，内存还不足，就报OOM了</li>
</ul>
<h4 id="full-gc触发机制">Full GC触发机制</h4>
<p>触发Full GC执行的情况有如下五种：<br>
(1)调用 System. gc()时，系统建议执行Full GC,但是不必然执行<br>
(2)老年代空间不足<br>
(3)方法区空间不足<br>
(4)通过 Minor GC后进入老年代的平均大小大于老年代的可用内存<br>
(5)由Eden区、 survivor spacee( From Space)区向 survivor space1(To Space)区复制时，对象大小大于 To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小<br>
<em>说明：full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。</em></p>
<p><strong>一般来说 出现OOM，则极大可能进行了Full GC</strong></p>
<h3 id="为什么要把java堆分代不分代就不能正常工作了吗">为什么要把Java堆分代？不分代就不能正常工作了吗？</h3>
<ul>
<li>
<p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：有Eden、两块大小相同的Survivor(又称作 s0/s1或from/to )构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC依旧存活的对象</li>
</ul>
</li>
<li>
<p>其实不分代完全可以，分代的唯一理由就是优化GC性能。</p>
<ul>
<li>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。</li>
<li>而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="针对不同年龄段的对象分配原则">针对不同年龄段的对象分配原则</h3>
<ul>
<li>
<p>优先分配到Eden</p>
</li>
<li>
<p>大对象直接分配到老年代：<br>
<em>尽量避免程序中出现过多的大对象</em></p>
</li>
<li>
<p>长期存活的对象分配到老年代</p>
</li>
<li>
<p>动态对象年龄判断：<br>
<em>如果Survivor区中相同年龄的所有对象大小的总和 大于 Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</em></p>
<blockquote>
<p><strong>【比如】</strong>：Survivor区中有6个相同年龄的对象，都是10岁，而且这6个对象占用的空间大于 Survivor空间的一半，则其他大于10岁的对象可以直接进入老年代。</p>
</blockquote>
</li>
<li>
<p>空间分配担保：<br>
<em>-XX:HandlePromotionFailure ，也就是经过Minor GC后，所有的对象都存活，因为Survivor比较小，所以就需要将Survivor无法容纳的对象，存放到老年代中。</em></p>
</li>
</ul>
<h3 id="tlabtodo">TLAB【ToDo】</h3>
<p><strong>TLAB(Thread Local Allocation Buffer)中文意思是线程本地分配缓冲区</strong></p>
<h4 id="堆空间都是共享的么">堆空间都是共享的么？</h4>
<p>不一定，因为还有TLAB这个概念，<strong>在堆中划分出一块区域，为每个线程所独占</strong></p>
<h4 id="为什么要有tlab">为什么要有TLAB？</h4>
<ul>
<li>TLAB：Thread Local Allocation Buffer，也就是为每个线程单独分配了一个缓冲区</li>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<h4 id="小结">小结</h4>
<ul>
<li>
<p>年轻代是对象的诞生、成长和消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
</li>
<li>
<p>老年代放置长生命周期的对象。通常都是从Survivor区域筛选拷贝过来的java对象。</p>
<p>普通的对象会被分配在TLAB上，当对象较大的，JVM会试图直接分配在Eden其他位置上</p>
<p>当对象太大，无法在新生代找到足够长的连续空闲空间，JVM就会把对象直接分配到老年代。</p>
</li>
<li>
<p>当GC只发生在年轻代，回收年轻代对象的行为称为Minor GC。</p>
<p>当GC发生在老年代，则被成为Major GC或者Full GC。</p>
<p>一般来说，Minor GC的发生频率比Major GC要高，即年轻代中垃圾回收频率大大高于年轻代。</p>
</li>
</ul>
<hr>
<h2 id="方法区">方法区</h2>
<h3 id="栈-堆-方法区的交互关系">栈 堆 方法区的交互关系</h3>
<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210722145839.png" alt="image-20210722145836188" style="zoom:50%;" />
<blockquote>
<p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p>
<p>类加载器将 .class 文件搬过来就是先丢到这一块上</p>
<p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，</p>
<p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p>
</blockquote>
<p>上面的图中，new PerSon()相当于创建了一个对象实例，则放在<strong>堆</strong>中</p>
<p>Person存放了这个类的信息，存放在方法区中</p>
<p>person是存放在Java栈的局部变量表中</p>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210722151407.png" alt="image-20210722151405350" loading="lazy"></figure>
<h3 id="方法区的基本理解">方法区的基本理解</h3>
<blockquote>
<p>《java虚拟机规范》中明确说明：“尽管所有的<strong>方法区在逻辑上是属于堆的一部分</strong>，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpot JVM而言，方法区还有一个别名叫Non-Heap(非堆)，目的就是要和堆分开。</p>
<p>所以，<strong>方法区看作是独立于java堆的内存空间。</strong></p>
</blockquote>
<ul>
<li>方法区和堆一样，是各个线程共享的内存区域</li>
<li>方法区在jvm启动的时候被创建，而且他的实际物理内存空间中和java堆区一样都可以是不连续的</li>
<li>方法区的大小跟堆空间大小都可以选择固定大小或者可拓展</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，悉尼及同样会抛出内存溢出错误，</li>
<li>关闭JVM就会释放这个区域的内存</li>
</ul>
<h3 id="方法区的演进">方法区的演进</h3>
<p><strong>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代</strong></p>
<p>本质上，方法区和永久代并不等价</p>
<p>当年使用永久代，不是好的idea，因为实在JVM的内存中运行，导致Java程序更容易OOM</p>
<p><strong>而jdk1.8及以后，元空间不在虚拟机设置的内存中，而是使用本地内存</strong></p>
<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210722160956.png" alt="image-20210722160955144" style="zoom:80%;" />
<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210722161025.png" alt="image-20210722161024342" style="zoom:80%;" />
<h3 id="方法区的内部结构">方法区的内部结构</h3>
<p>方法区主要存放的信息如下：</p>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210722162317.png" alt="image-20210722162315731" loading="lazy"></figure>
<p>《深入理解java虚拟机》中对方法区存储的内容描述如下：</p>
<blockquote>
<p>它用于存储已被虚拟机加载的<strong>类型信息</strong>、<strong>常量、静态变量</strong>、<strong>即时编译器编译之后的代码缓存</strong>等。</p>
</blockquote>
<p><strong>类型信息</strong>：</p>
<p>包含了下面几个信息：</p>
<ul>
<li>这个类的完整有效名称(全名=包名+类名)</li>
<li>这个类型直接父类的完整有效名(对于interface或者Object,都没有父类)</li>
<li>这个类型的修饰符(public,abstract,final)</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<p><strong>域信息</strong>(成员变量)：</p>
<ul>
<li>JVM必须在方法区中保存类型的所有域相关的信息以及域的声明顺序。</li>
<li>域的相关信息包括：域名称、域类型、域修饰符(public、static、final、volatile等)</li>
</ul>
<p><strong>non-final的类变量</strong></p>
<ul>
<li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上一部分</li>
<li><strong>类变量被所有的实例共享，即使没有类实例时也可以访问</strong></li>
</ul>
<p><strong>【注意】被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了</strong></p>
<p><strong>方法信息：</strong></p>
<ul>
<li>方法名称</li>
<li>方法的返回类型(或void)</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（ public, private, protected, static,final,synchronized, native, abstract的一个子集）</li>
<li>方法的字节码( bytecodes)、操作数栈、局部变量表及大小（ abstract和native方法除外）</li>
<li>异常表( abstract和 native方法除外)</li>
</ul>
<h3 id="常量池">常量池</h3>
<p>在字节码文件内部，包含了<strong>常量池</strong>。</p>
<p>当通过类的加载器加载运行之后，就叫做<strong>运行时常量池</strong>。</p>
<ul>
<li>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外</li>
<li>还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括<strong>各种字面量和对类型、域和方法的符号引用</strong></li>
</ul>
<h4 id="为什么需要常量池">为什么需要常量池？</h4>
<p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，所以我们将所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构。</p>
<h4 id="常量池里有什么">常量池里有什么？</h4>
<ul>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ul>
<blockquote>
<p><strong>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类</strong><br>
<strong>名、方法名、参数类型、字面量等类型。</strong></p>
</blockquote>
<h3 id="方法区的演进-2">方法区的演进</h3>
<table>
<thead>
<tr>
<th style="text-align:center">JDK版本</th>
<th style="text-align:center">演变细节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">JDK1.6及以前</td>
<td style="text-align:center">有永久代，静态变量存储在永久代上</td>
</tr>
<tr>
<td style="text-align:center">JDK1.7</td>
<td style="text-align:center">有永久代，但已经逐步“去永久代”，<strong>字符串常量池、静态变量从永久代中移除，保存在堆中</strong></td>
</tr>
<tr>
<td style="text-align:center">JDK1.8</td>
<td style="text-align:center">无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td>
</tr>
</tbody>
</table>
<ul>
<li>JDK1.6</li>
</ul>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210723162259.png" alt="image-20210723162257646" loading="lazy"></figure>
<ul>
<li>JDK1.7</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210723162443.png" alt="image-20210723162441857" loading="lazy"></figure>
<ul>
<li>JDK1.8</li>
</ul>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210723162529.png" alt="image-20210723162528585" loading="lazy"></figure>
<h4 id="为什么永久代要被元空间替代">为什么永久代要被元空间替代？</h4>
<blockquote>
<p>JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p>
<p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有：</p>
<ul>
<li>为永久代设置空间大小是很难确定的。</li>
</ul>
<p>在某些场景下，如果动态加载类过多，容易产生Perm区的oom。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<p>“Exception in thread‘dubbo client x.x connector'java.lang.OutOfMemoryError:PermGen space”</p>
<p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<ul>
<li>对永久代进行调优是很困难的。
<ul>
<li>主要是为了降低Full GC</li>
</ul>
</li>
</ul>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不在使用的类型</p>
</blockquote>
<h4 id="string-table为什么要调整">String Table为什么要调整？</h4>
<p>JDK7中将StringTable放在堆空间中。</p>
<p>因为永久代的回收效率很低，在Full GC时才会被执行永久代(方法区)的垃圾回收，而Full GC是老年代空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。</p>
<p>放到堆里，能及时回收内存。</p>
<h4 id="静态变量存放在哪里">静态变量存放在哪里？</h4>
<p>静态引用对应的对象实体始终都存在堆空间。</p>
<h3 id="方法区的垃圾回收">方法区的垃圾回收</h3>
<p>实际上java虚拟机规范中并没有规定方法区一定要垃圾回收</p>
<p>方法区的垃圾收集主要回收两个部分：<strong>常量池中废弃的常量</strong>和<strong>不再使用的类型</strong></p>
<p>常量池之中主要存放的两大类常量：字面量和符号引用。</p>
<p>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p><strong>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</strong></p>
<blockquote>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的java.lang.C1ass对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。I Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及oSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</li>
</ul>
</blockquote>
<h2 id="小结-2">小结</h2>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210724145710.png" alt="image-20210724145709334" loading="lazy"></figure>
<h2 id="大厂面试题">大厂面试题</h2>
<p>百度 三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p>
<p>蚂蚁金服： Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？ 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？ 二面：Eden和survior的比例分配</p>
<p>小米： jvm内存分区，为什么要有新生代和老年代</p>
<p>字节跳动： 二面：Java的内存分区 二面：讲讲vm运行时数据库区 什么时候对象会进入老年代？</p>
<p>京东： JVM的内存结构，Eden和Survivor比例。 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p>
<p>天猫： 一面：Jvm内存模型以及分区，需要详细到每个区放什么。 一面：JVM的内存模型，Java8做了什么改</p>
<p>拼多多： JVM内存分哪几个区，每个区的作用是什么？</p>
<p>美团： java内存分配 jvm的永久代中会发生垃圾回收吗？ 一面：jvm内存分区，为什么要有新生代和老年代？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM-02 类加载子系统]]></title>
        <id>https://aruul.github.io/post/HnC917QY2/</id>
        <link href="https://aruul.github.io/post/HnC917QY2/">
        </link>
        <updated>2021-07-18T09:32:19.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210717153813.png" alt="image-20210717153811503" loading="lazy"><br>
<strong>加载--&gt; 链接--&gt; 初始化</strong></p>
<p><strong>如果自己手写一个java虚拟机的话，主要考虑哪些结构？  类加载器和执行引擎</strong></p>
<h2 id="类的加载过程">类的加载过程</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210717154605.png" alt="image-20210717154600485" loading="lazy"></figure>
<ul>
<li>类加载子系统负责从文件系统或者网络系统中加载Class文件，class文件在文件开头有特定的文件标识</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则是由Execution Engine来jued</li>
<li>加载的<strong>类信息存放在一块成为方法区</strong>的内存空间。</li>
<li>除了类的信息之外，<strong>方法区还会存放运行时的常量池信息</strong>，可能还包括<strong>字符串常量和数字常量</strong>（这部分常量信息是Class文件中常量池部分的内存映射）</li>
</ul>
<hr>
<p>具体的类加载过程图</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210717160036.png" alt="image-20210717160035120" loading="lazy"></figure>
<h3 id="第一步-加载-生成-javalangclass对象">第一步 加载 --生成 java.lang.Class对象</h3>
<ol>
<li>通过一个类的全限定名获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态数据结构转化为方法区的运行时数据结构</li>
<li>在内存中<strong>生成</strong>一个代码这个类的  <strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h3 id="第二步-链接">第二步 链接</h3>
<h4 id="1验证-verify">1.<strong>验证( Verify):</strong></h4>
<ul>
<li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证</li>
</ul>
<blockquote>
<p>java .class文件开头是COFFBABE</p>
</blockquote>
<h4 id="2准备-prepare">2.<strong>准备( Prepare):</strong></h4>
<ul>
<li>
<p>为<strong>类变量</strong>分配内存并且设置该类变量的<strong>默认初始值</strong>，即零值。</p>
<pre><code class="language-java">class Demo{
    //这时a会被赋值为0，在初始化时才会被初始化为1
    private static int a = 1;
}
</code></pre>
</li>
<li>
<p>这里<strong>不包含用final修饰的 static</strong>,因为<strong>final在编译的时候就会分配了</strong>，准备阶段会显式初始化</p>
</li>
<li>
<p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而<strong>实例变量</strong>是会随着对象一起分<br>
配到<strong>java堆</strong>中。</p>
</li>
</ul>
<h4 id="3解析-resolve">3.<strong>解析( Resolve)</strong></h4>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程</li>
<li>事实上，解析操作住住会伴随着JVM在执行完初始化之后再执行。</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的<br>
CONSTANT Class info CONSTANT Fieldref info, CONSTANT Methodref info</li>
</ul>
<h3 id="第三步-初始化">第三步 初始化</h3>
<ul>
<li>
<p>初始化阶段就是执行<strong>类的构造器方法 <clinit>()</strong> 的过程（cl可以理解为 class  ，init为 inital）</p>
</li>
<li>
<p>此方法不需要定义，是javac编译器自动收集类中的所有变量的赋值动作和静态代码块中的语句合并而来的。</p>
</li>
<li>
<p>构造器方法按语句顺序执行所有<strong>类变量</strong>（static修饰的成员变量）显式初始化和<strong>静态代码块中语句</strong></p>
<pre><code class="language-java">/*这里的话，a最终的值为1
* 首先在第二步链接的准备阶段，会将a初始化为0
* 在第三步初始化时，类的构造器方法按照顺序执行，先将a赋值为10，再将a赋值为1，所以最后a=1
*/
class Demo{
    static{
        a = 10;
    }
    private static int a = 1;
}
</code></pre>
</li>
<li>
<p><strong>类的构造器方法 <clinit>()</strong> 不同于类的构造函数，<mark>当一个类中不存在类变量的时候，则.class文件中没有<clinit>()</mark></p>
</li>
<li>
<p>若该类有父类，JVM会保证父类的 <clinit>()执行完毕之后再执行子类的<clinit>()</p>
<pre><code class="language-java">class Father{
    public static int a = 1;
    static{
        a = 2;
    }
}

class Son extends Father{
    public static int b = a;
    
    public static void main(String []args){
        //最终的结果为2
        Sysytem.out.println(Son.b);
    }
}
</code></pre>
</li>
<li>
<p>虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁，即<mark>一个类只会被加载一次</mark>、</p>
</li>
</ul>
<h2 id="类的加载器">类的加载器</h2>
<h3 id="类加载器分类">类加载器分类</h3>
<p>JVM支持<strong>两种</strong>类型的<strong>类加载器</strong>，分别为</p>
<ol>
<li><strong>引导加载器</strong>(Bootstrap ClassLoader)</li>
<li>**自定义加载器(**User-Defined ClassLoader)，<strong>是指继承自ClassLoader的加载器</strong></li>
</ol>
<hr>
<h3 id="虚拟机自带的加载器">虚拟机自带的加载器</h3>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210718143804.png" alt="image-20210718143802701" loading="lazy"></figure>
<h4 id="启动类加载器引导类加载器-bootstrap-classloader">启动类加载器(引导类加载器 Bootstrap ClassLoader)</h4>
<ul>
<li>
<p>我们不能直接获取到</p>
</li>
<li>
<p>java的<strong>核心类库</strong>都是使用<strong>引导类加载器</strong>来进行加载的。</p>
</li>
<li>
<p>这个类加载使用C++/C来实现的，嵌套在JVM内部</p>
</li>
<li>
<p>并不继承于java.lang.ClassLoader</p>
</li>
<li>
<p><strong>加载扩展类和程序类加载器，并指定为它们的父加载器</strong></p>
</li>
<li>
<p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
</ul>
<h4 id="拓展类加载器extension-classloader">拓展类加载器(Extension ClassLoader)</h4>
<ul>
<li>java语言编写</li>
<li>派生于ClassLoader类</li>
<li>父加载器为启动类加载器</li>
<li>从java。ext.dirs系统属性所指定的目录中加载类库，或者从JDK安装目录的jre/lib/ext子目录下加载类库。<strong>如果用户创建的jar在此目录下，也会自动由扩展类加载器加载</strong></li>
</ul>
<h4 id="应用程序类加载器系统类加载器appclassloader">应用程序类加载器(系统类加载器AppClassLoader)</h4>
<ul>
<li>java语言编写</li>
<li>派生于ClassLoader类</li>
<li><strong>父加载器为拓展类加载器</strong></li>
<li>负责加载<strong>环境变量classpath</strong>或<strong>系统属性java.class.path</strong>指定路径下的类库</li>
<li><strong>我们自己写的类中默认加载器就是应用程序类加载器</strong></li>
</ul>
<h3 id="用户自定义加载类">用户自定义加载类</h3>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210718151628.png" alt="image-20210718151625921" loading="lazy"></figure>
<h2 id="classloader">ClassLoader</h2>
<p><strong>ClassLoader类是一个抽象类，其后所有的类加载器都继承自ClassLoader(不包括启动加载类)</strong></p>
<p>这里暂且了解就够了（嗯，大概</p>
<h2 id="双亲委派机制">双亲委派机制</h2>
<blockquote>
<p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是需要的时候才会将它的class文件加载到内存，生成class对象。</p>
<p>而在加载某个类的class文件时，JVM采用<strong>双亲委派模式</strong>，即把请求交给父类处理，是一种任务委派模式。</p>
</blockquote>
<p><strong>双亲委派机制</strong>：</p>
<ol>
<li>
<p>当一个类加载器收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，</p>
</li>
<li>
<p>如果父类还有父类加载器，则进一步向上委托，以此类推，直到顶层的启动类加载器</p>
</li>
<li>
<p>如果父类加载器可以完成加载任务，则成功返回；否则，子类加载器尝试去加载</p>
</li>
</ol>
<p><mark>可以理解为 类加载器这个家族很重亲情，能爸爸做的就爸爸做，爸爸实在做不了就儿子做</mark></p>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210718154732.png" alt="image-20210718154731162" loading="lazy"></figure>
<p>优势：</p>
<ul>
<li>
<p>避免类的重复加载</p>
</li>
<li>
<p>保护程序的安全，防止核心api被随意的篡改</p>
<p>比如你自定义一个包 java.lang,包下面有一个类Demo</p>
<pre><code class="language-java">package java.lang
class Demo{
    public static void main(String[] args){
        System.out.println(&quot;test&quot;);
    }
}
</code></pre>
<p>当你运行的时候，由于双亲委派机制，这和Demo类是java开头的，所以最终的加载器是引导类加载器。(引导类加载器只加载包名为java、javax、sun等开头的类)，而java核心类包中并没有Demo这个类，所以就会报错。</p>
</li>
</ul>
<h2 id="其他小的点">其他小的点</h2>
<h3 id="在jvm中表示两个class对象相同的两个必要条件">在JVM中表示两个class对象相同的两个必要条件：</h3>
<ol>
<li>类的完整类名要一致，包括包名</li>
<li>加载 这个类的ClassLoader(指ClassLoader实例对象)必须相同。</li>
</ol>
<h3 id="对类加载器的引用">对类加载器的引用</h3>
<ol>
<li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。</li>
<li>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。</li>
<li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM-01 概述]]></title>
        <id>https://aruul.github.io/post/0D3cevlgX/</id>
        <link href="https://aruul.github.io/post/0D3cevlgX/">
        </link>
        <updated>2021-07-16T08:47:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java虚拟机jvm">java虚拟机JVM</h2>
<p>java虚拟机是一台执行java字节码的虚拟计算机，它拥有独立的运行机制，其运行的java字节码也未必由java语言编译而成。</p>
<p>JVM平台的各种语言可以共享java虚拟机带来的跨平台性、优秀的垃圾回收机制以及可靠的即时编译器。java技术的核心就是java虚拟机（jvm，java virtual machine）</p>
<h2 id="jvm的位置">JVM的位置</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200358.png" alt="image-20210716200357558" loading="lazy"></figure>
<p>jvm是运行在操作系统之上的，没有和硬件直接交互</p>
<h2 id="jvm的整体结构">JVM的整体结构</h2>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200827.png" alt="image-20210716200826280" loading="lazy"></figure>
<p>​															<mark>要求会自己画出这张图</mark></p>
<ul>
<li>HotSport VM是目前市面上最高性能的虚拟机的代表作之一。</li>
<li>它采用解释器与即时编译器并存的架构</li>
</ul>
<h2 id="java代码执行流程">java代码执行流程</h2>
<p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p>
<p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong></p>
<p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进JVM里面来。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210716200206.png" alt="image-20210716200204379" loading="lazy"></figure>
<p>==由于跨平台的设计，java的指令都是根据栈来设计的。==跨平台性，指令集小，指令多。</p>
<p>相对于基于寄存器的架构，基于栈的架构的执行性能相比寄存器来说要差一些</p>
<h2 id="jvm的生命周期">JVM的生命周期</h2>
<p><strong>java虚拟机的启动</strong>是通过引导类类(bootstrap class loader)创建一个初始化类(initial class)来完成，这个类是有虚拟机的具体实现指定的。</p>
<p><strong>虚拟机的执行:</strong> 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序<br>
程序开始执行时他才运行，程序结束时他就停止<br>
执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</p>
<p><strong>虚拟机的退出</strong><br>
有如下的几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而异致Java虚拟机进程终止</li>
<li>某线程调用 Runtime类或 system类的exit方法，或 Runtime类的halt<br>
方法，并且Java安全管理器也允许这次exit或halt操作</li>
<li>除此之外，JNI( Java Native Interface)规范描述了用JNI Invocation APｴ来加载或卸载Java虚拟机时，Java虚拟机的退出情况</li>
</ul>
<h2 id="hotspot虚拟机">HotSpot虚拟机</h2>
<p>不管是JDK6还是最常用的JDK8，默认虚拟机都是HotSpot</p>
<blockquote>
<p>名称中的 Hotspot指的就是它的热点代码探测技术。<br>
通过计数器找到最具编译价值代码，触发即时编译或上替拧<br>
通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</p>
</blockquote>
<hr>
<p>Graal VM  ---&quot;Run Programs Faster Anywhere&quot;  最有可能替代HotSpot。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java多线程]]></title>
        <id>https://aruul.github.io/post/h25epdEh9/</id>
        <link href="https://aruul.github.io/post/h25epdEh9/">
        </link>
        <updated>2021-07-15T08:25:56.000Z</updated>
        <content type="html"><![CDATA[<p><strong>最近准备秋招，就开始之前java内容的复习，把复习过程中一些基本知识记录了下来，预祝自己秋招顺利吧。</strong></p>
<h2 id="基础篇">基础篇</h2>
<h3 id="1进程和线程">1.进程和线程</h3>
<blockquote>
<p>进程就是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。</p>
<p><strong>一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p>
</blockquote>
<p>进程和线程的提出极大的提高了操作系统的性能。<strong>进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。</strong></p>
<h4 id="11进程和线程的区别">1.1进程和线程的区别</h4>
<p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是<strong>是否单独占有内存地址空间及其它系统资源（比如I/O）</strong>：</p>
<ul>
<li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</li>
<li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li>
<li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li>
</ul>
<p>另外一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即CPU分配时间的单位 。</p>
<h4 id="12上下文切换">1.2上下文切换</h4>
<p>上下文切换有时也叫做线程切换或者任务切换，是指cpu从一个进程（或线程）切换到另一个进程或（者线程）。上下文是指某一个时间点cpu寄存器和程序计数器的内容。</p>
<p>举例说明 线程A ---&gt; B</p>
<p>1.先挂起线程A，将其在cpu中的状态保存在内存中。</p>
<p>2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。</p>
<p>3.当B执行完，根据程序计数器中指向的位置恢复线程A。</p>
<hr>
<h3 id="2java多线程入门类和接口">2.Java多线程入门类和接口</h3>
<p>JDK提供了<code>Thread</code>类和<code>Runnable</code>接口来让我们实现自己的“线程”类。</p>
<ul>
<li>继承<code>Thread</code>类，并重写<code>run</code>方法；</li>
<li>实现<code>Runnable</code>接口的<code>run</code>方法；</li>
</ul>
<h4 id="21-继承thread类">2..1 继承<code>Thread</code>类</h4>
<pre><code class="language-java">public class MyThread_01 extends Thread{
    @Override
    public void run() {
        System.out.println(&quot;MyThread_01 run&quot;);
    }

    public static void main(String[] args) {
        MyThread_01 myThread_01 = new MyThread_01();
        myThread_01.start();
    }
}
</code></pre>
<p>注意要调用<code>start()</code>方法后，该线程才算启动！</p>
<blockquote>
<p>我们在程序里面调用了start()方法后，虚拟机会先为我们创建一个线程，然后等到这个线程第一次得到时间片时再调用run()方法。</p>
<p>注意不可多次调用start()方法。在第一次调用start()方法后，再次调用start()方法会抛出illegalThreadStateException异常。</p>
</blockquote>
<h4 id="22实现runnable接口">2.2实现Runnable接口</h4>
<p>略</p>
<hr>
<h2 id="小细节">小细节</h2>
<p>当main线程启动一个线程的时候，main线程并不会阻塞，会和新开的线程交替执行</p>
<pre><code class="language-java">public class Demo1 extends Thread{
    @Override
    public void run() {
        for (int i=0; i&lt;5;i++){
            try {
                Thread.sleep(500);
                System.out.println(&quot;线程启动了...【&quot;+ Thread.currentThread().getName()+&quot;】&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Demo1 demo1 = new Demo1();
        demo1.start();

        for (int i = 0; i &lt; 5; i++) {
            System.out.println(&quot;main 线程启动&quot;);
            Thread.sleep(1000);
        }
    }

}
</code></pre>
<p>运行结果：</p>
<blockquote>
<p>main 线程启动<br>
线程启动了...【Thread-0】<br>
main 线程启动<br>
线程启动了...【Thread-0】<br>
线程启动了...【Thread-0】<br>
main 线程启动<br>
线程启动了...【Thread-0】<br>
线程启动了...【Thread-0】<br>
main 线程启动<br>
main 线程启动</p>
<p>Process finished with exit code 0</p>
</blockquote>
<p>实现Runnable接口的方式更加适合多个线程共享一个资源的情况</p>
<hr>
<h2 id="jdk18新特性lamda表达式">jdk1.8新特性Lamda表达式</h2>
<p>属于函数式编程</p>
<p>lambda 表达式的语法格式如下：</p>
<pre><code class="language-java">(parameters) -&gt; expression 
</code></pre>
<p>或</p>
<pre><code class="language-java"> (parameters) -&gt;{ statements; }
</code></pre>
<pre><code class="language-java">public class MyLamda {
    public static void main(String[] args) {
        Like like = ()-&gt;{
            System.out.println(&quot;i like java lamda&quot;);
        };
        like.say();
    }
}

interface Like{
    void say();
}
</code></pre>
<h2 id="线程的状态">线程的状态</h2>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210714161606.png" alt="image-20210714161604425" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210714190304.png" alt="image-20210714190303037" loading="lazy"></figure>
<hr>
<h2 id="线程的优先级">线程的优先级</h2>
<p>java中优先级可以指定，范围是1——10（从低到高），<strong>默认优先级为5</strong></p>
<p><strong>但是，并不一定是优先级越高越先执行</strong>，要取决于操作系统，java只是给操作系统一个优先级的参考值，线程最终在操作系统的优先级还是由操作系统决定的。</p>
<p>我们使用方法<code>Thread</code>类的<code>setPriority()</code>实例方法来设定线程的优先级。</p>
<h2 id="守护线程">守护线程</h2>
<p>在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)</p>
<p>如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<p><mark>当主线程结束之后，守护线程也就结束</mark></p>
<pre><code class="language-java">public class ShouHu {
    public static void main(String[] args) {

        Runnable runnable=()-&gt;{
            for( ; ; ){
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;我是守护线程&quot;);
            }
        };

        Thread thread = new Thread(runnable);
        thread.setDaemon(true);
        thread.start();

        for (int i = 0; i &lt; 5; i++) {
            System.out.println(&quot;main线程&quot;);
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<h2 id="线程同步">线程同步</h2>
<blockquote>
<p>在多线程编程，一些敏感数据不允许被多个线程同时访向，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访向，以保证数据的完整性</p>
</blockquote>
<h3 id="synchronized">synchronized</h3>
<p><strong>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</strong></p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<h2 id="死锁">死锁</h2>
<p><strong>产生死锁的四个必要条件：</strong><br>
1.互斥条件：一个资源每次只能被一个进程使用。<br>
2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放<br>
3.不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>
4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210715145533.png" alt="image-20210715145531281" loading="lazy"></figure>
<h2 id="释放锁">释放锁</h2>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210715145649.png" alt="image-20210715145648921" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210715150000.png" alt="image-20210715145957974" loading="lazy"></figure>
<h2 id="lock锁">Lock锁</h2>
<blockquote>
<p>1、从Java5开始，Java提供了一种功能更强大的线程同步机制——通过显式定义同步锁对象来实现同步，在这种机制下，同步锁由Lock对象充当。</p>
<p>2、Lock 提供了比synchronized方法和synchronized代码块更广泛的锁定操作，Lock允许实现更灵活的结构，可以具有差别很大的属性，并且支持多个相关的Condition对象。</p>
<p>3、Lock是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p>
<p>4、某些锁可能允许对共享资源并发访问，如ReadWriteLock（读写锁），Lock、ReadWriteLock是Java5提供的两个根接口，并为Lock 提供了ReentrantLock（可重入锁）实现类，为ReadWriteLock提供了ReentrantReadWriteLock 实现类。</p>
<p>5、Java8新增了新型的StampedLock类，在大多数场景中它可以替代传统的ReentrantReadWriteLock。ReentrantReadWriteLock 为读写操作提供了三种锁模式：Writing、ReadingOptimistic、Reading。</p>
</blockquote>
<pre><code class="language-java">public class MyLock {
    public static void main(String[] args) {
        TestLock testLock = new TestLock();
        new Thread(testLock).start();
        new Thread(testLock).start();
        new Thread(testLock).start();
    }
}

class TestLock implements Runnable{
    private int tickets = 100;
    //定义锁
    private final ReentrantLock reentrantLock = new ReentrantLock();

    @Override
    public void run() {
        while (true){
            //加锁
            reentrantLock.lock();
            if(tickets&lt;=0){
                break;
            }
            System.out.println(Thread.currentThread().getName()+&quot;, &quot;+(tickets--));
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                //解锁
                reentrantLock.unlock();
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代理模式]]></title>
        <id>https://aruul.github.io/post/YYF012ILo/</id>
        <link href="https://aruul.github.io/post/YYF012ILo/">
        </link>
        <updated>2021-07-04T07:51:46.000Z</updated>
        <content type="html"><![CDATA[<p>代理模式简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p>代理模式有静态代理和动态代理两种实现方式。</p>
<h2 id="静态代理">静态代理</h2>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>例如：小明想要打官司，则他需要找到代理律师来帮他</p>
<p>​			代理律师负责将小明想说的话说出去，并在小明说话前面引用法律条文，在小明说话后发动道德谴责。</p>
<p>代码：</p>
<pre><code class="language-java">//说话的行为接口
interface Say{
    void sayMessage(String m);
}
//小明
class XiaoMing implements Say{
    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;小明说出案情--by&quot;+m);
    }
}

//静态代理 王律师
class LawyerWang implements Say{
    private final Say say;

    public LawyerWang(Say say) {
        this.say = say;
    }

    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;引用法律条文&quot;);
        say.sayMessage(m);
        System.out.println(&quot;使用道德谴责&quot;);
    }
}
</code></pre>
<p>但是当又有一人来找王律师的时候，就需要重写代理的代码，非常不实用。</p>
<hr>
<h2 id="动态代理">动态代理</h2>
<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p>
<p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p>
<p><strong>动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<h3 id="jdk动态代理">JDK动态代理</h3>
<h3 id="介绍">介绍</h3>
<p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<ol>
<li><strong>InvocationHandler接口</strong></li>
</ol>
<blockquote>
<p>在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</p>
<pre><code>/**
 * 调用处理程序
 */
public interface InvocationHandler { 
    Object invoke(Object proxy, Method method, Object[] args); 
} 
复制代码
</code></pre>
<p>从InvocationHandler这个名称我们就可以知道，实现了这个接口的中介类用做“调用处理器”。</p>
<p>当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中。</p>
<p>代理类对象作为proxy参数传入，</p>
<p>参数method标识了我们具体调用的是代理类的哪个方法，</p>
<p>args为这个方法的参数。</p>
<p>这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用，这样我们可以在invoke方法中添加统一的处理逻辑(也可以根据method参数对不同的代理类方法做不同的处理)。因此我们只需在中介类的invoke方法实现中输出“before”，然后调用委托类的invoke方法，再输出“after”。<br>
作者：Chaexsy<br>
链接：https://juejin.cn/post/6844903591501627405<br>
来源：掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<ol start="2">
<li><strong><code>Proxy</code> 类</strong></li>
</ol>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<pre><code class="language-java">    public static Object newProxyInstance(ClassLoader loader,
                                          Class&lt;?&gt;[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        ......
    }Copy to clipboardErrorCopied
</code></pre>
<p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<hr>
<h3 id="接口和被代理委托方">接口和被代理(委托方)</h3>
<pre><code class="language-java">//说话的行为接口
interface Say{
    void sayMessage(String m);
}
//小明
class XiaoMing implements Say{
    @Override
    public void sayMessage(String m) {
        System.out.println(&quot;小明说出案情--by&quot;+m);
    }
}
</code></pre>
<h3 id="中介类">中介类</h3>
<p>对于<strong>XiaoMing</strong>这个类来说<strong>LawyerProxy</strong>类是他的代理，构成了静态代理</p>
<pre><code class="language-java">class LawyerProxy implements InvocationHandler{
    final private Object object;

    public LawyerProxy(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;引用法律条文&quot;);
        method.invoke(object,args);
        System.out.println(&quot;使用道德谴责&quot;);
        return null;
    }
}
</code></pre>
<h3 id="实际调用">实际调用</h3>
<p>而对于<strong>LawyerProxy</strong>类来说，<strong>Proxy 类</strong>是它的代理，构成了静态代理</p>
<pre><code class="language-java">	//动态代理
  System.out.println(&quot;===动态代理===&quot;);
  LawyerProxy lawyerProxy = new LawyerProxy(new XiaoMing());
  Say s = (Say)Proxy.newProxyInstance(Say.class.getClassLoader(), new Class[]{Say.class}, lawyerProxy);
  s.sayMessage(&quot;动态代理类&quot;);
</code></pre>
<p>也就是说，<strong>动态代理关系由两组静态代理关系组成，这就是动态代理的原理</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反射（3）]]></title>
        <id>https://aruul.github.io/post/9RSSdqr6G/</id>
        <link href="https://aruul.github.io/post/9RSSdqr6G/">
        </link>
        <updated>2021-07-01T07:33:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="反射-得到对象的六种方式">反射-得到对象的六种方式</h3>
<pre><code class="language-java">  
        /*  1.Clss.forName
            已经知道一个类的全类名，
            应用场景：多用于配置文件，读取类全路径，加载类
        */
        final String classAllPath = &quot;org.example.Car&quot;;
        Class&lt;?&gt; cls1 = Class.forName(classAllPath);
        System.out.println(&quot;cls1 &quot;+cls1);

        /*  2.类名.class
            已经知道一个具体的类，
            应用场景：多用于参数传递，如通过反射得到对应的构造器对象
        */
        Class cls2 = Car.class;
        System.out.println(&quot;cls2 &quot;+cls2);

        /*  3.getClass()
            已经知道一个类的实例，调用该实例的getClass()方法获取Class对象，
            应用场景：通过创建好的对象，获取Class对象
        */
        Car car = new Car();
        Class cls3 = car.getClass();
        System.out.println(&quot;cls3 &quot;+cls3);

        /*  4.ClassLoader
            通过类加载器
            应用场景：
        */
        //(1)得到car类的加载器 
        ClassLoader classLoader = car.getClass().getClassLoader();
        //(2)通过类加载器，得到Class对象
        Class&lt;?&gt; cls4 = classLoader.loadClass(&quot;org.example.Car&quot;);
        System.out.println(&quot;cls4 &quot;+cls4);


        //cls1 cls2 cls3 cls4其实是同一个对象
        System.out.println(cls1.hashCode());
        System.out.println(cls2.hashCode());
        System.out.println(cls3.hashCode());
        System.out.println(cls4.hashCode());

        //5.基本数据类型获取Class对象
        Class&lt;?&gt; integerClass = int.class;
        System.out.println(integerClass);

        //6.基本数据类型对应的包装类，通过Type获取Class对象
        Class&lt;?&gt; type = Integer.TYPE;
        System.out.println(type);
</code></pre>
<hr>
<h3 id="反射-获取类相关的信息">反射-获取类相关的信息</h3>
<pre><code class="language-java">		Class&lt;?&gt; personClass = Class.forName(&quot;org.example.Person&quot;); //父类
        Class&lt;?&gt; studentClass = Class.forName(&quot;org.example.Student&quot;); //子类

        //获取全类名
        System.out.println(&quot;获取全类名&quot;+personClass.getName());

        //获取简单类名
        System.out.println(&quot;获取简单类名&quot;+personClass.getSimpleName());

        //获取所有public修饰的属性， 包括本类及父类
        Field[] fields = studentClass.getFields();
        System.out.println(&quot;获取所有public修饰的属性， 包括本类及父类&quot;);
        for (int i = 0; i &lt; fields.length; i++) {
            System.out.println(fields[i].getName());
        }

        //获取本类的所有属性
        Field[] fields2 = personClass.getDeclaredFields();
        System.out.println(&quot;获取本类的所有属性&quot;);
        for (int i = 0; i &lt; fields2.length; i++) {
            System.out.println(fields2[i].getName());
        }

        //获取本类和父类和超类所有public修饰的方法
        Method[] methods = studentClass.getMethods();
        System.out.println(&quot;获取本类和父类和超类所有public修饰的方法&quot;);
        for (int i = 0; i &lt; methods.length; i++) {
            System.out.println(methods[i].getName());
        }

        //获取本类中所有的方法
        Method[] methods2 = studentClass.getDeclaredMethods();
        System.out.println(&quot;获取本类中所有的方法&quot;);
        for (int i = 0; i &lt; methods2.length; i++) {
            System.out.println(methods2[i].getName());
        } 

        //获取本类所有public修饰的构造器，`
        Constructor[] constructors = studentClass.getConstructors();
        System.out.println(&quot;获取本类所有public修饰的构造器&quot;);
        for (int i = 0; i &lt; constructors.length; i++) {
            System.out.println(constructors[i].getName());
        }

        //获取本类所有构造器
        Constructor[] constructors2 = studentClass.getDeclaredConstructors();
        System.out.println(&quot;获取本类所有构造器&quot;);
        for (int i = 0; i &lt; constructors2.length; i++) {
            System.out.println(constructors2[i]);
        }

        //获取包名
        System.out.println(&quot;获取包名&quot;);
        System.out.println(studentClass.getPackage());

        //以Class的形式返回父类信息
        Class&lt;?&gt; superclass = studentClass.getSuperclass();
        System.out.println(&quot;以Class的形式返回父类信息&quot;);
        System.out.println(superclass);

        //以Class[]的形式返回接口信息
        Class[] interfaces = studentClass.getInterfaces();
        System.out.println(&quot;以Class[]的形式返回接口信息&quot;);
        for (int i = 0; i &lt; interfaces.length; i++) {
            System.out.println(interfaces[i]);
        }

        //以Annotation[]的形式得到注解信息
        Annotation[] annotations = studentClass.getAnnotations();
        System.out.println(&quot;以Annotation[]的形式得到注解信息&quot;);
        for (int i = 0; i &lt; annotations.length; i++) {
            System.out.println(annotations[i]);
        }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java中final变量的初始化]]></title>
        <id>https://aruul.github.io/post/Z708mjxH2/</id>
        <link href="https://aruul.github.io/post/Z708mjxH2/">
        </link>
        <updated>2021-06-15T04:18:56.000Z</updated>
        <content type="html"><![CDATA[<p>今天在看java中String的源码，发现了自己对final变量初始化的了解不够好，有遗漏的地方，之前只知道第一种初始化方法。</p>
<pre><code class="language-java">public class FinalStudy {
    //第一种 在定义后直接初始化
    private final int a = 1;
    //第二种 声明变量后在构造方法中为其赋值
    //如果采用用这种方式，那么每个构造方法中都要有j赋值的语句
    private final int b;
    public FinalStudy(int b) {
        this.b = b;
    }
    // 初始化方式三，声明变量后在构造代码块中为其赋值
    // 如果采用此方式，就不能在构造方法中再次为其赋值
    // 构造代码块中的代码会在构造函数之前执行，如果在构造函数中再次赋值，
    // 就会造成final变量的重复赋值
    private final int c;
    {
        c = 3;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>