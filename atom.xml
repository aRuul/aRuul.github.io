<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aruul.github.io</id>
    <title>aRuul的无名小站</title>
    <updated>2021-05-13T11:57:28.826Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aruul.github.io"/>
    <link rel="self" href="https://aruul.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aruul.github.io/images/avatar.png</logo>
    <icon>https://aruul.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, aRuul的无名小站</rights>
    <entry>
        <title type="html"><![CDATA[二叉树]]></title>
        <id>https://aruul.github.io/post/t70ZdhScS/</id>
        <link href="https://aruul.github.io/post/t70ZdhScS/">
        </link>
        <updated>2021-05-13T11:52:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近一直在刷算法题，感觉还是需要把基础打牢一点，就暂停了刷题，从基本的算法书开始看。</p>
<p>《小灰的算法之旅》一个很基础的书</p>
<h2 id="二叉树">二叉树</h2>
<blockquote>
<p>什么是二叉树？官方是这样定义的：<strong>在计算机科学中，二叉树是每个结点最多有两个子树的树结构</strong>。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。</p>
</blockquote>
<p>其实这些都是很基础的东西，之前数据结构也都学过了。所以一些东西就省去不表。。。</p>
<p>二叉树的数据结构</p>
<pre><code class="language-java">public class TreeNode {
    public int data;
    public TreeNode leftChild;
    public TreeNode rightChild;

    public TreeNode(int data){
        this.data = data;
    }
}
</code></pre>
<h2 id="前序遍历生成二叉树">前序遍历生成二叉树</h2>
<p>我采用的是递归的方式，这样最容易明白</p>
<pre><code class="language-java">    //创建二叉树
	//inputList  存放前序遍历的二叉树的list
    public static TreeNode createBinaryTree(LinkedList&lt;Integer&gt; inputList){
        TreeNode treeNode = null;
        if(inputList==null||inputList.isEmpty()){
            return null;
        }
        Integer data = inputList.removeFirst();
        if(data!=null){
            treeNode = new TreeNode(data);
            treeNode.leftChild = createBinaryTree(inputList);
            treeNode.rightChild = createBinaryTree(inputList);
        }
        return treeNode;

    }
</code></pre>
<p>测试代码：</p>
<pre><code class="language-java"> public static void main(String[] args) {
        LinkedList&lt;Integer&gt; inputList = new LinkedList&lt;Integer&gt;();
        inputList.add(3); 
        inputList.add(2);
        inputList.add(9);
        inputList.add(null);
        inputList.add(null);
        inputList.add(10);
        inputList.add(null);
        inputList.add(null);
        inputList.add(8);
        inputList.add(null);
        inputList.add(4);
        TreeNode head = createBinaryTree(inputList);

    }
</code></pre>
<h2 id="前序遍历二叉树">前序遍历二叉树</h2>
<h3 id="递归的写法">递归的写法</h3>
<pre><code class="language-java">    //前序遍历--递归的方式
    public static void qian(TreeNode head){
        if(head==null){
            return;
        }
        System.out.println(head.data);
        qian(head.leftChild);
        qian(head.rightChild);
    }
</code></pre>
<h3 id="非递归的写法">非递归的写法</h3>
<pre><code class="language-java">	//前序遍历--非递归的方式
    public static void qian2(TreeNode head){
        // 用栈来存放
        Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
 
        while(head!=null||!stack.isEmpty()){
            //迭代访问节点的左节点，并入栈
            while(head!=null){
                System.out.println(head.data);
                stack.push(head);
                head = head.leftChild;
            }

            //若节点没有左孩子，栈中弹出栈顶结点，访问节点右节点
            if(!stack.isEmpty()){
                head = stack.pop();
                head = head.rightChild;
            }
        }
    }
</code></pre>
<h2 id="层次遍历">层次遍历</h2>
<p>大致思路：</p>
<p><img src="https://aruul.github.io/post-images/1620906969722.jpg" alt="" loading="lazy"><br>
<img src="https://aruul.github.io/post-images/1620906979070.jpg" alt="" loading="lazy"></p>
<pre><code class="language-java">//广度优先遍历--层次遍历
    public static void level(TreeNode head){
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(head);
        while (!queue.isEmpty()){
            TreeNode treeNode =queue.poll();
            System.out.println(treeNode.data);
            if(treeNode.leftChild!=null){
                queue.offer(treeNode.leftChild);
            }
            if(treeNode.rightChild!=null){
                queue.offer(treeNode.rightChild);
            }

        }

    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工厂模式]]></title>
        <id>https://aruul.github.io/post/PdwpIn0xO/</id>
        <link href="https://aruul.github.io/post/PdwpIn0xO/">
        </link>
        <updated>2021-05-10T13:24:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="工厂模式">工厂模式</h2>
<h3 id="1前言">1.前言</h3>
<p>设计模式大二的时候就学了，但是现在有些也忘得差不多了，现在决定重新学一遍。</p>
<p>立个flag，一周至少学三种设计模式。</p>
<blockquote>
<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<h3 id="2简单工厂模式">2.简单工厂模式</h3>
<p><strong>应用实例：</strong> 你需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</p>
<hr>
<pre><code class="language-java">/** 简单(静态)工厂模式
 * @author aRu
 * @date 2021/5/8 15:31
 */
public class CarFactory {
    public static Car getCar(String name){
        if(name.equals(&quot;大众&quot;)){
            return new DaZhong();
        }else if (name.equals(&quot;五菱&quot;)){
            return new WuLing();
        }
        return null;
    }
}
</code></pre>
<pre><code class="language-java">/**抽象汽车类
 * @author aRu
 * @date 2021/5/8 15:28
 */
public interface Car {
    void Name();
}
</code></pre>
<pre><code class="language-java">/** 大众
 * @author aRu
 * @date 2021/5/8 15:29
 */
public class DaZhong implements Car{
    @Override
    public void Name() {
        System.out.println(&quot;大众&quot;);
    }
}

----------------------------------------------------------------------------------------
    
/**五菱
 * @author aRu
 * @date 2021/5/8 15:30
 */
public class WuLing implements Car{
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}

</code></pre>
<p>测试</p>
<pre><code class="language-java">/** 测试类
 * @author aRu
 * @date 2021/5/8 15:34
 */

//测试 简单(静态)工厂模式
public class Test {
    public static void main(String[] args) {
        Car car1 = CarFactory.getCar(&quot;大众&quot;);
        Car car2 = CarFactory.getCar(&quot;五菱&quot;);

        car1.Name();
        car2.Name();
    }
}
</code></pre>
<hr>
<p><strong>缺点</strong>：试想当老板提出新需求要加一辆本田汽车的时候，你会发现，你此时不得不去修改<strong>CarFactory</strong>这个类，这就违反了开闭原则.</p>
<h3 id="3方法工厂模式">3.方法工厂模式</h3>
<p>针对上面简单工厂的缺点，我们引出方法工厂模式。</p>
<p>在方法工厂模式中，我们将<strong>工厂抽象起来</strong>，使得每个品牌的汽车都有自己的工厂，而不是像简单工厂模式里，一个大工厂建造不同品牌的车。</p>
<p>当我们需要新添加汽车时，只需要添加新的汽车类和对应的工厂就好。</p>
<hr>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508161257.png" alt="image-20210508161255712" loading="lazy"></figure>
<pre><code class="language-java">//抽象汽车工厂
public interface CarFactory {
    Car getCar();
}
</code></pre>
<pre><code class="language-java">//具体的汽车工厂  
public class WuLingFactory implements CarFactory{
    //五菱工厂
    @Override
    public Car getCar() {
        return new WuLing();
    }
}

----------------------------------------------
 public class DaZhongFactory implements CarFactory{
     //大众工厂
    @Override
    public Car getCar() {
        return new DaZhong();
    }
}
</code></pre>
<pre><code class="language-java">//抽象汽车类
public interface Car {
    void Name();
}
</code></pre>
<pre><code class="language-java">//具体汽车类
public class WuLing implements Car {
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}
----------------------------------------
public class WuLing implements Car {
    @Override
    public void Name() {
        System.out.println(&quot;五菱&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//方法工厂模式测试public class Test {    public static void main(String[] args) {        Car car = new WuLingFactory().getCar();        Car car2 = new DaZhongFactory().getCar();        car.Name();        car2.Name();    }}
</code></pre>
<h4 id="4抽象工厂模式">4.抽象工厂模式</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC25. K个一组翻转链表.]]></title>
        <id>https://aruul.github.io/post/ofb0ZIr8t/</id>
        <link href="https://aruul.github.io/post/ofb0ZIr8t/">
        </link>
        <updated>2021-05-09T13:15:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509195221.png" alt="image-20210509195220283" loading="lazy"></figure>
<pre><code class="language-java">输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
</code></pre>
</blockquote>
<h3 id="补充">补充</h3>
<p>ListNode定义如下</p>
<pre><code class="language-java">public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
</code></pre>
<h3 id="解法">解法</h3>
<pre><code class="language-java">    public static ListNode reverseKGroup(ListNode head, int k) {

        if(head == null) return head;
        ListNode a = head;
        ListNode b = head;
        for (int i = 0; i &lt; k; i++) {
            if(b == null) return head;
            b = b.next;
        }
        ListNode newNode = reverse(a, b);
        a.next = reverseKGroup(b, k);
        return newNode;
    }

    // 反转[a,b)个节点
    public static ListNode reverse(ListNode a, ListNode b) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=b){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<h3 id="思路">思路</h3>
<p>首先，由一道和他类似的题<a href="https://leetcode-cn.com/problems/reverse-linked-list/">【<strong>LC206. 反转链表</strong>】</a>引出我的解法。</p>
<p>在我之前的博客中这道题采用了递归解法。</p>
<p>其实，还有还可以用while循环来解。</p>
<pre><code class="language-java">    public static ListNode reverse(ListNode a) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=null){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<p>上面的代码完成了 给定一个链表头a，将这个链表反转。</p>
<p>具体步骤如下：</p>
<p>这是链表的初始状态：</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509200639.png" alt="image-20210509200638636" loading="lazy"></figure>
<hr>
<hr>
<p>然后开始执行该函数, 将【前置节点pre】指为null，将【当前节点cur】指向a</p>
<pre><code class="language-java"> ListNode pre,cur,next;
 pre = null;
 cur = a;
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509201429.png" alt="image-20210509201427829" loading="lazy"></figure>
<hr>
<hr>
<p>当【当前节点cur】不为空的时候，将【next节点】指向【当前节点cur的下一个】</p>
<pre><code class="language-java">while(cur!=null){
            next = cur.next;
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509201824.png" alt="image-20210509201823579" loading="lazy"></figure>
<hr>
<hr>
<p>之后将【当前节点cur】指向【前置节点pre】</p>
<pre><code class="language-java">cur.next = pre;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204604.png" alt="image-20210509204603462" loading="lazy"></figure>
<hr>
<hr>
<p>然后【pre、cur】开始向后移动一个节点，即：</p>
<ul>
<li>将【前置节点pre】移动到【当前节点cur】的位置</li>
<li>将【当前节点cur】移动到【后置节点next】的位置</li>
</ul>
<p><mark>注意：这时候没有移动next是因为不确定移动后【cur】是否为null。</mark></p>
<p><mark>当【cur】为null的时候再移动【后置节点next】会抛出空指针异常。这也是为什么循环的条件是【cur】不为null</mark></p>
<pre><code class="language-java">pre = cur;
cur = next;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204700.png" alt="image-20210509204659403" loading="lazy"></figure>
<hr>
<p>之后在while的循环条件中判断【cur】是否为空， 不为空则进入循环</p>
<p>进入循环中，重复之前的操作。将【next节点】指向【当前节点cur的下一个】</p>
<pre><code class="language-java">next = cur.next;
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204748.png" alt="image-20210509204747387" loading="lazy"></figure>
<hr>
<hr>
<p>之后将【当前节点cur】指向【前置节点pre】</p>
<pre><code class="language-java">cur.next = pre;
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204827.png" alt="image-20210509204825846" loading="lazy"></figure>
<hr>
<p>然后【pre、cur】开始向后移动一个节点，即：</p>
<ul>
<li>将【前置节点pre】移动到【当前节点cur】的位置</li>
<li>将【当前节点cur】移动到【后置节点next】的位置</li>
</ul>
<pre><code class="language-java">pre = cur;
cur = next;
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509204904.png" alt="image-20210509204902250" loading="lazy"></figure>
<hr>
<p>以此类推，直到【当前节点cur】为null，停止循环，返回【前置节点pre】</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205131.png" alt="image-20210509205128892" loading="lazy"></figure>
<hr>
<p>那反转链表的一部分呢，比如反转【a，b）之间的节点 （左闭右开）</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205450.png" alt="image-20210509205449221" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210509205552.png" alt="image-20210509205551013" loading="lazy"></figure>
<p>你会发现，它其实和我们反转整个链表差不多，反转整个链表的时候，</p>
<p>是相当于反转【a，null）之间的节点，</p>
<p>和反转【a，b）之间的节点有异曲同工之妙啊~</p>
<p>所以说，反转【a，b）之间的节点的代码就应该在他的基础改一改，把</p>
<pre><code class="language-java">while(cur!=null)
</code></pre>
<p>改为</p>
<pre><code class="language-java">while(cur!=b)
</code></pre>
<p>代码如下：</p>
<pre><code class="language-java">    // 反转[a,b)个节点
    public static ListNode reverse(ListNode a, ListNode b) {
        ListNode pre,cur,next;
        pre = null;
        cur = a;
        while(cur!=b){
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
</code></pre>
<hr>
<p>这和 K个一组翻转链表反转 有啥子关系呢？</p>
<p>每K个一组就是相当于区间【a，b）之间的节点有K个，然后一一反转。</p>
<p>这就用到了递归</p>
<pre><code class="language-java">    public static ListNode reverseKGroup(ListNode head, int k) {

        if(head == null) return head;
        // 区间 [a, b) 包含 k 个待反转元素
        ListNode a = head;
        ListNode b = head;
        for (int i = 0; i &lt; k; i++) {
             // 不足 k 个，不需要反转
            if(b == null) return head;
            b = b.next;
        }
        // 反转前 k 个元素,并获得反转后的头节点
        ListNode newNode = reverse(a, b);
        // 递归反转后续链表并连接起来，这里a反转后由子节点中由头变为尾，所以和a.next拼接
        a.next = reverseKGroup(b, k);
        return newNode;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC206链表反转]]></title>
        <id>https://aruul.github.io/post/hM2JnmBVE/</id>
        <link href="https://aruul.github.io/post/hM2JnmBVE/">
        </link>
        <updated>2021-05-08T10:41:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508164053.png" alt="image-20210508164052248" loading="lazy"></figure>
<p>输入：head = [1,2,3,4,5]<br>
输出：[5,4,3,2,1]</p>
</blockquote>
<h3 id="补充">补充</h3>
<p>ListNode定义如下</p>
<pre><code class="language-java">public class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 }
</code></pre>
<h3 id="解法">解法</h3>
<p>我之前刚好看过这个题的解析教程，所以就用递归小小的装个逼</p>
<pre><code class="language-java"> public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null){
            return head;
        }

        ListNode last = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return last;
    }
</code></pre>
<p><strong>大概思路如下：</strong></p>
<p>这个递归其实做的是：</p>
<p>​	如果这和链表是个空的或者只有一个节点，则反转之后还是本身。</p>
<pre><code class="language-java">if(head==null||head.next==null){
            return head;
 }
</code></pre>
<hr>
<p>​	如果不是，则一直查找下一个节点，</p>
<pre><code class="language-java">ListNode last = reverseList(head.next);
</code></pre>
<hr>
<p>​	直到某个节点的next的next为null【其实就是找倒数第二个节点】</p>
<pre><code class="language-java">if(head==null||head.next==null){
     return head;
 }
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508165935.png" alt="image-20210508165933723" loading="lazy"></figure>
<hr>
<p>并将last=最后一个节点</p>
<pre><code class="language-java">ListNode last = reverseList(head.next);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170116.png" alt="image-20210508170111643" loading="lazy"></figure>
<hr>
<p>此时head=倒数第二个节点</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170608.png" alt="image-20210508170602536" loading="lazy"></figure>
<hr>
<p>在将此时head的next的next指向head，【其实就是把最后一个节点指向倒数第二个，做的就是反转链表】</p>
<pre><code class="language-java">head.next.next = head;
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508170950.png" alt="image-20210508170948257" loading="lazy"></figure>
<hr>
<p>这时候 将head.next=null 【把head指向空】</p>
<pre><code class="language-jav">head.next = null;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508171248.png" alt="image-20210508171244794" loading="lazy"></figure>
<hr>
<p>这时候，其实已经反转了一部分了。</p>
<p>然后再将last返回给上一级【也就是3】，此时last=最后一个节点【也就是5】。</p>
<p><strong>其他的节点 以此类推，直到结束</strong></p>
<p><strong>最后的时候，再返回一个last，也就是5</strong></p>
<h2 id=""><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210508183828.png" alt="image-20210508183826788" loading="lazy"></h2>
<p>结束</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java反射(2)  反射调用的性能和优化方案]]></title>
        <id>https://aruul.github.io/post/L4U-TAPK3/</id>
        <link href="https://aruul.github.io/post/L4U-TAPK3/">
        </link>
        <updated>2021-05-04T08:51:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="反射调用的性能和优化方案">反射调用的性能和优化方案</h2>
<h3 id="对比">对比</h3>
<p>普通方法</p>
<pre><code class="language-java">    //普通方法
    public static void m1(){
        Cat cat = new Cat();

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            cat.say();
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;普通方法执行时间：&quot;+(end-start));
    }
</code></pre>
<p>通过反射</p>
<pre><code class="language-java">//反射
    public static void m2() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class aClass = Class.forName(&quot;org.example.Cat&quot;);
        Object o = aClass.newInstance();
        Method say = aClass.getMethod(&quot;say&quot;);

        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            say.invoke(o);
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;反射机制执行时间：&quot;+(end-start));


    }
</code></pre>
<p>两者运行时间对比</p>
<pre><code>普通方法执行时间：3 ms
反射机制执行时间：175 ms
</code></pre>
<h3 id="优化">优化</h3>
<blockquote>
<p>反射调用优化-关闭访问检查</p>
<ol>
<li>Method和 Field、 Constructor象都有 setAccessible()方法</li>
<li>setAccessible()作用是启动和禁用访问安全检查的开关<br>
3.参数值为true表示反射的对象在使用时取消访向检查，提高反射的效率。<br>
参数值为 false则表示反射的对象执行访向检查</li>
</ol>
</blockquote>
<p>所以可以通过setAccessible()来优化反射。</p>
<p>其实呢，优化之后效率也没有高出很多。</p>
<pre><code class="language-java">    //反射优化
    public static void m3() throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {

        Class aClass = Class.forName(&quot;org.example.Cat&quot;);
        Object o = aClass.newInstance();
        Method say = aClass.getMethod(&quot;say&quot;);

        //取消在反射调用方法时 取消访问检测
        say.setAccessible(true);


        long start = System.currentTimeMillis();

        for (int i = 0; i &lt; 90000000; i++) {
            say.invoke(o);
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;反射优化机制执行时间：&quot;+(end-start));

    }
</code></pre>
<hr>
<p>执行结果对比</p>
<pre><code>普通方法执行时间：3 ms
反射机制执行时间：176 ms
反射优化机制执行时间：129 ms
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java 反射(1)--快速开始]]></title>
        <id>https://aruul.github.io/post/s8pJIRpaT/</id>
        <link href="https://aruul.github.io/post/s8pJIRpaT/">
        </link>
        <updated>2021-05-03T13:18:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="快速开始">快速开始</h3>
<h4 id="1什么是反射">1.什么是反射？</h4>
<p>如果你研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。</p>
<p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<p><strong>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</strong></p>
<h4 id="2反射机制优缺点">2.反射机制优缺点</h4>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li>
</ul>
<h4 id="3由一个例子引出反射">3.由一个例子引出反射</h4>
<h5 id="31需求">3.1需求</h5>
<blockquote>
<p>根据配置文件re. properties指定信息，创建Cat过象并调用方法say</p>
</blockquote>
<p>re. properties文件</p>
<pre><code class="language-properties">classfullpath=org.example.Cat
method=say
</code></pre>
<p>Cat</p>
<pre><code class="language-java">package org.example;

/**
 * @author aRu
 * @date 2021/5/3 10:01
 */
public class Cat {
    private String name = &quot;招财猫&quot;;
    public int age= 3;

    public Cat() {
    }

    public Cat(String name) {
        this.name = name;
    }

    public void say(){
        System.out.println(&quot;miao~ i am &quot;+name);
    }
}
</code></pre>
<p>工程目录如下，本次代码写在org.example.quickStart_01下</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210503213409.png" alt="image-20210503213403742" loading="lazy"></figure>
<h5 id="32实现">3.2实现</h5>
<pre><code class="language-java">package org.example.quickStart_01;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

/**问题的引入
 * @author aRu
 * @date 2021/5/3 10:04
 */
public class ReflectionQuickStart {
    public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        //根据配置文件 创建Cat对象并调用 配置文件中指定的方法

        //1.读取配置文件
        Properties properties = new Properties();
        properties.load(new FileInputStream(&quot;src\\org\\example\\re.properties&quot;));
        String classfullpath = properties.get(&quot;classfullpath&quot;).toString();
        String method = properties.get(&quot;method&quot;).toString();
        System.out.println(&quot;类的全路径： &quot;+classfullpath);
        System.out.println(&quot;方法名： &quot;+method);

        //2.使用反射机制
        Class cls = Class.forName(classfullpath);
        //通过 cls 得到你加载的类 Cat的对象实例
        Object o = cls.newInstance();
        System.out.println(&quot;o的类型： &quot;+o.getClass());
        //通过cls 得到你加载的类Cat的 method 方法
        Method method1 = cls.getMethod(method);
        //通过method1 调用方法： 即，通过方法对象 来实现调用方法
        method1.invoke(o);
        

    }
}

</code></pre>
<hr>
<p>运行结果</p>
<pre><code>类的全路径： org.example.Cat
方法名： say
o的类型： class org.example.Cat
miao~ i am 招财猫
</code></pre>
<p>补充</p>
<pre><code class="language-java">        //得到类的成员变量
        //注意： cls.getField(&quot;name&quot;)不能得到私有的属性
        Field nameField = cls.getField(&quot;age&quot;);
        System.out.println(nameField.get(o));

        //得到对象的构造函数
        Constructor constructor = cls.getConstructor();//()中可以指定构造参数类型，这里没写，则返回无参构造
        System.out.println(&quot;无参构造：&quot;+constructor);

        Constructor constructor2 = cls.getConstructor(String.class);
        System.out.println(&quot;有参构造：&quot;+constructor2);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java注解浅谈]]></title>
        <id>https://aruul.github.io/post/3NqPQbqyz/</id>
        <link href="https://aruul.github.io/post/3NqPQbqyz/">
        </link>
        <updated>2021-05-03T13:13:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="注解">注解</h3>
<hr>
<h4 id="内置注解">内置注解</h4>
<ul>
<li>
<p>@Override</p>
<p>表示一个方法声名打算重写超类中的另一个方法声明。</p>
</li>
<li>
<p>@Deprecated</p>
<p>表示不鼓励程序员使用这样的元素</p>
</li>
<li>
<p>@SuppressWarnings()</p>
<p>抑制编译时的警告信息</p>
<p>如@SuppressWarnings(&quot;all&quot;)等</p>
<hr>
<h4 id="元注解">元注解</h4>
<p>除了直接使用JDK 定义好的注解，我们还可以自定义注解，在JDK 1.5中提供了4个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是：</p>
</li>
<li>
<p>@Target</p>
<p>Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方</p>
</li>
<li>
<p>@Retention</p>
<p>Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时）</p>
<p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。</p>
<p><mark>RUNTIME一般较常用</mark></p>
<pre><code>SOURCE,    // 源文件保留
CLASS,       // 编译期保留，默认值
RUNTIME   // 运行期保留，可通过反射去获取注解信息
</code></pre>
</li>
<li>
<p>@Documented</p>
<p>表示是否将注解生成在JavaDoc中</p>
</li>
<li>
<p>@Inherited</p>
<p>子类可以继承父类的注解</p>
</li>
</ul>
<p>我们可以使用这4个元注解来对我们自定义的注解类型进行注解</p>
<hr>
<h4 id="自定义注解">自定义注解</h4>
<p>使用@interface</p>
<pre><code class="language-JAVA">//定义一个注解
@Target(value = {ElementType.METHOD,ElementType.TYPE})  //表示注解可以用在方法、类上
@Retention(value = RetentionPolicy.RUNTIME)             //表示注解在什么时候有效RUNTIME&gt;class&gt;sources
@Documented                                             //表示是否将注解生成在JavaDoc中
@Inherited                                              //子类可以继承父类的注解
public @interface MyAnnotation{

}
</code></pre>
<pre><code class="language-java">//定义一个注解
@Target(value = {ElementType.METHOD,ElementType.TYPE})  //表示注解可以用在方法、类上
@Retention(value = RetentionPolicy.RUNTIME)             //表示注解在什么时候有效RUNTIME&gt;class&gt;sources
@Documented                                             //表示是否将注解生成在JavaDoc中
@Inherited                                              //子类可以继承父类的注解
public @interface MyAnnotation{
    //注解的参数： 参数类型+参数名()
    String name() default &quot;&quot;;  //default 表示默认值  这里是默认值为空
    int age() default 0;
    int id() default -1;    //默认值为-1，代表不存在

    String [] schools();
}


@Target(value = {ElementType.METHOD,ElementType.TYPE})  //表示注解可以用在方法、类上
@Retention(value = RetentionPolicy.RUNTIME)             //表示注解在什么时候有效RUNTIME&gt;class&gt;sources
public @interface MyAnnotation2{
    String value();  //如果注解中只有一个参数，则建议定义为value，这样在使用的时候直接写  @MyAnnotation2(&quot;赋值&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ubuntu ngnix的安装和配置]]></title>
        <id>https://aruul.github.io/post/xeGoYob77/</id>
        <link href="https://aruul.github.io/post/xeGoYob77/">
        </link>
        <updated>2021-04-30T01:24:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基本概念">基本概念</h1>
<h2 id="什么是-nginx">什么是 Nginx</h2>
<p>一个项目或平台，用户使用量少，并发量小的情况下，一台 Tomcat 服务器就可以满足需求。但当平台用户量增多，并发量增大时，一台 Tomcat 服务器就不能够很好地支撑。于是就需要做横向扩展，多增加几台服务器，并设置一个代理服务器。用户如果要访问平台首先会经过代理服务器，代理服务器实现处理用户的请求和转发到真实服务器，也就是反向代理。在做横向扩展后，每台服务器的大小、性能可能各不相同。代理服务器需要根据用户的请求，服务器的状态等实际情况实现选择和转发，也就是负载均衡。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudybda5ac84-227d-47b9-8711-d19567828c6d.png" alt="img" loading="lazy"><br>
Nginx（ engine x ）是一个高性能的 HTTP 和反向代理 web 服务器。<br>
Nginx 特点是占用内存少，并发能力强。1M 左右的内存支持高达 50000 个并发连接数的响应，而 Tomcat 只支持 500~600 个响应。<br>
Nginx 安装简单，配置文件简洁，启动容易且能持续运行。<br>
Nginx 的作用简单来说就是反向代理和负载均衡。</p>
<h2 id="正向代理和反向代理">正向代理和反向代理</h2>
<p>正向代理基于客户端，代理客户端，是一种主动地行为。比如使用 VPN 访问外网，用户需要手动选择香港、日本或美国的节点，通过节点转发到外网服务器，这些节点代理了外网的服务器。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy872b3db7-d641-4ef7-9811-73a748fd1c27.png" alt="img" loading="lazy"><br>
反向代理基于服务端，代理服务端，是一种被动地行为。比如访问百度，百度的服务器可能不在同一个地方，但是用户可以通过访问百度的域名 www.baidu.com，由代理服务器实现转发，这个过程用户是无感知的。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyeacfb3ba-66bf-467e-b414-33bd466b046c.png" alt="img" loading="lazy"></p>
<h2 id="负载均衡">负载均衡</h2>
<p>Nginx 提供的负载均衡策略有 2 种：内置策略和扩展策略。内置策略分为轮询，加权轮询，Ip hash。扩展策略由程序员自行创造。<br>
轮询<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy33a6e959-9de6-4361-9452-63add93d36db.png" alt="img" loading="lazy"><br>
加权轮询<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyce51f657-9c95-44eb-a473-46b12f3e173c.png" alt="img" loading="lazy"><br>
Ip hash<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy8406dd2c-6596-4292-8890-3423e095f28f.png" alt="img" loading="lazy"><br>
动静分离<br>
一个项目中，有些请求需要后台处理，而有些请求不需要后台处理，如 HTML、CSS、JavaScript 等文件，这些文件统称为静态资源。在开发中将不经常变动地资源与经常变动地资源分离，将这些静态资源缓存到本地 Nginx 中，由 Nginx 直接返回，可以大大提高资源响应的速度和网页的健壮性。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy4ffdae63-5189-4289-b465-94b1be9e731d.png" alt="img" loading="lazy"></p>
<hr>
<h1 id="nginx-安装">Nginx 安装</h1>
<p>1、下载 nginx。<br>
下载 Linux 安装包，使用<code>tar -zxvf</code>命令解压到对应的目录即可。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy2700bc18-8194-43ba-aa31-6fbb78906ed1.png" alt="img" loading="lazy"><br>
2、安装 nginx 所需依赖。</p>
<pre><code>yum install gcc-c++
yum install -y pcre pcre-devel
yum install -y openssl openssl-devel
</code></pre>
<p>3、进入 nginx 目录，执行以下两个命令。</p>
<pre><code>./configuremake install
</code></pre>
<p>4、查找 nginx 安装路径并进入。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyf7a7e81f-7e8c-49af-a17a-b2a5794fb73c.png" alt="img" loading="lazy"><br>
5、启动 nginx。</p>
<pre><code>./nginx
</code></pre>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudycedd22d3-3f9a-4672-8262-403135731260.png" alt="img" loading="lazy"><br>
6、查看 nginx 配置文件.<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudyda8d055d-e44a-45f3-937e-6c9eefc4877a.png" alt="img" loading="lazy"><br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy47e6db4a-df2b-43a9-a501-47e1e2fbc1df.png" alt="img" loading="lazy"><br>
7、检查 nginx 是否启动成功。<br>
访问 服务器 ip:80，如果出现以下画面则说明 nginx 启动成功。<br>
<img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/04/23/kuangstudy5d020ccc-718c-4774-a07b-70168482f697.png" alt="img" loading="lazy"><br>
如果访问失败，检查服务器防火墙和阿里云安全组的端口是否开启。</p>
<hr>
<h1 id="nginx-常用命令">Nginx 常用命令</h1>
<pre><code class="language-java">cd /usr/local/nginx/sbin/
./nginx  启动
./nginx -s stop  停止
./nginx -s quit  安全退出
# reload命令十分常用，如果在线上部署的时候想要更改配置文件，完成后直接使用reload就可以快速重新加载。
./nginx -s reload  重新加载配置文件
ps aux|grep nginx  查看nginx进程
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LC136只出现一次的数字]]></title>
        <id>https://aruul.github.io/post/AyhAIG8Q_/</id>
        <link href="https://aruul.github.io/post/AyhAIG8Q_/">
        </link>
        <updated>2021-04-29T14:19:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>现在有一个整数类型的数组，数组中素只有一个元素只出现一次，其余的元素都出现两次。</p>
<p><strong>注意：</strong></p>
<p>你需要给出一个线性时间复杂度的算法，你能在不使用额外内存空间的情况下解决这个问题么？</p>
<p>示例1</p>
<h2 id="输入">输入</h2>
<p>[复制](javascript:void(0)😉</p>
<pre><code>[1,0,1]
</code></pre>
<h2 id="返回值">返回值</h2>
<p>[复制](javascript:void(0)😉</p>
<pre><code>0
</code></pre>
<hr>
<h4 id="本菜鸡的解题代码">本菜鸡的解题代码</h4>
<p>大概思路是暴力对比，暴力就完事了。</p>
<p>二重循环，先提前在外层循环设定一个初始标志，为0，</p>
<p>内存循环 ，如果找到相同的，则将标志设为1。</p>
<p>外层在根据标志判断是否找到相同的，否则返回出不同的值。</p>
<pre><code class="language-java">public class Solution {
    /**
     * 
     * @param A int整型一维数组 
     * @return int整型
     */
    public int singleNumber (int[] A) {
        // write code here
        for (int i = 0; i&lt;A.length ;i++) {
            int hasSame=0;
            for (int j = 0; j&lt;A.length; j++){
                if(i==j){
                    System.out.println(&quot;相同索引  A[&quot;+i+&quot;]=&quot;+A[i]+&quot; ,i=&quot;+i+&quot;, j=&quot;+j);
                    continue;
                }
                if(A[i]==A[j]){
                    hasSame=1;
                    break;
                }
            }
            if(hasSame==0){
                return A[i];
            }
        }
        return 0;
    }
}
</code></pre>
<hr>
<h3 id="大佬的代码">大佬的代码</h3>
<blockquote>
<p>链接：https://www.nowcoder.com/questionTerminal/0bc646909e474ac5b031ec6836a47768<br>
来源：牛客网</p>
</blockquote>
<p>根据异或运算特点：</p>
<p>两个相同的数进行异或，结果为0</p>
<pre><code class="language-java">	public static int singleNumber(int[] A) {
		int num = 0;
		for(int i=0;i&lt;A.length;i++){
			num^=A[i];
		}
		return num;
	}
</code></pre>
<p>其实只要记住：</p>
<p>​    1.异或满足交换律。</p>
<p>​    2.相同两个数异或为0。</p>
<p>​    3.0异或一个数为那个数本身。</p>
<p>最后结果即出现1次的那个数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阿里云https]]></title>
        <id>https://aruul.github.io/post/j3kVP0ZjV/</id>
        <link href="https://aruul.github.io/post/j3kVP0ZjV/">
        </link>
        <updated>2021-04-29T09:49:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1白嫖阿里云ssl证书">1.白嫖阿里云ssl证书</h3>
<ul>
<li><a href="https://common-buy.aliyun.com/?spm=5176.15089375.J_5834642020.3.360f65c3prTSPX&amp;commodityCode=cas_dv_public_cn&amp;request=%7B%22ord_time%22:%221:Year%22,%22order_num%22:1,%22product%22:%22cert_product%22,%22domain%22:%22all%22,%22productCode%22:%22symantec-dv-1-starter%22,%22service_num%22:2%7D">进入购买网址</a></li>
<li>选择如下图所示</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429170518.png" alt="image-20210429170510021" loading="lazy"></figure>
<ul>
<li>点击购买</li>
</ul>
<h3 id="2控制台证书申请">2.控制台证书申请</h3>
<p>毕竟是免费的，所以有点麻烦，买了之后还要去ssl控制台去申请，   <a href="https://yundun.console.aliyun.com/?p=cas#/certExtend">SSL控制台</a></p>
<ul>
<li>选择右侧的SSL证书------》再点击证书申请</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429171100.png" alt="image-20210429171051664" loading="lazy"></figure>
<ul>
<li>
<p>弹出如下界面，点击确认</p>
<img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429171318.png" alt="image-20210429171314073" style="zoom: 67%;" />
</li>
<li>
<p>证书申请之后，点击【免费证书】</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429171555.png" alt="image-20210429171553744" loading="lazy"></figure>
<ul>
<li>
<p>再点击证书申请，再弹出的页面中填写个人信息即可，之后再点击验证，验证成功后就可以领证书了</p>
</li>
<li>
<p>之后再根据自己的情况下载对应的证书</p>
</li>
</ul>
<hr>
<h3 id="3nginx配置https">3.nginx配置https</h3>
<p>在阿里云在点击证书下载的时候会有相关的文档，我这里配置的是nginx</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210429172922.png" alt="image-20210429172920399" loading="lazy"></figure>
<p>下载证书后将其上传的nginx的配置文件conf根目录中，可以建立一个cert文件夹，然后放入。</p>
<p>接着在配置文件中添加一个新的server</p>
<pre><code class="language-xml">#以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。
server {
         listen 443 ssl; #配置HTTPS的默认访问端口号为443。此处如果未配置HTTPS的默认访问端口，可能会造成Nginx无法启动。Nginx 1.15.0以上版本请使用listen 443 ssl代替listen 443和ssl on。
         server_name www.certificatestests.com; #将www.certificatestests.com修改为您证书绑定的域名，例如：www.example.com。如果您购买的是通配符域名证书，要修改为通配符域名，例如：*.aliyun.com。
         root html;
         index index.html index.htm;
         ssl_certificate cert/domain name.pem;  #将domain name.pem替换成您证书的文件名称。
         ssl_certificate_key cert/domain name.key; #将domain name.key替换成您证书的密钥文件名称。
         ssl_session_timeout 5m;
         ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。
         ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。
         ssl_prefer_server_ciphers on;
         location / {
         	root html;  #站点目录。
         	index index.html index.htm;
         }
}
</code></pre>
<p><mark>注意开启443端口哈</mark></p>
<h4 id="3-1-可能出现的错误">3. 1 可能出现的错误</h4>
<pre><code class="language-xml">the &quot;ssl&quot; parameter requires ngx_http_ssl_module
</code></pre>
<p>原因是在你装nginx的时候没有配置SSL模块</p>
<p><strong>说明：我的nginx安装目录为：/usr/local/nginx ， 源码包在/usr/src/nginx-1.8.0目录</strong></p>
<h4 id="nginx开启ssl模块">Nginx开启SSL模块：</h4>
<p>切换到源码包：<br>
<code>cd /usr/src/nginx-1.8.0</code></p>
<p>查看nginx原有的模块<br>
<code>/usr/local/nginx/sbin/nginx -V</code></p>
<p>在configure arguments:后面显示的原有的configure参数如下：<br>
<code>--prefix=/usr/local/nginx --with-http_stub_status_module</code></p>
<h4 id="二从新配置ssl模块">二：从新配置SSL模块：</h4>
<p>进入nginx源码包目录，运行：<br>
<code>./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</code></p>
<p>配置完成后，运行命令make命令：</p>
<h4 id="make">make</h4>
<p>注意：此处不能进行make install，否则就是覆盖安装</p>
<h4 id="三替换已安装好的nginx包">三：替换已安装好的nginx包</h4>
<p>替换之前先备份：<br>
<code>cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</code></p>
<h4 id="先停止nginx服务">先停止nginx服务：</h4>
<p>//查询nginx主进程号<br>
<code>$ ps -ef | grep nginx</code></p>
<p>//从容停止Nginx：<br>
<code>$kill -QUIT 主进程号</code></p>
<p>//快速停止Nginx：<br>
<code>kill -TERM 主进程号</code></p>
<p>//强制停止Nginx：<br>
<code>pkill -9 nginx</code><br>
将刚刚编译好的nginx覆盖掉原有的nginx</p>
<p><code>cp ./objs/nginx /usr/local/nginx/sbin/</code><br>
然后启动nginx，仍可以通过命令查看是否已经加入成功</p>
<pre><code>/usr/local/nginx/sbin/nginx -V
</code></pre>
<p>此时应该显示为即配置成功：<br>
<code>configure arguments: --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module</code></p>
<hr>
<p>之后照常开启nginx即可</p>
]]></content>
    </entry>
</feed>