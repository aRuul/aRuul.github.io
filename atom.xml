<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aruul.github.io</id>
    <title>aRuul的无名小站</title>
    <updated>2021-04-11T03:26:28.136Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aruul.github.io"/>
    <link rel="self" href="https://aruul.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aruul.github.io/images/avatar.png</logo>
    <icon>https://aruul.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, aRuul的无名小站</rights>
    <entry>
        <title type="html"><![CDATA[新的开始]]></title>
        <id>https://aruul.github.io/post/newbegain/</id>
        <link href="https://aruul.github.io/post/newbegain/">
        </link>
        <updated>2021-04-11T01:41:56.000Z</updated>
        <content type="html"><![CDATA[<p>今天开始使用Gridea写博客辣！<br>
之前的博客会陆续补上来的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lombook]]></title>
        <id>https://aruul.github.io/post/iJ3Ze3gYo/</id>
        <link href="https://aruul.github.io/post/iJ3Ze3gYo/">
        </link>
        <updated>2021-03-17T08:24:24.000Z</updated>
        <content type="html"><![CDATA[<p>使用步骤</p>
<ol>
<li>
<p>在idea中装Lombok插件</p>
</li>
<li>
<p>导入jar包</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.10&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>3.使用注解</p>
<hr>
<h2 id="有哪些注解">有哪些注解？</h2>
<ul>
<li>@Data</li>
<li>@Setter</li>
<li>@Getter</li>
<li>@Log4j</li>
<li>@AllArgsConstructor</li>
<li>@NoArgsConstructor</li>
<li>@EqualsAndHashCode</li>
<li>@NonNull</li>
<li>@Cleanup</li>
<li>@ToString</li>
<li>@RequiredArgsConstructor</li>
<li>@Value</li>
<li>@SneakyThrows</li>
<li>@Synchronized</li>
</ul>
<h2 id="注解详解">注解详解</h2>
<p><strong>@Data</strong></p>
<p>注解在 <strong>类</strong> 上；提供类所有属性的 get 和 set 方法，此外还提供了equals、canEqual、hashCode、toString 方法。</p>
<figure data-type="image" tabindex="1"><img src="https://pic4.zhimg.com/80/v2-9b36bb6fd37372cee213b118d7e26c7b_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Setter</strong></p>
<p>注解在 <strong>属性</strong> 上；为单个属性提供 set 方法; 注解在 <strong>类</strong> 上，为该类所有的属性提供 set 方法， 都提供默认构造方法。</p>
<figure data-type="image" tabindex="2"><img src="https://pic2.zhimg.com/80/v2-12139fea446022a1986ba2042f886a7d_720w.jpg" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://pic3.zhimg.com/80/v2-994e89f3c9c6976b05e345fcd0848692_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Getter</strong></p>
<p>注解在 <strong>属性</strong> 上；为单个属性提供 get 方法; 注解在 <strong>类</strong> 上，为该类所有的属性提供 get 方法，都提供默认构造方法。</p>
<figure data-type="image" tabindex="4"><img src="https://pic3.zhimg.com/80/v2-18149a8d23a4e3673b9441b198a1f976_720w.jpg" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://pic4.zhimg.com/80/v2-2cb156b6d93198d271f2ff4bca1c21ff_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Log4j</strong></p>
<p>注解在 <strong>类</strong> 上；为类提供一个 属性名为 log 的 log4j 日志对象，提供默认构造方法。</p>
<figure data-type="image" tabindex="6"><img src="https://pic1.zhimg.com/80/v2-ce28a344baae222aa0c4ea0b84461000_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@AllArgsConstructor</strong></p>
<p>注解在 <strong>类</strong> 上；为类提供一个全参的构造方法，加了这个注解后，类中不提供默认构造方法了。</p>
<figure data-type="image" tabindex="7"><img src="https://pic4.zhimg.com/80/v2-31bca5c4da7e9c475bade1eaa400802f_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@NoArgsConstructor</strong></p>
<p>注解在 <strong>类</strong> 上；为类提供一个无参的构造方法。</p>
<figure data-type="image" tabindex="8"><img src="https://pic2.zhimg.com/80/v2-518a849c9d5fffde690b2a801e951275_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@EqualsAndHashCode</strong></p>
<p>注解在 <strong>类</strong> 上, 可以生成 equals、canEqual、hashCode 方法。</p>
<figure data-type="image" tabindex="9"><img src="https://pic1.zhimg.com/80/v2-6bddfeaa77e8dd29b05bb8b499da65f4_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@NonNull</strong></p>
<p>注解在 <strong>属性</strong> 上，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，也会有一个默认的无参构造方法。</p>
<figure data-type="image" tabindex="10"><img src="https://pic2.zhimg.com/80/v2-268671034ed3141e117c99f055a3f2ad_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Cleanup</strong></p>
<p>这个注解用在 <strong>变量</strong> 前面，可以保证此变量代表的资源会被自动关闭，默认是调用资源的 close() 方法，如果该资源有其它关闭方法，可使用 @Cleanup(“methodName”) 来指定要调用的方法，也会生成默认的构造方法</p>
<figure data-type="image" tabindex="11"><img src="https://pic3.zhimg.com/80/v2-6408e68a5f77eba5add53abe3ee8abf2_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@ToString</strong></p>
<p>这个注解用在 <strong>类</strong> 上，可以生成所有参数的 toString 方法，还会生成默认的构造方法。</p>
<figure data-type="image" tabindex="12"><img src="https://pic1.zhimg.com/80/v2-28b29cc1b5940f31de246e719cfcd9e8_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@RequiredArgsConstructor</strong></p>
<p>这个注解用在 <strong>类</strong> 上，使用类中所有带有 @NonNull 注解的或者带有 final 修饰的成员变量生成对应的构造方法。</p>
<figure data-type="image" tabindex="13"><img src="https://pic3.zhimg.com/80/v2-866a42cd03707c5095b44721be5e17ba_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Value</strong></p>
<p>这个注解用在 <strong>类</strong> 上，会生成含所有参数的构造方法，get 方法，此外还提供了equals、hashCode、toString 方法。</p>
<figure data-type="image" tabindex="14"><img src="https://pic1.zhimg.com/80/v2-159c62a7a9f545505246939abe6cfcc0_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@SneakyThrows</strong></p>
<p>这个注解用在 <strong>方法</strong> 上，可以将方法中的代码用 try-catch 语句包裹起来，捕获异常并在 catch 中用 Lombok.sneakyThrow(e) 把异常抛出，可以使用 @SneakyThrows(Exception.class) 的形式指定抛出哪种异常，也会生成默认的构造方法。</p>
<figure data-type="image" tabindex="15"><img src="https://pic3.zhimg.com/80/v2-2cd23582188406e3301a318d37bfa426_720w.jpg" alt="img" loading="lazy"></figure>
<p><strong>@Synchronized</strong></p>
<p>这个注解用在 <strong>类方法</strong> 或者 <strong>实例方法</strong> 上，效果和 synchronized 关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized 关键字的锁对象分别是类的 class 对象和 this 对象，而 @Synchronized 的锁对象分别是 私有静态 final 对象 lock 和 私有 final 对象 lock，当然，也可以自己指定锁对象，此外也提供默认的构造方法。</p>
<figure data-type="image" tabindex="16"><img src="https://pic4.zhimg.com/80/v2-7f38c354c3ca8ba9205ecbcaae04d1d3_720w.jpg" alt="img" loading="lazy"></figure>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[8-多对一]]></title>
        <id>https://aruul.github.io/post/q2Mgvtj6L/</id>
        <link href="https://aruul.github.io/post/q2Mgvtj6L/">
        </link>
        <updated>2021-03-17T02:23:00.000Z</updated>
        <content type="html"><![CDATA[<p>student表</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210317213129.png" alt="image-20210317213128631" loading="lazy"></figure>
<hr>
<p>teacher表</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210317213220.png" alt="image-20210317213220202" loading="lazy"></figure>
<hr>
<p><mark>一个老师对应多个学生</mark></p>
<hr>
<p><strong>Teacher.java</strong></p>
<pre><code class="language-java">package org.example.pojo;

/**
 * @author aRu
 * @date 2021/3/17 20:21
 */
public class Teacher {
    private int id;
    private String name;

    public Teacher() {
    }

    public Teacher(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Teacher{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p><strong>Student.java</strong></p>
<p><mark>一个老师对应多个学生，在学生类中写上<strong>Teacher teacher</strong></mark></p>
<pre><code class="language-java">package org.example.pojo;

/**
 * @author aRu
 * @date 2021/3/17 20:20
 */
public class Student {
    private int id;
    private String name;
    private Teacher teacher;

    public Student() {
    }

    public Student(int id, String name, Teacher teacher) {
        this.id = id;
        this.name = name;
        this.teacher = teacher;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Teacher getTeacher() {
        return teacher;
    }

    public void setTeacher(Teacher teacher) {
        this.teacher = teacher;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, teacher=&quot; + teacher +
                '}';
    }
}
</code></pre>
<hr>
<p><strong>StudentMapper.java</strong></p>
<pre><code class="language-java">public interface StudentMapper {
    //查询所有的学生信息 以及对应的老师的信息
    public List&lt;Student&gt; getStudent();
}
</code></pre>
<ul>
<li><mark>在查询学生时，学生中包含了Teacher这个类，查询的resultType比较复杂 ，所以采用resultMap的形式</mark></li>
<li><mark>sql语句中将学生表、教师表中s.id  s.name  t.name字段起别名为sid  sname   tname</mark></li>
</ul>
<pre><code class="language-mysql">select s.id sid, s.name sname, t.name tname
        from mybatis.student s,mybatis.teacher t
        where s.tid=t.id;
</code></pre>
<ul>
<li>
<p><mark>resultMap的编写</mark></p>
<p><mark>在上一步中三个关键的数据库字段名被起别名，与原来java中的属性名不一致，所以要一一对应一下；</mark></p>
<p><mark>对于一般的属性 用<code>result</code>标签</mark></p>
<p><mark>对于类来说  用 <strong>association</strong> 标签 在java实体类中属性名property为teacher ,  javaType=&quot;Teacher&quot;</mark></p>
<p><mark>而原来java实体类中属性名name对于起别名后 的tname</mark></p>
</li>
</ul>
<p><strong>StudentMapper.xml</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace 是要绑定的类的路径--&gt;
&lt;mapper namespace=&quot;org.example.dao.StudentMapper&quot;&gt;
    &lt;!--按照结果嵌套处理--&gt;
    &lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt;
        select s.id sid, s.name sname, t.name tname
        from mybatis.student s,mybatis.teacher t
        where s.tid=t.id;
    &lt;/select&gt;

    &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt;
        &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
        &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;
            &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[7-注解开发]]></title>
        <id>https://aruul.github.io/post/d8DRHzqIN/</id>
        <link href="https://aruul.github.io/post/d8DRHzqIN/">
        </link>
        <updated>2021-03-15T14:01:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1面向接口编程">1.面向接口编程</h3>
<ul>
<li>
<p>使用面向接口编程的根本原因：<strong>解耦</strong>，可拓展，提高复用。</p>
</li>
<li>
<p>分层开发中，上层不用管具体的实现，大家都遵循共同的标准，使得开发变得更容易，规范性更好。</p>
</li>
</ul>
<hr>
<h3 id="2注解的基本步骤">2.注解的基本步骤</h3>
<ol>
<li>
<p>编写基本的配置文件【mybatis-config.xml】</p>
</li>
<li>
<p>编写pojo类</p>
</li>
<li>
<p>编写Dao层接口</p>
<pre><code class="language-java">//org.example.dao.UserMapper
public interface UserMapper {
    @Select(&quot;select * from user&quot;)
    List&lt;User&gt; getUser();
}
</code></pre>
</li>
</ol>
<p>4.在配置文件【mybatis-config.xml】中注册Mappers,绑定接口</p>
<pre><code>    &lt;mappers&gt;
        &lt;mapper class=&quot;org.example.dao.UserMapper&quot;/&gt;
    &lt;/mappers&gt;
</code></pre>
<p>5.测试</p>
<pre><code class="language-java">    @Test
    public void test(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        List&lt;User&gt; userList=mapper.getUser();
        for (User user : userList) {
            System.out.println(user);
        }
        sqlSession.close();
    }
</code></pre>
<h3 id="3本质">3.本质</h3>
<p>Java反射机制的实现</p>
<h3 id="4基于注解的增删改查">4.基于注解的增删改查</h3>
<h4 id="41自动提交">4.1自动提交</h4>
<p>之前写的工具类</p>
<pre><code class="language-java">public class MybatisUtils {
    private static SqlSessionFactory sqlSessionFactory;
    static {
        try{
            //获取 SqlSessionFactory 对象
            String resource = &quot;mybatis-config.xml&quot;;
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        }catch(IOException e){
            e.printStackTrace();
        }
    }
    //获取sqlSession实例
    public static SqlSession getSqlSession(){
         //true表示自动提交
         return sqlSessionFactory.openSession(true);
    }
}
</code></pre>
<h4 id="42-当parametertype-有多个参数">4.2 当parameterType 有多个参数</h4>
<p>使用注解的方法----------<mark>@Param</mark></p>
<pre><code class="language-java">User getUserById(@Param(&quot;id&quot;) int id,@Param(&quot;name&quot;) String name);
</code></pre>
<p>无论是采用注解进行增删改查还是用xml, 其他的照常写</p>
<p><mark><strong>注意</strong>! 在写sql语句提取参数的时候,要写@Param里的参数名字</mark></p>
<h4 id="43-增删改查">4.3 增删改查</h4>
<ul>
<li>
<p><strong>@Select(&quot;sql语句&quot;)              查</strong></p>
</li>
<li>
<p><strong>@Insert(&quot;sql语句&quot;)              增</strong></p>
</li>
<li>
<p><strong>@Delete(&quot;sql语句&quot;)             删</strong></p>
</li>
<li>
<p><strong>@Update(&quot;sql语句&quot;)           改</strong></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[6-分页]]></title>
        <id>https://aruul.github.io/post/INzAInTDR/</id>
        <link href="https://aruul.github.io/post/INzAInTDR/">
        </link>
        <updated>2021-03-15T12:20:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-使用limit实现分页">一 、使用limit实现分页</h3>
<h4 id="1分页-sql语句">1.分页  sql语句</h4>
<pre><code class="language-xml">select * from limit startIndex, pageSize
</code></pre>
<ul>
<li>
<blockquote>
<p>startIndex   开始序号</p>
</blockquote>
</li>
<li>
<blockquote>
<p>pageSize    一页的大小</p>
</blockquote>
</li>
</ul>
<p>例如</p>
<pre><code class="language-xml">&lt;!--从第0个开始查询，每两个为一页--&gt;
select * from 表名 limit 0, 2

&lt;!--从第0个开始查询，每两个为一页--&gt;
select * from limit 0, 2
</code></pre>
<h4 id="2代码部分">2.代码部分</h4>
<p>Dao层代码</p>
<pre><code class="language-java">    //分页查询
    List&lt;User&gt; getUserByLimit(Map&lt;String,Object&gt;map);
</code></pre>
<pre><code class="language-xml">    &lt;select id=&quot;getUserByLimit&quot; resultType=&quot;user&quot; parameterType=&quot;map&quot;&gt;
        select * from mybatis.user limit #{startIndex},#{pageSize}
    &lt;/select&gt;
</code></pre>
<pre><code class="language-java"> @Test
    public void getUserByLimit(){
        SqlSession sqlSession=MybatisUtils.getSqlSession();
        UserMapper userMapper=sqlSession.getMapper(UserMapper.class);

        Map&lt;String,Object&gt; map=new HashMap&lt;String, Object&gt;();
        map.put(&quot;startIndex&quot;,0);
        map.put(&quot;pageSize&quot;,2);
        List&lt;User&gt; userList=userMapper.getUserByLimit(map);
        for (User user : userList) {
            System.out.println(user);
        }
    }
</code></pre>
<hr>
<h3 id="二-rowbounds分页不常用">二、RowBounds分页【不常用】</h3>
<p>略，懒得写了</p>
<hr>
<h3 id="三-插件">三、插件</h3>
<p><a href="https://pagehelper.github.io/">Mybatis PageHelper 插件</a></p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/aruul/a-ru-img/raw/master/img/20210315202015.png" alt="image-20210314201120021" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[5-日志]]></title>
        <id>https://aruul.github.io/post/vKl9jV0iW/</id>
        <link href="https://aruul.github.io/post/vKl9jV0iW/">
        </link>
        <updated>2021-03-15T03:19:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1日志工厂">1.日志工厂</h3>
<p>Mybatis 通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一：</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j 2</li>
<li>Log4j   【掌握】</li>
<li>STDOUT_LOGGING （标准日志输出）【掌握】</li>
<li>JDK logging</li>
</ul>
<p>MyBatis 内置日志工厂会基于运行时检测信息选择日志委托实现。它会（按上面罗列的顺序）使用第一个查找到的实现。当没有找到这些实现时，将会禁用日志功能。</p>
<hr>
<p><strong>STDOUT_LOGGING</strong> （标准日志输出）</p>
<pre><code class="language-xml">&lt;!--设置日志--&gt;
&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<hr>
<p><strong>Log4j</strong></p>
<ol>
<li>
<p>导包</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>--未完待续</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4-常见parameterType的别名]]></title>
        <id>https://aruul.github.io/post/-bkx04iBA/</id>
        <link href="https://aruul.github.io/post/-bkx04iBA/">
        </link>
        <updated>2021-03-14T14:17:44.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th style="text-align:left">别名</th>
<th style="text-align:left">映射的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">_byte</td>
<td style="text-align:left">byte</td>
</tr>
<tr>
<td style="text-align:left">_long</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:left">_short</td>
<td style="text-align:left">short</td>
</tr>
<tr>
<td style="text-align:left">_int</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">_integer</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">_double</td>
<td style="text-align:left">double</td>
</tr>
<tr>
<td style="text-align:left">_float</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">_boolean</td>
<td style="text-align:left">boolean</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">String</td>
</tr>
<tr>
<td style="text-align:left">byte</td>
<td style="text-align:left">Byte</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">Long</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">Short</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">Integer</td>
</tr>
<tr>
<td style="text-align:left">integer</td>
<td style="text-align:left">Integer</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">Double</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">Float</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">Boolean</td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:left">Date</td>
</tr>
<tr>
<td style="text-align:left">decimal</td>
<td style="text-align:left">BigDecimal</td>
</tr>
<tr>
<td style="text-align:left">bigdecimal</td>
<td style="text-align:left">BigDecimal</td>
</tr>
<tr>
<td style="text-align:left">object</td>
<td style="text-align:left">Object</td>
</tr>
<tr>
<td style="text-align:left">map</td>
<td style="text-align:left">Map</td>
</tr>
<tr>
<td style="text-align:left">hashmap</td>
<td style="text-align:left">HashMap</td>
</tr>
<tr>
<td style="text-align:left">list</td>
<td style="text-align:left">List</td>
</tr>
<tr>
<td style="text-align:left">arraylist</td>
<td style="text-align:left">ArrayList</td>
</tr>
<tr>
<td style="text-align:left">collection</td>
<td style="text-align:left">Collection</td>
</tr>
<tr>
<td style="text-align:left">iterator</td>
<td style="text-align:left">Iterator</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3-一些小的知识点]]></title>
        <id>https://aruul.github.io/post/O6XvSvJBQ/</id>
        <link href="https://aruul.github.io/post/O6XvSvJBQ/">
        </link>
        <updated>2021-03-14T13:15:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1map和模糊查询">1.Map和模糊查询</h3>
<p>可以把map中的key直接提取出来</p>
<pre><code class="language-java">-----Dao文件  
//采用Map的形式来传值
    int updateUserByMap(Map&lt;String,Object&gt; map);
</code></pre>
<pre><code class="language-xml">---dao对应的xml文件 
-----------------------------Map对用的parameterType为&quot;map&quot;
&lt;update id=&quot;updateUserByMap&quot; parameterType=&quot;map&quot;&gt;
        update mybatis.user set name = #{userName} where id = #{userId};
 &lt;/update&gt;
</code></pre>
<pre><code class="language-java">---------测试的Java代码
@Test
    public void updateUserByMap(){
        SqlSession sqlSession= MybatisUtils.getSqlSession();
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

       //map
        Map&lt;String,Object&gt; mapp = new HashMap&lt;String,Object&gt;();
        mapp.put(&quot;userName&quot;,&quot;测试3&quot;);
        mapp.put(&quot;userId&quot;,4);

        int res= userMapper.updateUserByMap(mapp);
        System.out.println(res);
        if(res&gt;0){
            System.out.println(&quot;修改成功&quot;);
            System.out.println(&quot;-----------------------------------&quot;);
            List&lt;User&gt; userList= userMapper.getUserList();
            for (User user : userList) {
                System.out.println(user);
            }
        }
        //提交事务
        sqlSession.commit();
        sqlSession.close();
    }
</code></pre>
<hr>
<h3 id="2模糊查询">2.模糊查询</h3>
<p>sql 模糊查询的语句是like%&quot;要查的内容&quot;%</p>
<pre><code class="language-java">    //模糊查询
    List&lt;User&gt; getUserByLike(String name);
</code></pre>
<pre><code class="language-xml">    &lt;select id=&quot;getUserByLike&quot; resultType=&quot;org.example.pojo.User&quot;&gt;
        select * from mybatis.user where name like #{name}
    &lt;/select&gt;
</code></pre>
<pre><code class="language-java">@Test
    public void getUserByLike(){
        SqlSession sqlSession= MybatisUtils.getSqlSession();
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

        System.out.println(&quot;模糊查找成功&quot;);
        System.out.println(&quot;-----------------------------------&quot;);
        List&lt;User&gt; userList= userMapper.getUserByLike(&quot;%李%&quot;);
        for (User user : userList) {
            System.out.println(user);
        }
        sqlSession.close();
    }
</code></pre>
<hr>
<h3 id="3-配置解析">3. 配置解析</h3>
<h4 id="31-总览">3.1 总览</h4>
<ul>
<li>
<p>官方建议把配置文件命名为 <strong>mybatis-config.xml</strong></p>
<p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：</p>
</li>
<li>
<p>configuration（配置）</p>
<ul>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li>
<li>environments（环境配置）
<ul>
<li>environment（环境变量）
<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li>
</ul>
</li>
</ul>
<h4 id="32-environments环境配置">3.2 environments（环境配置）</h4>
<p>environments 元素定义了如何配置环境,如下所示的例子：</p>
<pre><code class="language-xml">&lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt; 
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;amp;useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    
    &lt;environment id=&quot;test&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;amp;useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
&lt;/environments&gt;
</code></pre>
<p>注意一些关键点:</p>
<ul>
<li>
<p><strong>默认使用的环境 ID（比如：default=&quot;development&quot;）。</strong></p>
</li>
<li>
<p><strong>每个 environment 元素定义的环境 ID（比如：id=&quot;development&quot;）。</strong></p>
</li>
<li>
<p>事务管理器的配置（比如：type=&quot;JDBC&quot;）。</p>
<p>​      在 MyBatis 中有两种类型的事务管理器（也就是 type=&quot;[JDBC|MANAGED]&quot;）</p>
<ul>
<li>
<p>JDBC               这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。</p>
</li>
<li>
<p>MANAGED    这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为</p>
<pre><code class="language-xml">&lt;transactionManager type=&quot;MANAGED&quot;&gt;
  &lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&gt;
&lt;/transactionManager&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p>数据源的配置（比如：type=&quot;POOLED&quot;）。</p>
<p>​       dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
<p>​        有三种内建的数据源类型（也就是 type=&quot;[UNPOOLED|POOLED|JNDI]&quot;）：</p>
<p><strong>POOLED</strong>– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。</p>
<hr>
<p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p>
<ul>
<li><strong>每个数据库对应一个 SqlSessionFactory 实例</strong></li>
</ul>
<p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p>
<pre><code class="language-java">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment);
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);
</code></pre>
<p>如果忽略了环境参数，那么将会加载默认环境，如下所示：</p>
<pre><code class="language-java">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader);  //比较常用
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);
</code></pre>
</li>
</ul>
<hr>
<h3 id="4别名优化">4.别名优化</h3>
<p>类型别名可为 Java 类型设置一个缩写名字，<strong>意在降低冗余的全限定类名书写</strong>。</p>
<h5 id="41-在xml文件中为每个类起别名">4.1 在xml文件中为每个类起别名</h5>
<p>例如：</p>
<pre><code class="language-xml">&lt;typeAliases&gt;
  &lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&gt;
  &lt;typeAlias alias=&quot;Blog&quot; type=&quot;domain.blog.Blog&quot;/&gt;
  &lt;typeAlias alias=&quot;Comment&quot; type=&quot;domain.blog.Comment&quot;/&gt;
  &lt;typeAlias alias=&quot;Post&quot; type=&quot;domain.blog.Post&quot;/&gt;
  &lt;typeAlias alias=&quot;Section&quot; type=&quot;domain.blog.Section&quot;/&gt;
  &lt;typeAlias alias=&quot;Tag&quot; type=&quot;domain.blog.Tag&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p>
<h5 id="42-指定一个包名">4.2 指定一个包名</h5>
<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：</p>
<pre><code class="language-xml">&lt;typeAliases&gt;
  &lt;package name=&quot;domain.blog&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的<strong>首字母小写的</strong>非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；</p>
<h5 id="43-注解">4.3 注解</h5>
<p>若有注解，则别名为其注解值。见下面的例子：</p>
<pre><code class="language-java">@Alias(&quot;author&quot;)
public class Author {
    ...
}
</code></pre>
<hr>
<h3 id="5-映射器mappers">5. 映射器（mappers）</h3>
<p>映射器要来定义 SQL 映射语句。</p>
<p>但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。</p>
<p>你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等。例如：</p>
<pre><code class="language-xml">&lt;!-- 使用相对于类路径的资源引用   【推荐使用】 --&gt;
&lt;mappers&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&gt;
  &lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;
&lt;!-- 使用完全限定资源定位符（URL） --&gt;
&lt;mappers&gt;
  &lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&gt;
  &lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&gt;
  &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;
&lt;/mappers&gt;
&lt;!-- 使用映射器接口实现类的完全限定类名  
**接口和他的Mapper配置文件必须同名**    
**接口和他的Mapper配置文件必须在同一个包下** --&gt;
&lt;mappers&gt;
  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;
&lt;/mappers&gt;
&lt;!-- 将包内的映射器接口实现全部注册为映射器 
**接口和他的Mapper配置文件必须同名**    
**接口和他的Mapper配置文件必须在同一个包下** --&gt;
&lt;mappers&gt;
  &lt;package name=&quot;org.mybatis.builder&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>这些配置会告诉 MyBatis 去哪里找映射文件。</p>
<ul>
<li>
<p><strong>注意 在使用映射器接口实现类的完全限定类名时  和   将包内的映射器接口实现全部注册为映射器</strong></p>
<p><strong>接口和他的Mapper配置文件必须同名</strong></p>
<p><strong>接口和他的Mapper配置文件必须在同一个包下</strong></p>
<pre><code class="language-xml">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;
&lt;mappers&gt;
  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.BlogMapper&quot;/&gt;
  &lt;mapper class=&quot;org.mybatis.builder.PostMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<hr>
</li>
</ul>
<h3 id="6解决属性名和字段名不一致的问题">6.解决属性名和字段名不一致的问题</h3>
<p>就是java代码的属性名和数据库字段的名字不一致的问题</p>
<pre><code>比如 
数据库字段为  id name pwd

java属性名为 id name password
</code></pre>
<h4 id="61-起别名">6.1 起别名</h4>
<pre><code class="language-xml">&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;org.example.pojo.User&quot;&gt;
    select id,name,pwd as password from mybatis.user where id=#{id}
&lt;/select&gt;
</code></pre>
<h4 id="62-resultmap">6.2 resultMap</h4>
<p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。</p>
<pre><code class="language-xml">&lt;!--结果集映射，id是名字，type是结果类型，数据库中的列和java代码的属性相对应--&gt;
&lt;resultMap id=&quot;UserMap&quot; type=&quot;org.example.pojo.User&quot;&gt;
    &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;
    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt; 
&lt;!--resultMap 引用的上面id为&quot;UserMap&quot;的resultMap--&gt;
&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;UserMap&quot;&gt;
    select * from mybatis.user where id=#{id}
&lt;/select&gt;
</code></pre>
<hr>
<h3 id="7-和的区别">7. #{}和${}的区别</h3>
<blockquote>
<p>a、#{}是预编译处理，${}是字符串替换。</p>
<p>b、Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值；<br>
c、Mybatis 在处理<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow></mrow><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">把</mi></mrow><annotation encoding="application/x-tex">{}时，就是把</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord"></span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">把</span></span></span></span>{}替换成变量的值。<br>
d、使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2-增删改查]]></title>
        <id>https://aruul.github.io/post/PjBvXe767/</id>
        <link href="https://aruul.github.io/post/PjBvXe767/">
        </link>
        <updated>2021-03-14T12:10:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1每一个dao接口对应一个xml文件">1.每一个Dao接口对应一个xml文件</h3>
<ul>
<li>最好名字要一致，方便管理</li>
</ul>
<pre><code class="language-java">//Dao接口
public interface UserMapper {
    //查询全部用户
    List&lt;User&gt; getUserList();
    //根据id查询用户
    User getUserById(int id);
    //添加用户
    int insertUser(User user);
    //修改
    int updateUser(User user);
    //删除
    int deleteUser(int id);
}
</code></pre>
<p>对应的xml文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;!--namespace 是要绑定的类的路径--&gt;
&lt;mapper namespace=&quot;org.example.dao.UserMapper&quot;&gt;
    &lt;!--进行查询操作  id是对应类的方法名 resultType是返回的结果集--&gt;
    &lt;select id=&quot;getUserList&quot; resultType=&quot;org.example.pojo.User&quot;&gt;
        select * from mybatis.user
    &lt;/select&gt;

    &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;org.example.pojo.User&quot;&gt;
        select * from mybatis.user where id=#{id}
    &lt;/select&gt;

    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;org.example.pojo.User&quot;&gt;
        insert into mybatis.user (id, name, pwd) values (#{id},#{name},#{pwd})
    &lt;/insert&gt;

    &lt;update id=&quot;updateUser&quot; parameterType=&quot;org.example.pojo.User&quot;&gt;
        update mybatis.user set name = #{name},pwd = #{pwd} where id = #{id};
    &lt;/update&gt;

    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
        delete from mybatis.user where id = #{id}
    &lt;/delete&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="2xml文件编写规则">2.xml文件编写规则</h3>
<ul>
<li>
<p>xml文件注意事项</p>
<pre><code class="language-xml">&lt;mapper namespace=&quot;org.example.dao.UserMapper&quot;&gt;&lt;/mapper&gt;
</code></pre>
<p>namespace是对应Dao文件的java路径</p>
<hr>
<p>以id查询为例</p>
<pre><code class="language-java"> //根据id查询用户 java代码
    User getUserById(int id);
</code></pre>
</li>
</ul>
<pre><code class="language-xml">  &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;org.example.pojo.User&quot;&gt;
        select * from mybatis.user where id=#{id}
    &lt;/select&gt;
</code></pre>
<p><strong>id为Dao接口中对应的方法名           parameterType是方法中参数的类型       resultType是sql语句执行狗返回的结果类型</strong></p>
<ul>
<li>
<p>sql语法</p>
<p>遵从基本的sql语法，</p>
<p><strong>可以通过#{属性}的写法来获取参数中的值</strong></p>
<h3 id="3测试">3.测试</h3>
<ul>
<li>注意在删除、修改操作的时候要提交事务</li>
<li>注意要关闭事务</li>
</ul>
<pre><code class="language-java">@Test
    public void getUserById(){
        //获取sqlSession实例
        SqlSession sqlSession= MybatisUtils.getSqlSession();
        //获取Dao层类的实例
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        //调用对用Dao层类的方法
        User user=userMapper.getUserById(1);
        System.out.println(user);
		//关闭事务
        sqlSession.close();
    }

    @Test
    public void insertUser(){
        SqlSession sqlSession= MybatisUtils.getSqlSession();
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

        int res= userMapper.insertUser(new User(4,&quot;测试&quot;,&quot;000000&quot;));
        if(res&gt;0){
            System.out.println(&quot;插入成功&quot;);
            System.out.println(&quot;-----------------------------------&quot;);
            List&lt;User&gt; userList= userMapper.getUserList();
            for (User user : userList) {
                System.out.println(user);
            }
        }

        //提交事务
        sqlSession.commit();
        //关闭事务
        sqlSession.close();
    }
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[创建第一个myBatis项目]]></title>
        <id>https://aruul.github.io/post/5z4z3U_A7/</id>
        <link href="https://aruul.github.io/post/5z4z3U_A7/">
        </link>
        <updated>2021-03-11T03:08:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="注意使用的是idea202032版本-mysql8-022">注意：使用的是idea2020.3.2版本  mysql8. 0.22</h3>
<h3 id="1创建一个默认的maven项目">1.创建一个默认的maven项目</h3>
<p>就是idea里点击maven，什么都不选，默认打开就行；</p>
<p>删除src目录</p>
<p>新建一个Module文件,作为子项目</p>
<h3 id="2导入依赖">2.导入依赖</h3>
<p>在父项目的pom.xml文件中导入所需依赖  mysql驱动、 mybatis 、junit</p>
<pre><code class="language-xml">&lt;!--导入依赖--&gt;
    &lt;dependencies&gt;
        &lt;!--mysql驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.22&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p><strong>注意：除此之外还要在配置pom.xml文件中添加下面的代码</strong></p>
<pre><code class="language-xml">&lt;!--配置resources，防止资源导出失败--&gt;
    &lt;build&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
</code></pre>
<h3 id="3在新建的module文件下编写代码">3.在新建的Module文件下编写代码</h3>
<h4 id="30-编写全局配置文件-mybatis-configxml">3.0 编写全局配置文件 <strong>mybatis-config.xml</strong></h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;!--设置日志--&gt;
    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;/settings&gt;

    &lt;typeAliases&gt;
        &lt;package name=&quot;org.example.pojo&quot;/&gt;
    &lt;/typeAliases&gt;

    &lt;!--环境配置--&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Asia/Shanghai&amp;amp;useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!--mapper映射--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;org/example/dao/UserMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h4 id="31实体类pojo">3.1实体类（pojo）</h4>
<pre><code class="language-java">public class User {
    private int id;
    private String name;
    private String pwd;

    public User() {
    }

    public User(int id, String name, String pwd) {
        this.id = id;
        this.name = name;
        this.pwd = pwd;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPwd() {
        return pwd;
    }

    public void setPwd(String pwd) {
        this.pwd = pwd;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, pwd='&quot; + pwd + '\'' +
                '}';
    }
}
</code></pre>
<h4 id="32dao接口">3.2Dao接口</h4>
<pre><code class="language-java">public interface UserDao {
    List&lt;User&gt; getUserList();
}
</code></pre>
<h4 id="33由xml文件实现dao接口">3.3由xml文件实现Dao接口</h4>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;!--namespace 是要绑定的类的路径--&gt;
&lt;mapper namespace=&quot;org.example.dao.UserDao&quot;&gt;
    &lt;!--进行查询操作  id是对应类的方法名 resultType sql语句执行是返回的值--&gt;
    &lt;select id=&quot;getUserList&quot; resultType=&quot;org.example.pojo.User&quot;&gt;
        select * from mybatis.user
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h4 id="34在-mybatis-configxml中绑定注册mapper">3.4在 <strong>mybatis-config.xml</strong>中绑定注册Mapper</h4>
<pre><code class="language-xml"> &lt;!--mapper映射--&gt;
&lt;mappers&gt;
    &lt;mapper resource=&quot;org/example/dao/UserMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<h4 id="35测试">3.5测试</h4>
<p>XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的<strong>资源文件</strong>进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p>
<p>​      <strong>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。</strong></p>
<p>​      <strong>SqlSessionFactory 的实例可以通SqlSessionFactoryBuilder 获得。</strong></p>
<p>​      <strong>而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</strong></p>
<pre><code class="language-java">//读取配置文件
String resource = &quot;mybatis-config.xml&quot;; 
InputStream inputStream = Resources.getResourceAsStream(resource);
//获取SqlSessionFactory实例
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);

public void test(){
    //从 SqlSessionFactory 中获取 SqlSession
    //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。
        SqlSession sqlSession= sqlSessionFactory.openSession();
      //SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。
      //通过getMapper方法得到Dao层的实例
        UserDao userDao= sqlSession.getMapper(UserDao.class);
      //通过调用Dao层实例的方法来操作数据库
        List&lt;User&gt; userList=userDao.getUserList();
        for (User user : userList) {
            System.out.println(user);
        }
      //关闭sqlSession
        sqlSession.close();

    }
</code></pre>
<hr>
<h3 id="4基本理论">4.基本理论</h3>
<h4 id="sqlsessionfactorybuilder">SqlSessionFactoryBuilder</h4>
<p>这个类可以被实例化、使用和丢弃，<strong>一旦创建了 SqlSessionFactory，就不再需要它了</strong>。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<h4 id="sqlsessionfactory">SqlSessionFactory</h4>
<p><strong>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在</strong>，<strong>没有任何理由丢弃它或重新创建另一个实例。</strong> 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h4 id="sqlsession">SqlSession</h4>
<p><strong>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的</strong>，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<pre><code>try (SqlSession session = sqlSessionFactory.openSession()) {
  // 你的应用逻辑代码
}
</code></pre>
<p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p>
<h4 id="映射器实例">映射器实例</h4>
<p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<pre><code>try (SqlSession session = sqlSessionFactory.openSession()) {
  BlogMapper mapper = session.getMapper(BlogMapper.class);
  // 你的应用逻辑代码
}
</code></pre>
]]></content>
    </entry>
</feed>